# 10.5 生产环境部署手册

> 微服务生产环境部署的完整指南，包含最佳实践和故障排除

## 📋 目录

- [10.5 生产环境部署手册](#105-生产环境部署手册)
  - [📋 目录](#-目录)
  - [部署前准备](#部署前准备)
    - [1. 环境检查清单](#1-环境检查清单)
      - [基础设施检查](#基础设施检查)
      - [应用配置检查](#应用配置检查)
    - [2. 资源配置要求](#2-资源配置要求)
      - [最小资源要求](#最小资源要求)
      - [推荐资源配置](#推荐资源配置)
    - [3. 安全配置](#3-安全配置)
      - [网络安全配置](#网络安全配置)
      - [安全上下文配置](#安全上下文配置)
  - [部署流程](#部署流程)
    - [1. 容器化部署](#1-容器化部署)
      - [Dockerfile优化](#dockerfile优化)
      - [容器构建脚本](#容器构建脚本)
    - [2. Kubernetes部署](#2-kubernetes部署)
      - [部署清单](#部署清单)
    - [3. 服务网格部署](#3-服务网格部署)
      - [Istio配置](#istio配置)
  - [监控与告警](#监控与告警)
    - [1. 指标监控](#1-指标监控)
      - [Prometheus配置](#prometheus配置)
      - [告警规则](#告警规则)
    - [2. 日志聚合](#2-日志聚合)
      - [Fluentd配置](#fluentd配置)
    - [3. 分布式追踪](#3-分布式追踪)
      - [Jaeger配置](#jaeger配置)
  - [故障排除](#故障排除)
    - [1. 常见问题](#1-常见问题)
      - [服务启动失败](#服务启动失败)
      - [性能问题诊断](#性能问题诊断)
    - [2. 性能调优](#2-性能调优)
      - [数据库优化](#数据库优化)
      - [应用优化](#应用优化)
    - [3. 安全事件处理](#3-安全事件处理)
      - [安全事件响应流程](#安全事件响应流程)
  - [维护操作](#维护操作)
    - [1. 滚动更新](#1-滚动更新)
      - [更新脚本](#更新脚本)
    - [2. 回滚策略](#2-回滚策略)
      - [回滚脚本](#回滚脚本)
    - [3. 数据备份](#3-数据备份)
      - [备份脚本](#备份脚本)
  - [总结](#总结)

## 部署前准备

### 1. 环境检查清单

#### 基础设施检查

```bash
#!/bin/bash
# 生产环境检查脚本

echo "🔍 开始生产环境检查..."

# 检查系统资源
echo "📊 检查系统资源..."
echo "CPU核心数: $(nproc)"
echo "内存总量: $(free -h | grep '^Mem:' | awk '{print $2}')"
echo "磁盘空间: $(df -h / | tail -1 | awk '{print $4}')"

# 检查网络连接
echo "🌐 检查网络连接..."
ping -c 3 8.8.8.8 > /dev/null && echo "✅ 外网连接正常" || echo "❌ 外网连接异常"
ping -c 3 kubernetes.default.svc.cluster.local > /dev/null && echo "✅ 集群内网连接正常" || echo "❌ 集群内网连接异常"

# 检查Docker
echo "🐳 检查Docker..."
docker --version > /dev/null && echo "✅ Docker已安装" || echo "❌ Docker未安装"
docker info > /dev/null && echo "✅ Docker服务正常" || echo "❌ Docker服务异常"

# 检查Kubernetes
echo "☸️ 检查Kubernetes..."
kubectl version --client > /dev/null && echo "✅ kubectl已安装" || echo "❌ kubectl未安装"
kubectl cluster-info > /dev/null && echo "✅ Kubernetes集群正常" || echo "❌ Kubernetes集群异常"

# 检查Helm
echo "⛵ 检查Helm..."
helm version > /dev/null && echo "✅ Helm已安装" || echo "❌ Helm未安装"

# 检查存储
echo "💾 检查存储..."
kubectl get storageclass > /dev/null && echo "✅ 存储类配置正常" || echo "❌ 存储类配置异常"

echo "✅ 环境检查完成"
```

#### 应用配置检查

```yaml
# 生产环境配置模板
apiVersion: v1
kind: ConfigMap
metadata:
  name: microservice-config
  namespace: production
data:
  # 应用配置
  APP_ENV: "production"
  LOG_LEVEL: "info"
  RUST_LOG: "info,microservice=debug"
  
  # 数据库配置
  DATABASE_URL: "postgresql://user:password@postgres-service:5432/microservice"
  DATABASE_MAX_CONNECTIONS: "50"
  DATABASE_MIN_CONNECTIONS: "10"
  DATABASE_CONNECTION_TIMEOUT: "30s"
  DATABASE_IDLE_TIMEOUT: "600s"
  
  # Redis配置
  REDIS_URL: "redis://redis-service:6379"
  REDIS_POOL_SIZE: "20"
  REDIS_TIMEOUT: "5s"
  
  # 服务配置
  SERVICE_NAME: "microservice"
  SERVICE_VERSION: "1.0.0"
  SERVICE_PORT: "8080"
  SERVICE_HOST: "0.0.0.0"
  
  # 监控配置
  METRICS_ENABLED: "true"
  METRICS_PORT: "9090"
  HEALTH_CHECK_INTERVAL: "30s"
  
  # 安全配置
  JWT_SECRET: "your-production-secret-key"
  JWT_EXPIRY: "24h"
  TLS_ENABLED: "true"
  
  # 性能配置
  MAX_REQUEST_SIZE: "10MB"
  REQUEST_TIMEOUT: "30s"
  KEEP_ALIVE_TIMEOUT: "75s"
  WORKER_THREADS: "4"
```

### 2. 资源配置要求

#### 最小资源要求

| 组件 | CPU | 内存 | 存储 | 网络 |
|------|-----|------|------|------|
| 微服务实例 | 0.5核 | 512MB | 1GB | 100Mbps |
| PostgreSQL | 1核 | 2GB | 20GB | 100Mbps |
| Redis | 0.5核 | 1GB | 5GB | 100Mbps |
| 监控组件 | 1核 | 2GB | 10GB | 100Mbps |
| 负载均衡器 | 0.5核 | 512MB | 1GB | 1Gbps |

#### 推荐资源配置

| 组件 | CPU | 内存 | 存储 | 网络 |
|------|-----|------|------|------|
| 微服务实例 | 2核 | 2GB | 5GB | 1Gbps |
| PostgreSQL | 4核 | 8GB | 100GB | 1Gbps |
| Redis | 2核 | 4GB | 20GB | 1Gbps |
| 监控组件 | 4核 | 8GB | 50GB | 1Gbps |
| 负载均衡器 | 2核 | 4GB | 10GB | 10Gbps |

### 3. 安全配置

#### 网络安全配置

```yaml
# 网络策略配置
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: microservice-network-policy
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: microservice
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: istio-system
    - podSelector:
        matchLabels:
          app: nginx-ingress
    ports:
    - protocol: TCP
      port: 8080
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: postgres
    ports:
    - protocol: TCP
      port: 5432
  - to:
    - podSelector:
        matchLabels:
          app: redis
    ports:
    - protocol: TCP
      port: 6379
  - to: []
    ports:
    - protocol: TCP
      port: 53
    - protocol: UDP
      port: 53
```

#### 安全上下文配置

```yaml
# Pod安全上下文
apiVersion: v1
kind: Pod
metadata:
  name: microservice-pod
spec:
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    runAsGroup: 1000
    fsGroup: 1000
    seccompProfile:
      type: RuntimeDefault
  containers:
  - name: microservice
    image: microservice:latest
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      runAsUser: 1000
      capabilities:
        drop:
        - ALL
    resources:
      requests:
        memory: "512Mi"
        cpu: "500m"
      limits:
        memory: "1Gi"
        cpu: "1000m"
```

## 部署流程

### 1. 容器化部署

#### Dockerfile优化

```dockerfile
# 多阶段构建Dockerfile
FROM rust:1.90-slim as builder

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    pkg-config \
    libssl-dev \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

# 设置工作目录
WORKDIR /app

# 复制Cargo文件
COPY Cargo.toml Cargo.lock ./

# 构建依赖
RUN cargo build --release --locked

# 复制源代码
COPY src ./src
COPY migrations ./migrations

# 构建应用
RUN cargo build --release --locked

# 运行时镜像
FROM debian:bookworm-slim

# 安装运行时依赖
RUN apt-get update && apt-get install -y \
    ca-certificates \
    libssl3 \
    libpq5 \
    && rm -rf /var/lib/apt/lists/*

# 创建非root用户
RUN groupadd -r microservice && useradd -r -g microservice microservice

# 设置工作目录
WORKDIR /app

# 复制二进制文件
COPY --from=builder /app/target/release/microservice /app/microservice
COPY --from=builder /app/migrations /app/migrations

# 设置权限
RUN chown -R microservice:microservice /app
USER microservice

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

# 暴露端口
EXPOSE 8080

# 启动命令
CMD ["./microservice"]
```

#### 容器构建脚本

```bash
#!/bin/bash
# 容器构建和推送脚本

set -e

# 配置变量
REGISTRY="your-registry.com"
IMAGE_NAME="microservice"
VERSION=${1:-latest}
NAMESPACE="production"

echo "🏗️ 开始构建容器镜像..."

# 构建镜像
docker build -t ${REGISTRY}/${IMAGE_NAME}:${VERSION} .
docker build -t ${REGISTRY}/${IMAGE_NAME}:latest .

echo "✅ 镜像构建完成"

# 运行安全扫描
echo "🔍 运行安全扫描..."
docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
    aquasec/trivy image ${REGISTRY}/${IMAGE_NAME}:${VERSION}

# 推送镜像
echo "📤 推送镜像到仓库..."
docker push ${REGISTRY}/${IMAGE_NAME}:${VERSION}
docker push ${REGISTRY}/${IMAGE_NAME}:latest

echo "✅ 镜像推送完成"

# 更新Kubernetes部署
echo "🚀 更新Kubernetes部署..."
kubectl set image deployment/microservice \
    microservice=${REGISTRY}/${IMAGE_NAME}:${VERSION} \
    -n ${NAMESPACE}

echo "✅ 部署更新完成"
```

### 2. Kubernetes部署

#### 部署清单

```yaml
# 完整的Kubernetes部署清单
apiVersion: apps/v1
kind: Deployment
metadata:
  name: microservice
  namespace: production
  labels:
    app: microservice
    version: v1
spec:
  replicas: 3
  selector:
    matchLabels:
      app: microservice
  template:
    metadata:
      labels:
        app: microservice
        version: v1
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9090"
        prometheus.io/path: "/metrics"
    spec:
      serviceAccountName: microservice
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 1000
      containers:
      - name: microservice
        image: your-registry.com/microservice:latest
        ports:
        - containerPort: 8080
          name: http
        - containerPort: 9090
          name: metrics
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: database-secret
              key: url
        - name: REDIS_URL
          valueFrom:
            configMapKeyRef:
              name: microservice-config
              key: REDIS_URL
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: jwt-secret
              key: secret
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 1000
          capabilities:
            drop:
            - ALL
        volumeMounts:
        - name: tmp
          mountPath: /tmp
        - name: migrations
          mountPath: /app/migrations
          readOnly: true
      volumes:
      - name: tmp
        emptyDir: {}
      - name: migrations
        configMap:
          name: migrations-config
      imagePullSecrets:
      - name: registry-secret
      nodeSelector:
        kubernetes.io/os: linux
      tolerations:
      - key: "node-role.kubernetes.io/master"
        operator: "Exists"
        effect: "NoSchedule"
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values:
                  - microservice
              topologyKey: kubernetes.io/hostname
---
apiVersion: v1
kind: Service
metadata:
  name: microservice-service
  namespace: production
  labels:
    app: microservice
spec:
  selector:
    app: microservice
  ports:
  - name: http
    port: 80
    targetPort: 8080
    protocol: TCP
  - name: metrics
    port: 9090
    targetPort: 9090
    protocol: TCP
  type: ClusterIP
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: microservice-hpa
  namespace: production
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: microservice
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 10
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
```

### 3. 服务网格部署

#### Istio配置

```yaml
# Istio Gateway配置
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: microservice-gateway
  namespace: production
spec:
  selector:
    istio: ingressgateway
  servers:
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
    - microservice.your-domain.com
    tls:
      httpsRedirect: true
  - port:
      number: 443
      name: https
      protocol: HTTPS
    hosts:
    - microservice.your-domain.com
    tls:
      mode: SIMPLE
      credentialName: microservice-tls
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: microservice-vs
  namespace: production
spec:
  hosts:
  - microservice.your-domain.com
  gateways:
  - microservice-gateway
  http:
  - match:
    - headers:
        version:
          exact: v2
    route:
    - destination:
        host: microservice-service
        subset: v2
      weight: 100
  - route:
    - destination:
        host: microservice-service
        subset: v1
      weight: 90
    - destination:
        host: microservice-service
        subset: v2
      weight: 10
    fault:
      delay:
        percentage:
          value: 0.1
        fixedDelay: 5s
    retries:
      attempts: 3
      perTryTimeout: 2s
      retryOn: 5xx,reset,connect-failure,refused-stream
    timeout: 30s
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: microservice-dr
  namespace: production
spec:
  host: microservice-service
  trafficPolicy:
    connectionPool:
      tcp:
        maxConnections: 100
      http:
        http1MaxPendingRequests: 50
        maxRequestsPerConnection: 10
        maxRetries: 3
        consecutiveGatewayErrors: 5
        interval: 30s
        baseEjectionTime: 30s
    outlierDetection:
      consecutive5xxErrors: 5
      interval: 30s
      baseEjectionTime: 30s
      maxEjectionPercent: 50
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
```

## 监控与告警

### 1. 指标监控

#### Prometheus配置

```yaml
# Prometheus配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-config
  namespace: monitoring
data:
  prometheus.yml: |
    global:
      scrape_interval: 15s
      evaluation_interval: 15s
    
    rule_files:
      - "alert_rules.yml"
    
    alerting:
      alertmanagers:
        - static_configs:
            - targets:
              - alertmanager:9093
    
    scrape_configs:
      - job_name: 'kubernetes-pods'
        kubernetes_sd_configs:
          - role: pod
        relabel_configs:
          - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
            action: keep
            regex: true
          - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
            action: replace
            target_label: __metrics_path__
            regex: (.+)
          - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]
            action: replace
            regex: ([^:]+)(?::\d+)?;(\d+)
            replacement: $1:$2
            target_label: __address__
          - action: labelmap
            regex: __meta_kubernetes_pod_label_(.+)
          - source_labels: [__meta_kubernetes_namespace]
            action: replace
            target_label: kubernetes_namespace
          - source_labels: [__meta_kubernetes_pod_name]
            action: replace
            target_label: kubernetes_pod_name
      
      - job_name: 'microservice'
        static_configs:
          - targets: ['microservice-service:9090']
        metrics_path: /metrics
        scrape_interval: 10s
```

#### 告警规则

```yaml
# 告警规则配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: alert-rules
  namespace: monitoring
data:
  alert_rules.yml: |
    groups:
    - name: microservice
      rules:
      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) / rate(http_requests_total[5m]) > 0.05
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High error rate detected"
          description: "Error rate is above 5% for 5 minutes"
      
      - alert: HighLatency
        expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High latency detected"
          description: "95th percentile latency is above 1 second"
      
      - alert: ServiceDown
        expr: up{job="microservice"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Service is down"
          description: "Microservice is not responding"
      
      - alert: HighMemoryUsage
        expr: (container_memory_usage_bytes / container_spec_memory_limit_bytes) > 0.8
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High memory usage"
          description: "Memory usage is above 80%"
      
      - alert: HighCPUUsage
        expr: (rate(container_cpu_usage_seconds_total[5m]) / container_spec_cpu_quota) > 0.8
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High CPU usage"
          description: "CPU usage is above 80%"
```

### 2. 日志聚合

#### Fluentd配置

```yaml
# Fluentd配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluentd-config
  namespace: logging
data:
  fluent.conf: |
    <source>
      @type tail
      path /var/log/containers/*microservice*.log
      pos_file /var/log/fluentd-containers.log.pos
      tag kubernetes.*
      format json
      time_key time
      time_format %Y-%m-%dT%H:%M:%S.%NZ
    </source>
    
    <filter kubernetes.**>
      @type kubernetes_metadata
    </filter>
    
    <filter kubernetes.**>
      @type parser
      key_name log
      reserve_data true
      <parse>
        @type json
      </parse>
    </filter>
    
    <match kubernetes.**>
      @type elasticsearch
      host elasticsearch.logging.svc.cluster.local
      port 9200
      index_name microservice-logs
      type_name _doc
      include_tag_key true
      tag_key @log_name
      flush_interval 1s
    </match>
```

### 3. 分布式追踪

#### Jaeger配置

```yaml
# Jaeger配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: jaeger-config
  namespace: tracing
data:
  jaeger.yaml: |
    collector:
      grpc:
        host-port: ":14250"
      http:
        host-port: ":14268"
      zipkin:
        host-port: ":9411"
    
    query:
      base-path: /jaeger
    
    agent:
      grpc:
        host-port: ":14250"
      http:
        host-port: ":14268"
      zipkin:
        host-port: ":9411"
    
    storage:
      type: elasticsearch
      elasticsearch:
        server-urls: http://elasticsearch.logging.svc.cluster.local:9200
        index-prefix: jaeger
        tags-as-fields:
          all: true
```

## 故障排除

### 1. 常见问题

#### 服务启动失败

```bash
#!/bin/bash
# 服务启动故障排除脚本

echo "🔍 检查服务启动状态..."

# 检查Pod状态
kubectl get pods -n production -l app=microservice

# 检查Pod日志
kubectl logs -n production -l app=microservice --tail=100

# 检查事件
kubectl get events -n production --sort-by='.lastTimestamp'

# 检查配置
kubectl describe configmap microservice-config -n production

# 检查密钥
kubectl describe secret database-secret -n production

# 检查服务
kubectl get svc -n production

# 检查端点
kubectl get endpoints -n production

echo "✅ 故障排除完成"
```

#### 性能问题诊断

```bash
#!/bin/bash
# 性能问题诊断脚本

echo "🔍 开始性能诊断..."

# 检查资源使用情况
kubectl top pods -n production
kubectl top nodes

# 检查HPA状态
kubectl get hpa -n production

# 检查网络策略
kubectl get networkpolicies -n production

# 检查服务网格配置
kubectl get virtualservice -n production
kubectl get destinationrule -n production

# 检查监控指标
kubectl port-forward -n monitoring svc/prometheus 9090:9090 &
sleep 5
curl -s "http://localhost:9090/api/v1/query?query=up" | jq

echo "✅ 性能诊断完成"
```

### 2. 性能调优

#### 数据库优化

```sql
-- PostgreSQL性能优化配置
-- 连接池配置
ALTER SYSTEM SET max_connections = 200;
ALTER SYSTEM SET shared_buffers = '256MB';
ALTER SYSTEM SET effective_cache_size = '1GB';
ALTER SYSTEM SET maintenance_work_mem = '64MB';
ALTER SYSTEM SET checkpoint_completion_target = 0.9;
ALTER SYSTEM SET wal_buffers = '16MB';
ALTER SYSTEM SET default_statistics_target = 100;

-- 索引优化
CREATE INDEX CONCURRENTLY idx_orders_user_id ON orders(user_id);
CREATE INDEX CONCURRENTLY idx_orders_created_at ON orders(created_at);
CREATE INDEX CONCURRENTLY idx_payments_order_id ON payments(order_id);

-- 查询优化
EXPLAIN ANALYZE SELECT * FROM orders WHERE user_id = $1 AND created_at > $2;
```

#### 应用优化

```rust
// 应用性能优化配置
use tokio::runtime::Runtime;
use std::sync::Arc;

pub struct OptimizedApp {
    runtime: Arc<Runtime>,
    db_pool: sqlx::PgPool,
    redis_pool: redis::Pool,
}

impl OptimizedApp {
    pub fn new() -> Self {
        // 创建优化的运行时
        let runtime = Arc::new(Runtime::new().unwrap());
        
        // 配置数据库连接池
        let db_pool = runtime.block_on(async {
            sqlx::PgPool::builder()
                .max_connections(50)
                .min_connections(10)
                .acquire_timeout(Duration::from_secs(30))
                .idle_timeout(Duration::from_secs(600))
                .build("postgresql://...")
                .await
                .unwrap()
        });
        
        // 配置Redis连接池
        let redis_pool = redis::Pool::builder()
            .max_size(20)
            .min_idle(Some(5))
            .connection_timeout(Duration::from_secs(5))
            .build("redis://...")
            .unwrap();
        
        Self {
            runtime,
            db_pool,
            redis_pool,
        }
    }
}
```

### 3. 安全事件处理

#### 安全事件响应流程

```bash
#!/bin/bash
# 安全事件响应脚本

echo "🚨 安全事件响应开始..."

# 1. 隔离受影响的Pod
kubectl get pods -n production -l app=microservice
kubectl delete pod <affected-pod> -n production

# 2. 检查日志
kubectl logs -n production -l app=microservice --since=1h | grep -i "error\|exception\|attack"

# 3. 检查网络流量
kubectl exec -n production <pod-name> -- netstat -tulpn

# 4. 检查文件系统
kubectl exec -n production <pod-name> -- find /app -type f -newer /app/microservice

# 5. 更新安全策略
kubectl apply -f security-policy.yaml

# 6. 通知安全团队
echo "安全事件已报告给安全团队"

echo "✅ 安全事件响应完成"
```

## 维护操作

### 1. 滚动更新

#### 更新脚本

```bash
#!/bin/bash
# 滚动更新脚本

set -e

VERSION=${1:-latest}
NAMESPACE="production"
DEPLOYMENT="microservice"

echo "🚀 开始滚动更新到版本: $VERSION"

# 检查当前状态
kubectl get deployment $DEPLOYMENT -n $NAMESPACE

# 执行滚动更新
kubectl set image deployment/$DEPLOYMENT \
    microservice=your-registry.com/microservice:$VERSION \
    -n $NAMESPACE

# 等待更新完成
kubectl rollout status deployment/$DEPLOYMENT -n $NAMESPACE --timeout=300s

# 验证更新
kubectl get pods -n $NAMESPACE -l app=microservice
kubectl get deployment $DEPLOYMENT -n $NAMESPACE

echo "✅ 滚动更新完成"
```

### 2. 回滚策略

#### 回滚脚本

```bash
#!/bin/bash
# 回滚脚本

set -e

NAMESPACE="production"
DEPLOYMENT="microservice"
REVISION=${1:-""}

echo "🔄 开始回滚操作..."

# 查看回滚历史
kubectl rollout history deployment/$DEPLOYMENT -n $NAMESPACE

if [ -z "$REVISION" ]; then
    # 回滚到上一个版本
    kubectl rollout undo deployment/$DEPLOYMENT -n $NAMESPACE
else
    # 回滚到指定版本
    kubectl rollout undo deployment/$DEPLOYMENT --to-revision=$REVISION -n $NAMESPACE
fi

# 等待回滚完成
kubectl rollout status deployment/$DEPLOYMENT -n $NAMESPACE --timeout=300s

# 验证回滚
kubectl get pods -n $NAMESPACE -l app=microservice
kubectl get deployment $DEPLOYMENT -n $NAMESPACE

echo "✅ 回滚完成"
```

### 3. 数据备份

#### 备份脚本

```bash
#!/bin/bash
# 数据备份脚本

set -e

BACKUP_DIR="/backup/$(date +%Y%m%d_%H%M%S)"
NAMESPACE="production"

echo "💾 开始数据备份..."

# 创建备份目录
mkdir -p $BACKUP_DIR

# 备份PostgreSQL
kubectl exec -n $NAMESPACE postgres-0 -- pg_dump -U postgres microservice > $BACKUP_DIR/postgres_backup.sql

# 备份Redis
kubectl exec -n $NAMESPACE redis-0 -- redis-cli BGSAVE
kubectl cp $NAMESPACE/redis-0:/data/dump.rdb $BACKUP_DIR/redis_backup.rdb

# 备份配置文件
kubectl get configmap -n $NAMESPACE -o yaml > $BACKUP_DIR/configmaps.yaml
kubectl get secret -n $NAMESPACE -o yaml > $BACKUP_DIR/secrets.yaml

# 备份Kubernetes资源
kubectl get all -n $NAMESPACE -o yaml > $BACKUP_DIR/resources.yaml

# 压缩备份
tar -czf $BACKUP_DIR.tar.gz $BACKUP_DIR
rm -rf $BACKUP_DIR

echo "✅ 数据备份完成: $BACKUP_DIR.tar.gz"
```

## 总结

本生产环境部署手册提供了完整的部署、监控、故障排除和维护指南：

1. **部署前准备**：环境检查、资源配置、安全配置
2. **部署流程**：容器化、Kubernetes、服务网格部署
3. **监控与告警**：指标监控、日志聚合、分布式追踪
4. **故障排除**：常见问题、性能调优、安全事件处理
5. **维护操作**：滚动更新、回滚策略、数据备份

通过遵循本手册，可以确保微服务在生产环境中的稳定运行和高效维护。
