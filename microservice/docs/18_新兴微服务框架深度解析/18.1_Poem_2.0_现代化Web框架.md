# Poem 2.0 现代化Web框架

> 深入探索Poem 2.0框架在微服务开发中的高级应用和最佳实践

## 📋 目录

- [Poem 2.0 现代化Web框架](#poem-20-现代化web框架)
  - [📋 目录](#-目录)
  - [概述](#概述)
    - [主要优势](#主要优势)
  - [Poem 2.0 核心特性](#poem-20-核心特性)
    - [1. 路由系统](#1-路由系统)
    - [2. 中间件系统](#2-中间件系统)
    - [3. 错误处理](#3-错误处理)
  - [微服务架构集成](#微服务架构集成)
    - [1. 服务发现集成](#1-服务发现集成)
    - [2. 负载均衡集成](#2-负载均衡集成)
    - [3. 熔断器集成](#3-熔断器集成)
  - [高级功能应用](#高级功能应用)
    - [1. OpenAPI集成](#1-openapi集成)
    - [2. GraphQL集成](#2-graphql集成)
  - [性能优化策略](#性能优化策略)
    - [1. 连接池管理](#1-连接池管理)
    - [2. 缓存策略](#2-缓存策略)
  - [实际代码示例](#实际代码示例)
    - [1. 完整的微服务应用](#1-完整的微服务应用)
    - [2. 中间件开发](#2-中间件开发)
  - [最佳实践](#最佳实践)
    - [1. 错误处理策略](#1-错误处理策略)
    - [2. 配置管理](#2-配置管理)
    - [3. 监控和指标](#3-监控和指标)
  - [总结](#总结)
    - [主要优势1](#主要优势1)
    - [应用场景](#应用场景)
    - [最佳实践1](#最佳实践1)

## 概述

Poem 2.0是一个现代化的Rust Web框架，专为高性能微服务开发而设计。
它提供了简洁的API、强大的类型安全性和出色的性能表现，特别适合构建现代化的微服务架构。

### 主要优势

- **高性能**: 基于Tokio异步运行时，提供卓越的并发性能
- **类型安全**: 利用Rust的类型系统，确保编译时安全
- **简洁API**: 直观的API设计，降低学习成本
- **中间件支持**: 丰富的中间件生态系统
- **OpenAPI集成**: 内置OpenAPI 3.0支持
- **GraphQL支持**: 原生GraphQL支持

## Poem 2.0 核心特性

### 1. 路由系统

```rust
use poem::{get, handler, listener::TcpListener, middleware::Tracing, web::Path, EndpointExt, Route, Server};

#[handler]
async fn hello() -> &'static str {
    "Hello, Poem 2.0!"
}

#[handler]
async fn get_user(Path(id): Path<u64>) -> String {
    format!("User ID: {}", id)
}

#[handler]
async fn create_user(Json(payload): Json<CreateUserRequest>) -> Result<Json<User>, poem::Error> {
    // 创建用户逻辑
    let user = User {
        id: 1,
        name: payload.name,
        email: payload.email,
    };
    Ok(Json(user))
}

#[tokio::main]
async fn main() -> Result<(), std::io::Error> {
    let app = Route::new()
        .at("/", get(hello))
        .at("/users/:id", get(get_user))
        .at("/users", post(create_user))
        .with(Tracing);
    
    Server::new(TcpListener::bind("0.0.0.0:3000"))
        .run(app)
        .await
}
```

### 2. 中间件系统

```rust
use poem::{
    middleware::{Cors, Tracing, Compression},
    EndpointExt, Route,
};

// 自定义中间件
struct AuthMiddleware;

impl<E: Endpoint> Middleware<E> for AuthMiddleware {
    type Output = AuthMiddlewareImpl<E>;

    fn transform(&self, ep: E) -> Self::Output {
        AuthMiddlewareImpl { ep }
    }
}

struct AuthMiddlewareImpl<E> {
    ep: E,
}

#[poem::async_trait]
impl<E: Endpoint> Endpoint for AuthMiddlewareImpl<E> {
    type Output = E::Output;

    async fn call(&self, req: Request) -> Self::Output {
        // 认证逻辑
        if let Some(auth_header) = req.headers().get("Authorization") {
            if verify_token(auth_header).await {
                return self.ep.call(req).await;
            }
        }
        
        // 返回401未授权
        Response::builder()
            .status(StatusCode::UNAUTHORIZED)
            .body("Unauthorized")
    }
}

// 使用中间件
let app = Route::new()
    .at("/api/*", api_routes)
    .with(AuthMiddleware)
    .with(Cors::new())
    .with(Tracing)
    .with(Compression::new());
```

### 3. 错误处理

```rust
use poem::{error::Result, Error, Response, StatusCode};

#[derive(Debug, thiserror::Error)]
pub enum ApiError {
    #[error("用户不存在: {0}")]
    UserNotFound(u64),
    #[error("认证失败")]
    AuthenticationFailed,
    #[error("权限不足")]
    InsufficientPermissions,
    #[error("内部服务器错误: {0}")]
    InternalError(String),
}

impl From<ApiError> for Error {
    fn from(err: ApiError) -> Self {
        let status = match err {
            ApiError::UserNotFound(_) => StatusCode::NOT_FOUND,
            ApiError::AuthenticationFailed => StatusCode::UNAUTHORIZED,
            ApiError::InsufficientPermissions => StatusCode::FORBIDDEN,
            ApiError::InternalError(_) => StatusCode::INTERNAL_SERVER_ERROR,
        };
        
        Error::from_string(err.to_string(), status)
    }
}

#[handler]
async fn get_user(Path(id): Path<u64>) -> Result<Json<User>> {
    let user = find_user(id).await
        .ok_or(ApiError::UserNotFound(id))?;
    
    Ok(Json(user))
}
```

## 微服务架构集成

### 1. 服务发现集成

```rust
use poem::{handler, web::Json, EndpointExt, Route};
use std::sync::Arc;
use tokio::sync::RwLock;

// 服务注册表
#[derive(Clone)]
pub struct ServiceRegistry {
    services: Arc<RwLock<HashMap<String, ServiceInfo>>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceInfo {
    pub name: String,
    pub address: String,
    pub port: u16,
    pub health_check_url: String,
    pub metadata: HashMap<String, String>,
}

impl ServiceRegistry {
    pub fn new() -> Self {
        Self {
            services: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    pub async fn register_service(&self, service: ServiceInfo) {
        let mut services = self.services.write().await;
        services.insert(service.name.clone(), service);
    }
    
    pub async fn discover_service(&self, name: &str) -> Option<ServiceInfo> {
        let services = self.services.read().await;
        services.get(name).cloned()
    }
    
    pub async fn list_services(&self) -> Vec<ServiceInfo> {
        let services = self.services.read().await;
        services.values().cloned().collect()
    }
}

// 服务注册端点
#[handler]
async fn register_service(
    Json(service): Json<ServiceInfo>,
    Data(registry): Data<&ServiceRegistry>,
) -> Result<Json<RegisterResponse>> {
    registry.register_service(service.clone()).await;
    
    Ok(Json(RegisterResponse {
        success: true,
        message: format!("服务 {} 注册成功", service.name),
    }))
}

// 服务发现端点
#[handler]
async fn discover_service(
    Path(name): Path<String>,
    Data(registry): Data<&ServiceRegistry>,
) -> Result<Json<ServiceInfo>> {
    let service = registry.discover_service(&name).await
        .ok_or(ApiError::ServiceNotFound(name))?;
    
    Ok(Json(service))
}

// 健康检查端点
#[handler]
async fn health_check() -> Json<HealthStatus> {
    Json(HealthStatus {
        status: "healthy".to_string(),
        timestamp: chrono::Utc::now(),
        version: env!("CARGO_PKG_VERSION").to_string(),
    })
}
```

### 2. 负载均衡集成

```rust
use poem::{handler, web::Json, EndpointExt, Route};
use std::sync::Arc;
use tokio::sync::RwLock;

// 负载均衡器
#[derive(Clone)]
pub struct LoadBalancer {
    services: Arc<RwLock<Vec<ServiceInfo>>>,
    current_index: Arc<RwLock<usize>>,
    strategy: LoadBalanceStrategy,
}

#[derive(Debug, Clone)]
pub enum LoadBalanceStrategy {
    RoundRobin,
    Random,
    WeightedRoundRobin,
    LeastConnections,
}

impl LoadBalancer {
    pub fn new(strategy: LoadBalanceStrategy) -> Self {
        Self {
            services: Arc::new(RwLock::new(Vec::new())),
            current_index: Arc::new(RwLock::new(0)),
            strategy,
        }
    }
    
    pub async fn add_service(&self, service: ServiceInfo) {
        let mut services = self.services.write().await;
        services.push(service);
    }
    
    pub async fn select_service(&self) -> Option<ServiceInfo> {
        let services = self.services.read().await;
        if services.is_empty() {
            return None;
        }
        
        match self.strategy {
            LoadBalanceStrategy::RoundRobin => {
                let mut index = self.current_index.write().await;
                let selected = services[*index].clone();
                *index = (*index + 1) % services.len();
                Some(selected)
            }
            LoadBalanceStrategy::Random => {
                let index = rand::random::<usize>() % services.len();
                Some(services[index].clone())
            }
            LoadBalanceStrategy::WeightedRoundRobin => {
                // 实现加权轮询逻辑
                self.weighted_round_robin(&services).await
            }
            LoadBalanceStrategy::LeastConnections => {
                // 实现最少连接逻辑
                self.least_connections(&services).await
            }
        }
    }
    
    async fn weighted_round_robin(&self, services: &[ServiceInfo]) -> Option<ServiceInfo> {
        // 加权轮询实现
        let total_weight: u32 = services.iter()
            .map(|s| s.metadata.get("weight").unwrap_or(&"1".to_string()).parse::<u32>().unwrap_or(1))
            .sum();
        
        let mut index = self.current_index.write().await;
        let mut current_weight = 0;
        
        for (i, service) in services.iter().enumerate() {
            let weight = service.metadata.get("weight").unwrap_or(&"1".to_string()).parse::<u32>().unwrap_or(1);
            current_weight += weight;
            
            if current_weight >= total_weight {
                *index = (i + 1) % services.len();
                return Some(service.clone());
            }
        }
        
        None
    }
    
    async fn least_connections(&self, services: &[ServiceInfo]) -> Option<ServiceInfo> {
        // 最少连接实现
        services.iter()
            .min_by_key(|s| s.metadata.get("connections").unwrap_or(&"0".to_string()).parse::<u32>().unwrap_or(0))
            .cloned()
    }
}

// 代理请求端点
#[handler]
async fn proxy_request(
    Path(path): Path<String>,
    Data(load_balancer): Data<&LoadBalancer>,
) -> Result<Json<serde_json::Value>> {
    let service = load_balancer.select_service().await
        .ok_or(ApiError::NoAvailableServices)?;
    
    // 转发请求到选中的服务
    let client = reqwest::Client::new();
    let url = format!("http://{}:{}/{}", service.address, service.port, path);
    
    let response = client.get(&url).send().await
        .map_err(|e| ApiError::InternalError(e.to_string()))?;
    
    let data: serde_json::Value = response.json().await
        .map_err(|e| ApiError::InternalError(e.to_string()))?;
    
    Ok(Json(data))
}
```

### 3. 熔断器集成

```rust
use poem::{handler, web::Json, EndpointExt, Route};
use std::sync::Arc;
use tokio::sync::RwLock;
use std::time::{Duration, Instant};

// 熔断器
#[derive(Clone)]
pub struct CircuitBreaker {
    state: Arc<RwLock<CircuitState>>,
    failure_count: Arc<RwLock<u32>>,
    failure_threshold: u32,
    timeout: Duration,
    last_failure_time: Arc<RwLock<Option<Instant>>>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum CircuitState {
    Closed,
    Open,
    HalfOpen,
}

impl CircuitBreaker {
    pub fn new(failure_threshold: u32, timeout: Duration) -> Self {
        Self {
            state: Arc::new(RwLock::new(CircuitState::Closed)),
            failure_count: Arc::new(RwLock::new(0)),
            failure_threshold,
            timeout,
            last_failure_time: Arc::new(RwLock::new(None)),
        }
    }
    
    pub async fn call<F, T>(&self, f: F) -> Result<T, ApiError>
    where
        F: FnOnce() -> Result<T, ApiError>,
    {
        let state = *self.state.read().await;
        
        match state {
            CircuitState::Open => {
                if self.should_attempt_reset().await {
                    let mut state_guard = self.state.write().await;
                    *state_guard = CircuitState::HalfOpen;
                } else {
                    return Err(ApiError::CircuitBreakerOpen);
                }
            }
            CircuitState::HalfOpen => {
                // 允许一次尝试
            }
            CircuitState::Closed => {
                // 正常状态
            }
        }
        
        match f() {
            Ok(result) => {
                self.on_success().await;
                Ok(result)
            }
            Err(e) => {
                self.on_failure().await;
                Err(e)
            }
        }
    }
    
    async fn should_attempt_reset(&self) -> bool {
        let last_failure = *self.last_failure_time.read().await;
        if let Some(last_failure) = last_failure {
            last_failure.elapsed() >= self.timeout
        } else {
            true
        }
    }
    
    async fn on_success(&self) {
        let mut state = self.state.write().await;
        *state = CircuitState::Closed;
        
        let mut failure_count = self.failure_count.write().await;
        *failure_count = 0;
        
        let mut last_failure_time = self.last_failure_time.write().await;
        *last_failure_time = None;
    }
    
    async fn on_failure(&self) {
        let mut failure_count = self.failure_count.write().await;
        *failure_count += 1;
        
        let mut last_failure_time = self.last_failure_time.write().await;
        *last_failure_time = Some(Instant::now());
        
        if *failure_count >= self.failure_threshold {
            let mut state = self.state.write().await;
            *state = CircuitState::Open;
        }
    }
    
    pub async fn get_state(&self) -> CircuitState {
        *self.state.read().await
    }
}

// 使用熔断器的服务调用
#[handler]
async fn call_external_service(
    Data(circuit_breaker): Data<&CircuitBreaker>,
) -> Result<Json<serde_json::Value>> {
    let result = circuit_breaker.call(|| async {
        // 模拟外部服务调用
        let client = reqwest::Client::new();
        let response = client.get("https://api.example.com/data")
            .send()
            .await
            .map_err(|e| ApiError::InternalError(e.to_string()))?;
        
        let data: serde_json::Value = response.json().await
            .map_err(|e| ApiError::InternalError(e.to_string()))?;
        
        Ok(data)
    }).await?;
    
    Ok(Json(result))
}
```

## 高级功能应用

### 1. OpenAPI集成

```rust
use poem::{handler, web::Json, EndpointExt, Route};
use poem_openapi::{OpenApi, OpenApiService, payload::Json as OpenApiJson, ApiResponse, Object};

// 定义API响应类型
#[derive(Object, Serialize, Deserialize)]
pub struct User {
    pub id: u64,
    pub name: String,
    pub email: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Object, Serialize, Deserialize)]
pub struct CreateUserRequest {
    pub name: String,
    pub email: String,
}

#[derive(ApiResponse)]
pub enum UserResponse {
    #[oai(status = 200)]
    Ok(OpenApiJson<User>),
    #[oai(status = 404)]
    NotFound(OpenApiJson<ErrorResponse>),
    #[oai(status = 400)]
    BadRequest(OpenApiJson<ErrorResponse>),
}

#[derive(Object, Serialize, Deserialize)]
pub struct ErrorResponse {
    pub error: String,
    pub message: String,
}

// 定义API服务
pub struct UserApi;

#[OpenApi]
impl UserApi {
    /// 获取用户信息
    #[oai(path = "/users/:id", method = "get")]
    async fn get_user(&self, id: u64) -> UserResponse {
        match find_user(id).await {
            Some(user) => UserResponse::Ok(OpenApiJson(user)),
            None => UserResponse::NotFound(OpenApiJson(ErrorResponse {
                error: "USER_NOT_FOUND".to_string(),
                message: format!("用户 {} 不存在", id),
            })),
        }
    }
    
    /// 创建用户
    #[oai(path = "/users", method = "post")]
    async fn create_user(&self, req: OpenApiJson<CreateUserRequest>) -> UserResponse {
        let user = User {
            id: generate_user_id(),
            name: req.0.name,
            email: req.0.email,
            created_at: chrono::Utc::now(),
        };
        
        if save_user(&user).await {
            UserResponse::Ok(OpenApiJson(user))
        } else {
            UserResponse::BadRequest(OpenApiJson(ErrorResponse {
                error: "USER_CREATION_FAILED".to_string(),
                message: "创建用户失败".to_string(),
            }))
        }
    }
}

// 创建OpenAPI服务
let api_service = OpenApiService::new(UserApi, "用户服务", "1.0")
    .server("http://localhost:3000/api");

// 创建路由
let app = Route::new()
    .nest("/api", api_service)
    .nest("/docs", api_service.swagger_ui())
    .nest("/redoc", api_service.redoc());
```

### 2. GraphQL集成

```rust
use poem::{handler, web::Json, EndpointExt, Route};
use poem_graphql::{GraphQL, GraphQLSubscription, GraphQLRequest, GraphQLResponse};
use async_graphql::{Object, Schema, Subscription, EmptySubscription, Context, Result as GraphQLResult};

// 定义GraphQL类型
#[derive(Object)]
pub struct User {
    pub id: u64,
    pub name: String,
    pub email: String,
}

#[derive(Object)]
pub struct QueryRoot;

#[Object]
impl QueryRoot {
    async fn user(&self, ctx: &Context<'_>, id: u64) -> GraphQLResult<Option<User>> {
        // 从数据库获取用户
        let user = find_user(id).await;
        Ok(user.map(|u| User {
            id: u.id,
            name: u.name,
            email: u.email,
        }))
    }
    
    async fn users(&self, ctx: &Context<'_>) -> GraphQLResult<Vec<User>> {
        // 获取所有用户
        let users = find_all_users().await;
        Ok(users.into_iter().map(|u| User {
            id: u.id,
            name: u.name,
            email: u.email,
        }).collect())
    }
}

// 定义订阅
#[derive(Subscription)]
pub struct SubscriptionRoot;

#[Subscription]
impl SubscriptionRoot {
    async fn user_created(&self) -> impl Stream<Item = User> {
        // 实现用户创建事件流
        tokio_stream::wrappers::BroadcastStream::new(user_created_receiver)
            .filter_map(|result| async move {
                result.ok().map(|event| User {
                    id: event.id,
                    name: event.name,
                    email: event.email,
                })
            })
    }
}

// 创建GraphQL Schema
type MySchema = Schema<QueryRoot, EmptyMutation, SubscriptionRoot>;

// GraphQL处理器
#[handler]
async fn graphql_handler(
    req: GraphQLRequest,
    Data(schema): Data<&MySchema>,
) -> GraphQLResponse {
    schema.execute(req.0).await.into()
}

// GraphQL订阅处理器
#[handler]
async fn graphql_subscription_handler(
    req: GraphQLRequest,
    Data(schema): Data<&MySchema>,
) -> GraphQLSubscription {
    schema.subscription(req.0).into()
}

// 创建路由
let schema = Schema::new(QueryRoot, EmptyMutation, SubscriptionRoot);
let app = Route::new()
    .at("/graphql", post(graphql_handler).get(graphql_subscription_handler))
    .data(schema);
```

## 性能优化策略

### 1. 连接池管理

```rust
use poem::{handler, web::Json, EndpointExt, Route};
use std::sync::Arc;
use tokio::sync::RwLock;

// 数据库连接池
#[derive(Clone)]
pub struct DatabasePool {
    pool: Arc<sqlx::PgPool>,
}

impl DatabasePool {
    pub async fn new(database_url: &str) -> Result<Self, sqlx::Error> {
        let pool = sqlx::PgPool::connect(database_url).await?;
        Ok(Self {
            pool: Arc::new(pool),
        })
    }
    
    pub async fn get_connection(&self) -> Result<sqlx::PgConnection, sqlx::Error> {
        self.pool.acquire().await
    }
    
    pub async fn execute_query<T>(&self, query: &str) -> Result<Vec<T>, sqlx::Error>
    where
        T: for<'r> sqlx::FromRow<'r, sqlx::postgres::PgRow> + Send + Unpin,
    {
        let rows = sqlx::query_as::<_, T>(query)
            .fetch_all(&*self.pool)
            .await?;
        Ok(rows)
    }
}

// Redis连接池
#[derive(Clone)]
pub struct RedisPool {
    client: Arc<redis::Client>,
    connection_manager: Arc<redis::aio::ConnectionManager>,
}

impl RedisPool {
    pub async fn new(redis_url: &str) -> Result<Self, redis::RedisError> {
        let client = redis::Client::open(redis_url)?;
        let connection_manager = client.get_connection_manager().await?;
        
        Ok(Self {
            client: Arc::new(client),
            connection_manager: Arc::new(connection_manager),
        })
    }
    
    pub async fn get(&self, key: &str) -> Result<Option<String>, redis::RedisError> {
        let mut conn = self.connection_manager.clone();
        redis::cmd("GET").arg(key).query_async(&mut conn).await
    }
    
    pub async fn set(&self, key: &str, value: &str, ttl: Option<u64>) -> Result<(), redis::RedisError> {
        let mut conn = self.connection_manager.clone();
        let mut cmd = redis::cmd("SET").arg(key).arg(value);
        
        if let Some(ttl) = ttl {
            cmd = cmd.arg("EX").arg(ttl);
        }
        
        cmd.query_async(&mut conn).await
    }
}
```

### 2. 缓存策略

```rust
use poem::{handler, web::Json, EndpointExt, Route};
use std::sync::Arc;
use tokio::sync::RwLock;
use std::time::{Duration, Instant};

// 多级缓存
#[derive(Clone)]
pub struct MultiLevelCache {
    l1_cache: Arc<RwLock<HashMap<String, CacheEntry>>>>,
    l2_cache: Arc<RedisPool>,
    ttl: Duration,
}

#[derive(Debug, Clone)]
struct CacheEntry {
    value: String,
    expires_at: Instant,
}

impl MultiLevelCache {
    pub fn new(redis_pool: Arc<RedisPool>, ttl: Duration) -> Self {
        Self {
            l1_cache: Arc::new(RwLock::new(HashMap::new())),
            l2_cache: redis_pool,
            ttl,
        }
    }
    
    pub async fn get(&self, key: &str) -> Option<String> {
        // 首先检查L1缓存
        {
            let l1_cache = self.l1_cache.read().await;
            if let Some(entry) = l1_cache.get(key) {
                if entry.expires_at > Instant::now() {
                    return Some(entry.value.clone());
                }
            }
        }
        
        // 检查L2缓存
        if let Ok(Some(value)) = self.l2_cache.get(key).await {
            // 更新L1缓存
            let mut l1_cache = self.l1_cache.write().await;
            l1_cache.insert(key.to_string(), CacheEntry {
                value: value.clone(),
                expires_at: Instant::now() + self.ttl,
            });
            
            return Some(value);
        }
        
        None
    }
    
    pub async fn set(&self, key: &str, value: &str) -> Result<(), Box<dyn std::error::Error>> {
        // 设置L1缓存
        {
            let mut l1_cache = self.l1_cache.write().await;
            l1_cache.insert(key.to_string(), CacheEntry {
                value: value.to_string(),
                expires_at: Instant::now() + self.ttl,
            });
        }
        
        // 设置L2缓存
        self.l2_cache.set(key, value, Some(self.ttl.as_secs())).await?;
        
        Ok(())
    }
    
    pub async fn invalidate(&self, key: &str) -> Result<(), Box<dyn std::error::Error>> {
        // 清除L1缓存
        {
            let mut l1_cache = self.l1_cache.write().await;
            l1_cache.remove(key);
        }
        
        // 清除L2缓存
        let mut conn = self.l2_cache.connection_manager.clone();
        redis::cmd("DEL").arg(key).query_async(&mut conn).await?;
        
        Ok(())
    }
}

// 使用缓存的处理器
#[handler]
async fn get_cached_data(
    Path(key): Path<String>,
    Data(cache): Data<&MultiLevelCache>,
) -> Result<Json<serde_json::Value>> {
    if let Some(value) = cache.get(&key).await {
        let data: serde_json::Value = serde_json::from_str(&value)?;
        Ok(Json(data))
    } else {
        // 从数据库获取数据
        let data = fetch_from_database(&key).await?;
        
        // 缓存数据
        let value = serde_json::to_string(&data)?;
        cache.set(&key, &value).await?;
        
        Ok(Json(data))
    }
}
```

## 实际代码示例

### 1. 完整的微服务应用

```rust
use poem::{
    handler, listener::TcpListener, middleware::Tracing, web::{Json, Path, Data},
    EndpointExt, Route, Server,
};
use std::sync::Arc;
use tokio::sync::RwLock;

// 应用状态
#[derive(Clone)]
pub struct AppState {
    pub service_registry: ServiceRegistry,
    pub load_balancer: LoadBalancer,
    pub circuit_breaker: CircuitBreaker,
    pub database_pool: DatabasePool,
    pub redis_pool: RedisPool,
    pub cache: MultiLevelCache,
}

// 主应用处理器
#[handler]
async fn health_check() -> Json<HealthStatus> {
    Json(HealthStatus {
        status: "healthy".to_string(),
        timestamp: chrono::Utc::now(),
        version: env!("CARGO_PKG_VERSION").to_string(),
    })
}

#[handler]
async fn get_user(
    Path(id): Path<u64>,
    Data(state): Data<&AppState>,
) -> Result<Json<User>, ApiError> {
    // 使用熔断器保护数据库调用
    let user = state.circuit_breaker.call(|| async {
        // 首先检查缓存
        if let Some(cached_user) = state.cache.get(&format!("user:{}", id)).await {
            let user: User = serde_json::from_str(&cached_user)?;
            return Ok(user);
        }
        
        // 从数据库获取
        let user = find_user_from_db(&state.database_pool, id).await
            .ok_or(ApiError::UserNotFound(id))?;
        
        // 缓存用户数据
        let user_json = serde_json::to_string(&user)?;
        state.cache.set(&format!("user:{}", id), &user_json).await?;
        
        Ok(user)
    }).await?;
    
    Ok(Json(user))
}

#[handler]
async fn create_user(
    Json(payload): Json<CreateUserRequest>,
    Data(state): Data<&AppState>,
) -> Result<Json<User>, ApiError> {
    let user = User {
        id: generate_user_id(),
        name: payload.name,
        email: payload.email,
        created_at: chrono::Utc::now(),
    };
    
    // 保存到数据库
    save_user_to_db(&state.database_pool, &user).await?;
    
    // 缓存新用户
    let user_json = serde_json::to_string(&user)?;
    state.cache.set(&format!("user:{}", user.id), &user_json).await?;
    
    Ok(Json(user))
}

#[handler]
async fn proxy_to_service(
    Path(service_name): Path<String>,
    Path(path): Path<String>,
    Data(state): Data<&AppState>,
) -> Result<Json<serde_json::Value>, ApiError> {
    // 使用负载均衡器选择服务
    let service = state.load_balancer.select_service().await
        .ok_or(ApiError::NoAvailableServices)?;
    
    // 使用熔断器保护外部服务调用
    let result = state.circuit_breaker.call(|| async {
        let client = reqwest::Client::new();
        let url = format!("http://{}:{}/{}", service.address, service.port, path);
        
        let response = client.get(&url).send().await
            .map_err(|e| ApiError::InternalError(e.to_string()))?;
        
        let data: serde_json::Value = response.json().await
            .map_err(|e| ApiError::InternalError(e.to_string()))?;
        
        Ok(data)
    }).await?;
    
    Ok(Json(result))
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 初始化日志
    tracing_subscriber::fmt::init();
    
    // 初始化应用状态
    let service_registry = ServiceRegistry::new();
    let load_balancer = LoadBalancer::new(LoadBalanceStrategy::RoundRobin);
    let circuit_breaker = CircuitBreaker::new(5, Duration::from_secs(30));
    let database_pool = DatabasePool::new("postgresql://user:password@localhost/mydb").await?;
    let redis_pool = RedisPool::new("redis://localhost:6379").await?;
    let cache = MultiLevelCache::new(Arc::new(redis_pool.clone()), Duration::from_secs(300));
    
    let app_state = AppState {
        service_registry,
        load_balancer,
        circuit_breaker,
        database_pool,
        redis_pool,
        cache,
    };
    
    // 创建路由
    let app = Route::new()
        .at("/health", get(health_check))
        .at("/users/:id", get(get_user))
        .at("/users", post(create_user))
        .at("/proxy/:service_name/*path", get(proxy_to_service))
        .with(Tracing)
        .data(app_state);
    
    // 启动服务器
    Server::new(TcpListener::bind("0.0.0.0:3000"))
        .run(app)
        .await?;
    
    Ok(())
}
```

### 2. 中间件开发

```rust
use poem::{middleware::Middleware, Endpoint, EndpointExt, Request, Response};

// 请求日志中间件
pub struct RequestLoggingMiddleware;

impl<E: Endpoint> Middleware<E> for RequestLoggingMiddleware {
    type Output = RequestLoggingMiddlewareImpl<E>;

    fn transform(&self, ep: E) -> Self::Output {
        RequestLoggingMiddlewareImpl { ep }
    }
}

struct RequestLoggingMiddlewareImpl<E> {
    ep: E,
}

#[poem::async_trait]
impl<E: Endpoint> Endpoint for RequestLoggingMiddlewareImpl<E> {
    type Output = E::Output;

    async fn call(&self, req: Request) -> Self::Output {
        let start_time = std::time::Instant::now();
        let method = req.method().clone();
        let path = req.uri().path().to_string();
        
        tracing::info!("请求开始: {} {}", method, path);
        
        let response = self.ep.call(req).await;
        
        let duration = start_time.elapsed();
        tracing::info!("请求完成: {} {} - {}ms", method, path, duration.as_millis());
        
        response
    }
}

// 限流中间件
pub struct RateLimitMiddleware {
    max_requests: u32,
    window: Duration,
    requests: Arc<RwLock<VecDeque<Instant>>>,
}

impl RateLimitMiddleware {
    pub fn new(max_requests: u32, window: Duration) -> Self {
        Self {
            max_requests,
            window,
            requests: Arc::new(RwLock::new(VecDeque::new())),
        }
    }
}

impl<E: Endpoint> Middleware<E> for RateLimitMiddleware {
    type Output = RateLimitMiddlewareImpl<E>;

    fn transform(&self, ep: E) -> Self::Output {
        RateLimitMiddlewareImpl {
            ep,
            max_requests: self.max_requests,
            window: self.window,
            requests: self.requests.clone(),
        }
    }
}

struct RateLimitMiddlewareImpl<E> {
    ep: E,
    max_requests: u32,
    window: Duration,
    requests: Arc<RwLock<VecDeque<Instant>>>,
}

#[poem::async_trait]
impl<E: Endpoint> Endpoint for RateLimitMiddlewareImpl<E> {
    type Output = E::Output;

    async fn call(&self, req: Request) -> Self::Output {
        let now = Instant::now();
        
        // 清理过期的请求记录
        {
            let mut requests = self.requests.write().await;
            while let Some(&oldest) = requests.front() {
                if now.duration_since(oldest) > self.window {
                    requests.pop_front();
                } else {
                    break;
                }
            }
            
            if requests.len() >= self.max_requests as usize {
                return Response::builder()
                    .status(StatusCode::TOO_MANY_REQUESTS)
                    .body("Rate limit exceeded");
            }
            
            requests.push_back(now);
        }
        
        self.ep.call(req).await
    }
}

// 使用中间件
let app = Route::new()
    .at("/api/*", api_routes)
    .with(RequestLoggingMiddleware)
    .with(RateLimitMiddleware::new(100, Duration::from_secs(1)))
    .with(Tracing);
```

## 最佳实践

### 1. 错误处理策略

```rust
use poem::{error::Result, Error, Response, StatusCode};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum AppError {
    #[error("数据库错误: {0}")]
    DatabaseError(#[from] sqlx::Error),
    #[error("Redis错误: {0}")]
    RedisError(#[from] redis::RedisError),
    #[error("JSON错误: {0}")]
    JsonError(#[from] serde_json::Error),
    #[error("HTTP错误: {0}")]
    HttpError(#[from] reqwest::Error),
    #[error("用户不存在: {0}")]
    UserNotFound(u64),
    #[error("认证失败")]
    AuthenticationFailed,
    #[error("权限不足")]
    InsufficientPermissions,
}

impl From<AppError> for Error {
    fn from(err: AppError) -> Self {
        let status = match err {
            AppError::DatabaseError(_) => StatusCode::INTERNAL_SERVER_ERROR,
            AppError::RedisError(_) => StatusCode::INTERNAL_SERVER_ERROR,
            AppError::JsonError(_) => StatusCode::BAD_REQUEST,
            AppError::HttpError(_) => StatusCode::BAD_GATEWAY,
            AppError::UserNotFound(_) => StatusCode::NOT_FOUND,
            AppError::AuthenticationFailed => StatusCode::UNAUTHORIZED,
            AppError::InsufficientPermissions => StatusCode::FORBIDDEN,
        };
        
        Error::from_string(err.to_string(), status)
    }
}
```

### 2. 配置管理

```rust
use poem::{handler, web::Json, EndpointExt, Route};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AppConfig {
    pub server: ServerConfig,
    pub database: DatabaseConfig,
    pub redis: RedisConfig,
    pub logging: LoggingConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerConfig {
    pub host: String,
    pub port: u16,
    pub workers: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DatabaseConfig {
    pub url: String,
    pub max_connections: u32,
    pub min_connections: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RedisConfig {
    pub url: String,
    pub max_connections: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LoggingConfig {
    pub level: String,
    pub format: String,
}

impl AppConfig {
    pub fn from_env() -> Result<Self, config::ConfigError> {
        let mut settings = config::Config::default();
        
        // 从环境变量加载配置
        settings.merge(config::Environment::with_prefix("APP"))?;
        
        // 从配置文件加载
        if let Ok(config_file) = std::env::var("CONFIG_FILE") {
            settings.merge(config::File::with_name(&config_file))?;
        }
        
        settings.try_into()
    }
}

// 配置端点
#[handler]
async fn get_config(Data(config): Data<&AppConfig>) -> Json<AppConfig> {
    Json(config.clone())
}

#[handler]
async fn update_config(
    Json(new_config): Json<AppConfig>,
    Data(config): Data<&Arc<RwLock<AppConfig>>>,
) -> Result<Json<AppConfig>, ApiError> {
    let mut config = config.write().await;
    *config = new_config.clone();
    Ok(Json(new_config))
}
```

### 3. 监控和指标

```rust
use poem::{handler, web::Json, EndpointExt, Route};
use std::sync::Arc;
use tokio::sync::RwLock;
use std::time::Instant;

// 应用指标
#[derive(Debug, Clone, Default)]
pub struct AppMetrics {
    pub requests_total: u64,
    pub requests_success: u64,
    pub requests_error: u64,
    pub response_time_sum: u64,
    pub response_time_count: u64,
    pub active_connections: u32,
}

impl AppMetrics {
    pub fn record_request(&mut self, success: bool, response_time: Duration) {
        self.requests_total += 1;
        if success {
            self.requests_success += 1;
        } else {
            self.requests_error += 1;
        }
        
        self.response_time_sum += response_time.as_millis() as u64;
        self.response_time_count += 1;
    }
    
    pub fn average_response_time(&self) -> f64 {
        if self.response_time_count > 0 {
            self.response_time_sum as f64 / self.response_time_count as f64
        } else {
            0.0
        }
    }
    
    pub fn error_rate(&self) -> f64 {
        if self.requests_total > 0 {
            self.requests_error as f64 / self.requests_total as f64
        } else {
            0.0
        }
    }
}

// 指标中间件
pub struct MetricsMiddleware {
    metrics: Arc<RwLock<AppMetrics>>,
}

impl MetricsMiddleware {
    pub fn new() -> Self {
        Self {
            metrics: Arc::new(RwLock::new(AppMetrics::default())),
        }
    }
    
    pub fn get_metrics(&self) -> Arc<RwLock<AppMetrics>> {
        self.metrics.clone()
    }
}

impl<E: Endpoint> Middleware<E> for MetricsMiddleware {
    type Output = MetricsMiddlewareImpl<E>;

    fn transform(&self, ep: E) -> Self::Output {
        MetricsMiddlewareImpl {
            ep,
            metrics: self.metrics.clone(),
        }
    }
}

struct MetricsMiddlewareImpl<E> {
    ep: E,
    metrics: Arc<RwLock<AppMetrics>>,
}

#[poem::async_trait]
impl<E: Endpoint> Endpoint for MetricsMiddlewareImpl<E> {
    type Output = E::Output;

    async fn call(&self, req: Request) -> Self::Output {
        let start_time = Instant::now();
        
        let response = self.ep.call(req).await;
        
        let response_time = start_time.elapsed();
        let success = response.status().is_success();
        
        {
            let mut metrics = self.metrics.write().await;
            metrics.record_request(success, response_time);
        }
        
        response
    }
}

// 指标端点
#[handler]
async fn get_metrics(Data(metrics): Data<&Arc<RwLock<AppMetrics>>>) -> Json<serde_json::Value> {
    let metrics = metrics.read().await;
    
    let metrics_json = serde_json::json!({
        "requests_total": metrics.requests_total,
        "requests_success": metrics.requests_success,
        "requests_error": metrics.requests_error,
        "average_response_time_ms": metrics.average_response_time(),
        "error_rate": metrics.error_rate(),
        "active_connections": metrics.active_connections,
    });
    
    Json(metrics_json)
}
```

## 总结

Poem 2.0是一个功能强大、性能优异的现代化Web框架，特别适合构建微服务架构：

### 主要优势1

1. **高性能**: 基于Tokio异步运行时，提供卓越的并发性能
2. **类型安全**: 利用Rust的类型系统，确保编译时安全
3. **简洁API**: 直观的API设计，降低学习成本
4. **丰富生态**: 支持OpenAPI、GraphQL、中间件等
5. **微服务友好**: 内置服务发现、负载均衡、熔断器等支持

### 应用场景

1. **API网关**: 构建高性能的API网关
2. **微服务**: 开发独立的微服务
3. **Web应用**: 构建现代化的Web应用
4. **GraphQL服务**: 提供GraphQL API
5. **实时应用**: 支持WebSocket和SSE

### 最佳实践1

1. **合理使用中间件**: 避免过度使用中间件影响性能
2. **错误处理**: 实现统一的错误处理机制
3. **配置管理**: 使用环境变量和配置文件管理配置
4. **监控指标**: 集成监控和指标收集
5. **缓存策略**: 实现多级缓存提升性能

通过合理使用Poem 2.0的各种特性，可以构建高性能、可扩展的现代化微服务架构，充分发挥Rust在系统编程方面的优势。
