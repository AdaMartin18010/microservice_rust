# Poem 2.0 ç°ä»£åŒ–Webæ¡†æ¶

> æ·±å…¥æ¢ç´¢Poem 2.0æ¡†æ¶åœ¨å¾®æœåŠ¡å¼€å‘ä¸­çš„é«˜çº§åº”ç”¨å’Œæœ€ä½³å®è·µ

## ğŸ“‹ ç›®å½•

- [Poem 2.0 ç°ä»£åŒ–Webæ¡†æ¶](#poem-20-ç°ä»£åŒ–webæ¡†æ¶)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
    - [ä¸»è¦ä¼˜åŠ¿](#ä¸»è¦ä¼˜åŠ¿)
  - [Poem 2.0 æ ¸å¿ƒç‰¹æ€§](#poem-20-æ ¸å¿ƒç‰¹æ€§)
    - [1. è·¯ç”±ç³»ç»Ÿ](#1-è·¯ç”±ç³»ç»Ÿ)
    - [2. ä¸­é—´ä»¶ç³»ç»Ÿ](#2-ä¸­é—´ä»¶ç³»ç»Ÿ)
    - [3. é”™è¯¯å¤„ç†](#3-é”™è¯¯å¤„ç†)
  - [å¾®æœåŠ¡æ¶æ„é›†æˆ](#å¾®æœåŠ¡æ¶æ„é›†æˆ)
    - [1. æœåŠ¡å‘ç°é›†æˆ](#1-æœåŠ¡å‘ç°é›†æˆ)
    - [2. è´Ÿè½½å‡è¡¡é›†æˆ](#2-è´Ÿè½½å‡è¡¡é›†æˆ)
    - [3. ç†”æ–­å™¨é›†æˆ](#3-ç†”æ–­å™¨é›†æˆ)
  - [é«˜çº§åŠŸèƒ½åº”ç”¨](#é«˜çº§åŠŸèƒ½åº”ç”¨)
    - [1. OpenAPIé›†æˆ](#1-openapié›†æˆ)
    - [2. GraphQLé›†æˆ](#2-graphqlé›†æˆ)
  - [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
    - [1. è¿æ¥æ± ç®¡ç†](#1-è¿æ¥æ± ç®¡ç†)
    - [2. ç¼“å­˜ç­–ç•¥](#2-ç¼“å­˜ç­–ç•¥)
  - [å®é™…ä»£ç ç¤ºä¾‹](#å®é™…ä»£ç ç¤ºä¾‹)
    - [1. å®Œæ•´çš„å¾®æœåŠ¡åº”ç”¨](#1-å®Œæ•´çš„å¾®æœåŠ¡åº”ç”¨)
    - [2. ä¸­é—´ä»¶å¼€å‘](#2-ä¸­é—´ä»¶å¼€å‘)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [1. é”™è¯¯å¤„ç†ç­–ç•¥](#1-é”™è¯¯å¤„ç†ç­–ç•¥)
    - [2. é…ç½®ç®¡ç†](#2-é…ç½®ç®¡ç†)
    - [3. ç›‘æ§å’ŒæŒ‡æ ‡](#3-ç›‘æ§å’ŒæŒ‡æ ‡)
  - [æ€»ç»“](#æ€»ç»“)
    - [ä¸»è¦ä¼˜åŠ¿1](#ä¸»è¦ä¼˜åŠ¿1)
    - [åº”ç”¨åœºæ™¯](#åº”ç”¨åœºæ™¯)
    - [æœ€ä½³å®è·µ1](#æœ€ä½³å®è·µ1)

## æ¦‚è¿°

Poem 2.0æ˜¯ä¸€ä¸ªç°ä»£åŒ–çš„Rust Webæ¡†æ¶ï¼Œä¸“ä¸ºé«˜æ€§èƒ½å¾®æœåŠ¡å¼€å‘è€Œè®¾è®¡ã€‚
å®ƒæä¾›äº†ç®€æ´çš„APIã€å¼ºå¤§çš„ç±»å‹å®‰å…¨æ€§å’Œå‡ºè‰²çš„æ€§èƒ½è¡¨ç°ï¼Œç‰¹åˆ«é€‚åˆæ„å»ºç°ä»£åŒ–çš„å¾®æœåŠ¡æ¶æ„ã€‚

### ä¸»è¦ä¼˜åŠ¿

- **é«˜æ€§èƒ½**: åŸºäºTokioå¼‚æ­¥è¿è¡Œæ—¶ï¼Œæä¾›å“è¶Šçš„å¹¶å‘æ€§èƒ½
- **ç±»å‹å®‰å…¨**: åˆ©ç”¨Rustçš„ç±»å‹ç³»ç»Ÿï¼Œç¡®ä¿ç¼–è¯‘æ—¶å®‰å…¨
- **ç®€æ´API**: ç›´è§‚çš„APIè®¾è®¡ï¼Œé™ä½å­¦ä¹ æˆæœ¬
- **ä¸­é—´ä»¶æ”¯æŒ**: ä¸°å¯Œçš„ä¸­é—´ä»¶ç”Ÿæ€ç³»ç»Ÿ
- **OpenAPIé›†æˆ**: å†…ç½®OpenAPI 3.0æ”¯æŒ
- **GraphQLæ”¯æŒ**: åŸç”ŸGraphQLæ”¯æŒ

## Poem 2.0 æ ¸å¿ƒç‰¹æ€§

### 1. è·¯ç”±ç³»ç»Ÿ

```rust
use poem::{get, handler, listener::TcpListener, middleware::Tracing, web::Path, EndpointExt, Route, Server};

#[handler]
async fn hello() -> &'static str {
    "Hello, Poem 2.0!"
}

#[handler]
async fn get_user(Path(id): Path<u64>) -> String {
    format!("User ID: {}", id)
}

#[handler]
async fn create_user(Json(payload): Json<CreateUserRequest>) -> Result<Json<User>, poem::Error> {
    // åˆ›å»ºç”¨æˆ·é€»è¾‘
    let user = User {
        id: 1,
        name: payload.name,
        email: payload.email,
    };
    Ok(Json(user))
}

#[tokio::main]
async fn main() -> Result<(), std::io::Error> {
    let app = Route::new()
        .at("/", get(hello))
        .at("/users/:id", get(get_user))
        .at("/users", post(create_user))
        .with(Tracing);
    
    Server::new(TcpListener::bind("0.0.0.0:3000"))
        .run(app)
        .await
}
```

### 2. ä¸­é—´ä»¶ç³»ç»Ÿ

```rust
use poem::{
    middleware::{Cors, Tracing, Compression},
    EndpointExt, Route,
};

// è‡ªå®šä¹‰ä¸­é—´ä»¶
struct AuthMiddleware;

impl<E: Endpoint> Middleware<E> for AuthMiddleware {
    type Output = AuthMiddlewareImpl<E>;

    fn transform(&self, ep: E) -> Self::Output {
        AuthMiddlewareImpl { ep }
    }
}

struct AuthMiddlewareImpl<E> {
    ep: E,
}

#[poem::async_trait]
impl<E: Endpoint> Endpoint for AuthMiddlewareImpl<E> {
    type Output = E::Output;

    async fn call(&self, req: Request) -> Self::Output {
        // è®¤è¯é€»è¾‘
        if let Some(auth_header) = req.headers().get("Authorization") {
            if verify_token(auth_header).await {
                return self.ep.call(req).await;
            }
        }
        
        // è¿”å›401æœªæˆæƒ
        Response::builder()
            .status(StatusCode::UNAUTHORIZED)
            .body("Unauthorized")
    }
}

// ä½¿ç”¨ä¸­é—´ä»¶
let app = Route::new()
    .at("/api/*", api_routes)
    .with(AuthMiddleware)
    .with(Cors::new())
    .with(Tracing)
    .with(Compression::new());
```

### 3. é”™è¯¯å¤„ç†

```rust
use poem::{error::Result, Error, Response, StatusCode};

#[derive(Debug, thiserror::Error)]
pub enum ApiError {
    #[error("ç”¨æˆ·ä¸å­˜åœ¨: {0}")]
    UserNotFound(u64),
    #[error("è®¤è¯å¤±è´¥")]
    AuthenticationFailed,
    #[error("æƒé™ä¸è¶³")]
    InsufficientPermissions,
    #[error("å†…éƒ¨æœåŠ¡å™¨é”™è¯¯: {0}")]
    InternalError(String),
}

impl From<ApiError> for Error {
    fn from(err: ApiError) -> Self {
        let status = match err {
            ApiError::UserNotFound(_) => StatusCode::NOT_FOUND,
            ApiError::AuthenticationFailed => StatusCode::UNAUTHORIZED,
            ApiError::InsufficientPermissions => StatusCode::FORBIDDEN,
            ApiError::InternalError(_) => StatusCode::INTERNAL_SERVER_ERROR,
        };
        
        Error::from_string(err.to_string(), status)
    }
}

#[handler]
async fn get_user(Path(id): Path<u64>) -> Result<Json<User>> {
    let user = find_user(id).await
        .ok_or(ApiError::UserNotFound(id))?;
    
    Ok(Json(user))
}
```

## å¾®æœåŠ¡æ¶æ„é›†æˆ

### 1. æœåŠ¡å‘ç°é›†æˆ

```rust
use poem::{handler, web::Json, EndpointExt, Route};
use std::sync::Arc;
use tokio::sync::RwLock;

// æœåŠ¡æ³¨å†Œè¡¨
#[derive(Clone)]
pub struct ServiceRegistry {
    services: Arc<RwLock<HashMap<String, ServiceInfo>>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceInfo {
    pub name: String,
    pub address: String,
    pub port: u16,
    pub health_check_url: String,
    pub metadata: HashMap<String, String>,
}

impl ServiceRegistry {
    pub fn new() -> Self {
        Self {
            services: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    pub async fn register_service(&self, service: ServiceInfo) {
        let mut services = self.services.write().await;
        services.insert(service.name.clone(), service);
    }
    
    pub async fn discover_service(&self, name: &str) -> Option<ServiceInfo> {
        let services = self.services.read().await;
        services.get(name).cloned()
    }
    
    pub async fn list_services(&self) -> Vec<ServiceInfo> {
        let services = self.services.read().await;
        services.values().cloned().collect()
    }
}

// æœåŠ¡æ³¨å†Œç«¯ç‚¹
#[handler]
async fn register_service(
    Json(service): Json<ServiceInfo>,
    Data(registry): Data<&ServiceRegistry>,
) -> Result<Json<RegisterResponse>> {
    registry.register_service(service.clone()).await;
    
    Ok(Json(RegisterResponse {
        success: true,
        message: format!("æœåŠ¡ {} æ³¨å†ŒæˆåŠŸ", service.name),
    }))
}

// æœåŠ¡å‘ç°ç«¯ç‚¹
#[handler]
async fn discover_service(
    Path(name): Path<String>,
    Data(registry): Data<&ServiceRegistry>,
) -> Result<Json<ServiceInfo>> {
    let service = registry.discover_service(&name).await
        .ok_or(ApiError::ServiceNotFound(name))?;
    
    Ok(Json(service))
}

// å¥åº·æ£€æŸ¥ç«¯ç‚¹
#[handler]
async fn health_check() -> Json<HealthStatus> {
    Json(HealthStatus {
        status: "healthy".to_string(),
        timestamp: chrono::Utc::now(),
        version: env!("CARGO_PKG_VERSION").to_string(),
    })
}
```

### 2. è´Ÿè½½å‡è¡¡é›†æˆ

```rust
use poem::{handler, web::Json, EndpointExt, Route};
use std::sync::Arc;
use tokio::sync::RwLock;

// è´Ÿè½½å‡è¡¡å™¨
#[derive(Clone)]
pub struct LoadBalancer {
    services: Arc<RwLock<Vec<ServiceInfo>>>,
    current_index: Arc<RwLock<usize>>,
    strategy: LoadBalanceStrategy,
}

#[derive(Debug, Clone)]
pub enum LoadBalanceStrategy {
    RoundRobin,
    Random,
    WeightedRoundRobin,
    LeastConnections,
}

impl LoadBalancer {
    pub fn new(strategy: LoadBalanceStrategy) -> Self {
        Self {
            services: Arc::new(RwLock::new(Vec::new())),
            current_index: Arc::new(RwLock::new(0)),
            strategy,
        }
    }
    
    pub async fn add_service(&self, service: ServiceInfo) {
        let mut services = self.services.write().await;
        services.push(service);
    }
    
    pub async fn select_service(&self) -> Option<ServiceInfo> {
        let services = self.services.read().await;
        if services.is_empty() {
            return None;
        }
        
        match self.strategy {
            LoadBalanceStrategy::RoundRobin => {
                let mut index = self.current_index.write().await;
                let selected = services[*index].clone();
                *index = (*index + 1) % services.len();
                Some(selected)
            }
            LoadBalanceStrategy::Random => {
                let index = rand::random::<usize>() % services.len();
                Some(services[index].clone())
            }
            LoadBalanceStrategy::WeightedRoundRobin => {
                // å®ç°åŠ æƒè½®è¯¢é€»è¾‘
                self.weighted_round_robin(&services).await
            }
            LoadBalanceStrategy::LeastConnections => {
                // å®ç°æœ€å°‘è¿æ¥é€»è¾‘
                self.least_connections(&services).await
            }
        }
    }
    
    async fn weighted_round_robin(&self, services: &[ServiceInfo]) -> Option<ServiceInfo> {
        // åŠ æƒè½®è¯¢å®ç°
        let total_weight: u32 = services.iter()
            .map(|s| s.metadata.get("weight").unwrap_or(&"1".to_string()).parse::<u32>().unwrap_or(1))
            .sum();
        
        let mut index = self.current_index.write().await;
        let mut current_weight = 0;
        
        for (i, service) in services.iter().enumerate() {
            let weight = service.metadata.get("weight").unwrap_or(&"1".to_string()).parse::<u32>().unwrap_or(1);
            current_weight += weight;
            
            if current_weight >= total_weight {
                *index = (i + 1) % services.len();
                return Some(service.clone());
            }
        }
        
        None
    }
    
    async fn least_connections(&self, services: &[ServiceInfo]) -> Option<ServiceInfo> {
        // æœ€å°‘è¿æ¥å®ç°
        services.iter()
            .min_by_key(|s| s.metadata.get("connections").unwrap_or(&"0".to_string()).parse::<u32>().unwrap_or(0))
            .cloned()
    }
}

// ä»£ç†è¯·æ±‚ç«¯ç‚¹
#[handler]
async fn proxy_request(
    Path(path): Path<String>,
    Data(load_balancer): Data<&LoadBalancer>,
) -> Result<Json<serde_json::Value>> {
    let service = load_balancer.select_service().await
        .ok_or(ApiError::NoAvailableServices)?;
    
    // è½¬å‘è¯·æ±‚åˆ°é€‰ä¸­çš„æœåŠ¡
    let client = reqwest::Client::new();
    let url = format!("http://{}:{}/{}", service.address, service.port, path);
    
    let response = client.get(&url).send().await
        .map_err(|e| ApiError::InternalError(e.to_string()))?;
    
    let data: serde_json::Value = response.json().await
        .map_err(|e| ApiError::InternalError(e.to_string()))?;
    
    Ok(Json(data))
}
```

### 3. ç†”æ–­å™¨é›†æˆ

```rust
use poem::{handler, web::Json, EndpointExt, Route};
use std::sync::Arc;
use tokio::sync::RwLock;
use std::time::{Duration, Instant};

// ç†”æ–­å™¨
#[derive(Clone)]
pub struct CircuitBreaker {
    state: Arc<RwLock<CircuitState>>,
    failure_count: Arc<RwLock<u32>>,
    failure_threshold: u32,
    timeout: Duration,
    last_failure_time: Arc<RwLock<Option<Instant>>>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum CircuitState {
    Closed,
    Open,
    HalfOpen,
}

impl CircuitBreaker {
    pub fn new(failure_threshold: u32, timeout: Duration) -> Self {
        Self {
            state: Arc::new(RwLock::new(CircuitState::Closed)),
            failure_count: Arc::new(RwLock::new(0)),
            failure_threshold,
            timeout,
            last_failure_time: Arc::new(RwLock::new(None)),
        }
    }
    
    pub async fn call<F, T>(&self, f: F) -> Result<T, ApiError>
    where
        F: FnOnce() -> Result<T, ApiError>,
    {
        let state = *self.state.read().await;
        
        match state {
            CircuitState::Open => {
                if self.should_attempt_reset().await {
                    let mut state_guard = self.state.write().await;
                    *state_guard = CircuitState::HalfOpen;
                } else {
                    return Err(ApiError::CircuitBreakerOpen);
                }
            }
            CircuitState::HalfOpen => {
                // å…è®¸ä¸€æ¬¡å°è¯•
            }
            CircuitState::Closed => {
                // æ­£å¸¸çŠ¶æ€
            }
        }
        
        match f() {
            Ok(result) => {
                self.on_success().await;
                Ok(result)
            }
            Err(e) => {
                self.on_failure().await;
                Err(e)
            }
        }
    }
    
    async fn should_attempt_reset(&self) -> bool {
        let last_failure = *self.last_failure_time.read().await;
        if let Some(last_failure) = last_failure {
            last_failure.elapsed() >= self.timeout
        } else {
            true
        }
    }
    
    async fn on_success(&self) {
        let mut state = self.state.write().await;
        *state = CircuitState::Closed;
        
        let mut failure_count = self.failure_count.write().await;
        *failure_count = 0;
        
        let mut last_failure_time = self.last_failure_time.write().await;
        *last_failure_time = None;
    }
    
    async fn on_failure(&self) {
        let mut failure_count = self.failure_count.write().await;
        *failure_count += 1;
        
        let mut last_failure_time = self.last_failure_time.write().await;
        *last_failure_time = Some(Instant::now());
        
        if *failure_count >= self.failure_threshold {
            let mut state = self.state.write().await;
            *state = CircuitState::Open;
        }
    }
    
    pub async fn get_state(&self) -> CircuitState {
        *self.state.read().await
    }
}

// ä½¿ç”¨ç†”æ–­å™¨çš„æœåŠ¡è°ƒç”¨
#[handler]
async fn call_external_service(
    Data(circuit_breaker): Data<&CircuitBreaker>,
) -> Result<Json<serde_json::Value>> {
    let result = circuit_breaker.call(|| async {
        // æ¨¡æ‹Ÿå¤–éƒ¨æœåŠ¡è°ƒç”¨
        let client = reqwest::Client::new();
        let response = client.get("https://api.example.com/data")
            .send()
            .await
            .map_err(|e| ApiError::InternalError(e.to_string()))?;
        
        let data: serde_json::Value = response.json().await
            .map_err(|e| ApiError::InternalError(e.to_string()))?;
        
        Ok(data)
    }).await?;
    
    Ok(Json(result))
}
```

## é«˜çº§åŠŸèƒ½åº”ç”¨

### 1. OpenAPIé›†æˆ

```rust
use poem::{handler, web::Json, EndpointExt, Route};
use poem_openapi::{OpenApi, OpenApiService, payload::Json as OpenApiJson, ApiResponse, Object};

// å®šä¹‰APIå“åº”ç±»å‹
#[derive(Object, Serialize, Deserialize)]
pub struct User {
    pub id: u64,
    pub name: String,
    pub email: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Object, Serialize, Deserialize)]
pub struct CreateUserRequest {
    pub name: String,
    pub email: String,
}

#[derive(ApiResponse)]
pub enum UserResponse {
    #[oai(status = 200)]
    Ok(OpenApiJson<User>),
    #[oai(status = 404)]
    NotFound(OpenApiJson<ErrorResponse>),
    #[oai(status = 400)]
    BadRequest(OpenApiJson<ErrorResponse>),
}

#[derive(Object, Serialize, Deserialize)]
pub struct ErrorResponse {
    pub error: String,
    pub message: String,
}

// å®šä¹‰APIæœåŠ¡
pub struct UserApi;

#[OpenApi]
impl UserApi {
    /// è·å–ç”¨æˆ·ä¿¡æ¯
    #[oai(path = "/users/:id", method = "get")]
    async fn get_user(&self, id: u64) -> UserResponse {
        match find_user(id).await {
            Some(user) => UserResponse::Ok(OpenApiJson(user)),
            None => UserResponse::NotFound(OpenApiJson(ErrorResponse {
                error: "USER_NOT_FOUND".to_string(),
                message: format!("ç”¨æˆ· {} ä¸å­˜åœ¨", id),
            })),
        }
    }
    
    /// åˆ›å»ºç”¨æˆ·
    #[oai(path = "/users", method = "post")]
    async fn create_user(&self, req: OpenApiJson<CreateUserRequest>) -> UserResponse {
        let user = User {
            id: generate_user_id(),
            name: req.0.name,
            email: req.0.email,
            created_at: chrono::Utc::now(),
        };
        
        if save_user(&user).await {
            UserResponse::Ok(OpenApiJson(user))
        } else {
            UserResponse::BadRequest(OpenApiJson(ErrorResponse {
                error: "USER_CREATION_FAILED".to_string(),
                message: "åˆ›å»ºç”¨æˆ·å¤±è´¥".to_string(),
            }))
        }
    }
}

// åˆ›å»ºOpenAPIæœåŠ¡
let api_service = OpenApiService::new(UserApi, "ç”¨æˆ·æœåŠ¡", "1.0")
    .server("http://localhost:3000/api");

// åˆ›å»ºè·¯ç”±
let app = Route::new()
    .nest("/api", api_service)
    .nest("/docs", api_service.swagger_ui())
    .nest("/redoc", api_service.redoc());
```

### 2. GraphQLé›†æˆ

```rust
use poem::{handler, web::Json, EndpointExt, Route};
use poem_graphql::{GraphQL, GraphQLSubscription, GraphQLRequest, GraphQLResponse};
use async_graphql::{Object, Schema, Subscription, EmptySubscription, Context, Result as GraphQLResult};

// å®šä¹‰GraphQLç±»å‹
#[derive(Object)]
pub struct User {
    pub id: u64,
    pub name: String,
    pub email: String,
}

#[derive(Object)]
pub struct QueryRoot;

#[Object]
impl QueryRoot {
    async fn user(&self, ctx: &Context<'_>, id: u64) -> GraphQLResult<Option<User>> {
        // ä»æ•°æ®åº“è·å–ç”¨æˆ·
        let user = find_user(id).await;
        Ok(user.map(|u| User {
            id: u.id,
            name: u.name,
            email: u.email,
        }))
    }
    
    async fn users(&self, ctx: &Context<'_>) -> GraphQLResult<Vec<User>> {
        // è·å–æ‰€æœ‰ç”¨æˆ·
        let users = find_all_users().await;
        Ok(users.into_iter().map(|u| User {
            id: u.id,
            name: u.name,
            email: u.email,
        }).collect())
    }
}

// å®šä¹‰è®¢é˜…
#[derive(Subscription)]
pub struct SubscriptionRoot;

#[Subscription]
impl SubscriptionRoot {
    async fn user_created(&self) -> impl Stream<Item = User> {
        // å®ç°ç”¨æˆ·åˆ›å»ºäº‹ä»¶æµ
        tokio_stream::wrappers::BroadcastStream::new(user_created_receiver)
            .filter_map(|result| async move {
                result.ok().map(|event| User {
                    id: event.id,
                    name: event.name,
                    email: event.email,
                })
            })
    }
}

// åˆ›å»ºGraphQL Schema
type MySchema = Schema<QueryRoot, EmptyMutation, SubscriptionRoot>;

// GraphQLå¤„ç†å™¨
#[handler]
async fn graphql_handler(
    req: GraphQLRequest,
    Data(schema): Data<&MySchema>,
) -> GraphQLResponse {
    schema.execute(req.0).await.into()
}

// GraphQLè®¢é˜…å¤„ç†å™¨
#[handler]
async fn graphql_subscription_handler(
    req: GraphQLRequest,
    Data(schema): Data<&MySchema>,
) -> GraphQLSubscription {
    schema.subscription(req.0).into()
}

// åˆ›å»ºè·¯ç”±
let schema = Schema::new(QueryRoot, EmptyMutation, SubscriptionRoot);
let app = Route::new()
    .at("/graphql", post(graphql_handler).get(graphql_subscription_handler))
    .data(schema);
```

## æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. è¿æ¥æ± ç®¡ç†

```rust
use poem::{handler, web::Json, EndpointExt, Route};
use std::sync::Arc;
use tokio::sync::RwLock;

// æ•°æ®åº“è¿æ¥æ± 
#[derive(Clone)]
pub struct DatabasePool {
    pool: Arc<sqlx::PgPool>,
}

impl DatabasePool {
    pub async fn new(database_url: &str) -> Result<Self, sqlx::Error> {
        let pool = sqlx::PgPool::connect(database_url).await?;
        Ok(Self {
            pool: Arc::new(pool),
        })
    }
    
    pub async fn get_connection(&self) -> Result<sqlx::PgConnection, sqlx::Error> {
        self.pool.acquire().await
    }
    
    pub async fn execute_query<T>(&self, query: &str) -> Result<Vec<T>, sqlx::Error>
    where
        T: for<'r> sqlx::FromRow<'r, sqlx::postgres::PgRow> + Send + Unpin,
    {
        let rows = sqlx::query_as::<_, T>(query)
            .fetch_all(&*self.pool)
            .await?;
        Ok(rows)
    }
}

// Redisè¿æ¥æ± 
#[derive(Clone)]
pub struct RedisPool {
    client: Arc<redis::Client>,
    connection_manager: Arc<redis::aio::ConnectionManager>,
}

impl RedisPool {
    pub async fn new(redis_url: &str) -> Result<Self, redis::RedisError> {
        let client = redis::Client::open(redis_url)?;
        let connection_manager = client.get_connection_manager().await?;
        
        Ok(Self {
            client: Arc::new(client),
            connection_manager: Arc::new(connection_manager),
        })
    }
    
    pub async fn get(&self, key: &str) -> Result<Option<String>, redis::RedisError> {
        let mut conn = self.connection_manager.clone();
        redis::cmd("GET").arg(key).query_async(&mut conn).await
    }
    
    pub async fn set(&self, key: &str, value: &str, ttl: Option<u64>) -> Result<(), redis::RedisError> {
        let mut conn = self.connection_manager.clone();
        let mut cmd = redis::cmd("SET").arg(key).arg(value);
        
        if let Some(ttl) = ttl {
            cmd = cmd.arg("EX").arg(ttl);
        }
        
        cmd.query_async(&mut conn).await
    }
}
```

### 2. ç¼“å­˜ç­–ç•¥

```rust
use poem::{handler, web::Json, EndpointExt, Route};
use std::sync::Arc;
use tokio::sync::RwLock;
use std::time::{Duration, Instant};

// å¤šçº§ç¼“å­˜
#[derive(Clone)]
pub struct MultiLevelCache {
    l1_cache: Arc<RwLock<HashMap<String, CacheEntry>>>>,
    l2_cache: Arc<RedisPool>,
    ttl: Duration,
}

#[derive(Debug, Clone)]
struct CacheEntry {
    value: String,
    expires_at: Instant,
}

impl MultiLevelCache {
    pub fn new(redis_pool: Arc<RedisPool>, ttl: Duration) -> Self {
        Self {
            l1_cache: Arc::new(RwLock::new(HashMap::new())),
            l2_cache: redis_pool,
            ttl,
        }
    }
    
    pub async fn get(&self, key: &str) -> Option<String> {
        // é¦–å…ˆæ£€æŸ¥L1ç¼“å­˜
        {
            let l1_cache = self.l1_cache.read().await;
            if let Some(entry) = l1_cache.get(key) {
                if entry.expires_at > Instant::now() {
                    return Some(entry.value.clone());
                }
            }
        }
        
        // æ£€æŸ¥L2ç¼“å­˜
        if let Ok(Some(value)) = self.l2_cache.get(key).await {
            // æ›´æ–°L1ç¼“å­˜
            let mut l1_cache = self.l1_cache.write().await;
            l1_cache.insert(key.to_string(), CacheEntry {
                value: value.clone(),
                expires_at: Instant::now() + self.ttl,
            });
            
            return Some(value);
        }
        
        None
    }
    
    pub async fn set(&self, key: &str, value: &str) -> Result<(), Box<dyn std::error::Error>> {
        // è®¾ç½®L1ç¼“å­˜
        {
            let mut l1_cache = self.l1_cache.write().await;
            l1_cache.insert(key.to_string(), CacheEntry {
                value: value.to_string(),
                expires_at: Instant::now() + self.ttl,
            });
        }
        
        // è®¾ç½®L2ç¼“å­˜
        self.l2_cache.set(key, value, Some(self.ttl.as_secs())).await?;
        
        Ok(())
    }
    
    pub async fn invalidate(&self, key: &str) -> Result<(), Box<dyn std::error::Error>> {
        // æ¸…é™¤L1ç¼“å­˜
        {
            let mut l1_cache = self.l1_cache.write().await;
            l1_cache.remove(key);
        }
        
        // æ¸…é™¤L2ç¼“å­˜
        let mut conn = self.l2_cache.connection_manager.clone();
        redis::cmd("DEL").arg(key).query_async(&mut conn).await?;
        
        Ok(())
    }
}

// ä½¿ç”¨ç¼“å­˜çš„å¤„ç†å™¨
#[handler]
async fn get_cached_data(
    Path(key): Path<String>,
    Data(cache): Data<&MultiLevelCache>,
) -> Result<Json<serde_json::Value>> {
    if let Some(value) = cache.get(&key).await {
        let data: serde_json::Value = serde_json::from_str(&value)?;
        Ok(Json(data))
    } else {
        // ä»æ•°æ®åº“è·å–æ•°æ®
        let data = fetch_from_database(&key).await?;
        
        // ç¼“å­˜æ•°æ®
        let value = serde_json::to_string(&data)?;
        cache.set(&key, &value).await?;
        
        Ok(Json(data))
    }
}
```

## å®é™…ä»£ç ç¤ºä¾‹

### 1. å®Œæ•´çš„å¾®æœåŠ¡åº”ç”¨

```rust
use poem::{
    handler, listener::TcpListener, middleware::Tracing, web::{Json, Path, Data},
    EndpointExt, Route, Server,
};
use std::sync::Arc;
use tokio::sync::RwLock;

// åº”ç”¨çŠ¶æ€
#[derive(Clone)]
pub struct AppState {
    pub service_registry: ServiceRegistry,
    pub load_balancer: LoadBalancer,
    pub circuit_breaker: CircuitBreaker,
    pub database_pool: DatabasePool,
    pub redis_pool: RedisPool,
    pub cache: MultiLevelCache,
}

// ä¸»åº”ç”¨å¤„ç†å™¨
#[handler]
async fn health_check() -> Json<HealthStatus> {
    Json(HealthStatus {
        status: "healthy".to_string(),
        timestamp: chrono::Utc::now(),
        version: env!("CARGO_PKG_VERSION").to_string(),
    })
}

#[handler]
async fn get_user(
    Path(id): Path<u64>,
    Data(state): Data<&AppState>,
) -> Result<Json<User>, ApiError> {
    // ä½¿ç”¨ç†”æ–­å™¨ä¿æŠ¤æ•°æ®åº“è°ƒç”¨
    let user = state.circuit_breaker.call(|| async {
        // é¦–å…ˆæ£€æŸ¥ç¼“å­˜
        if let Some(cached_user) = state.cache.get(&format!("user:{}", id)).await {
            let user: User = serde_json::from_str(&cached_user)?;
            return Ok(user);
        }
        
        // ä»æ•°æ®åº“è·å–
        let user = find_user_from_db(&state.database_pool, id).await
            .ok_or(ApiError::UserNotFound(id))?;
        
        // ç¼“å­˜ç”¨æˆ·æ•°æ®
        let user_json = serde_json::to_string(&user)?;
        state.cache.set(&format!("user:{}", id), &user_json).await?;
        
        Ok(user)
    }).await?;
    
    Ok(Json(user))
}

#[handler]
async fn create_user(
    Json(payload): Json<CreateUserRequest>,
    Data(state): Data<&AppState>,
) -> Result<Json<User>, ApiError> {
    let user = User {
        id: generate_user_id(),
        name: payload.name,
        email: payload.email,
        created_at: chrono::Utc::now(),
    };
    
    // ä¿å­˜åˆ°æ•°æ®åº“
    save_user_to_db(&state.database_pool, &user).await?;
    
    // ç¼“å­˜æ–°ç”¨æˆ·
    let user_json = serde_json::to_string(&user)?;
    state.cache.set(&format!("user:{}", user.id), &user_json).await?;
    
    Ok(Json(user))
}

#[handler]
async fn proxy_to_service(
    Path(service_name): Path<String>,
    Path(path): Path<String>,
    Data(state): Data<&AppState>,
) -> Result<Json<serde_json::Value>, ApiError> {
    // ä½¿ç”¨è´Ÿè½½å‡è¡¡å™¨é€‰æ‹©æœåŠ¡
    let service = state.load_balancer.select_service().await
        .ok_or(ApiError::NoAvailableServices)?;
    
    // ä½¿ç”¨ç†”æ–­å™¨ä¿æŠ¤å¤–éƒ¨æœåŠ¡è°ƒç”¨
    let result = state.circuit_breaker.call(|| async {
        let client = reqwest::Client::new();
        let url = format!("http://{}:{}/{}", service.address, service.port, path);
        
        let response = client.get(&url).send().await
            .map_err(|e| ApiError::InternalError(e.to_string()))?;
        
        let data: serde_json::Value = response.json().await
            .map_err(|e| ApiError::InternalError(e.to_string()))?;
        
        Ok(data)
    }).await?;
    
    Ok(Json(result))
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åˆå§‹åŒ–æ—¥å¿—
    tracing_subscriber::fmt::init();
    
    // åˆå§‹åŒ–åº”ç”¨çŠ¶æ€
    let service_registry = ServiceRegistry::new();
    let load_balancer = LoadBalancer::new(LoadBalanceStrategy::RoundRobin);
    let circuit_breaker = CircuitBreaker::new(5, Duration::from_secs(30));
    let database_pool = DatabasePool::new("postgresql://user:password@localhost/mydb").await?;
    let redis_pool = RedisPool::new("redis://localhost:6379").await?;
    let cache = MultiLevelCache::new(Arc::new(redis_pool.clone()), Duration::from_secs(300));
    
    let app_state = AppState {
        service_registry,
        load_balancer,
        circuit_breaker,
        database_pool,
        redis_pool,
        cache,
    };
    
    // åˆ›å»ºè·¯ç”±
    let app = Route::new()
        .at("/health", get(health_check))
        .at("/users/:id", get(get_user))
        .at("/users", post(create_user))
        .at("/proxy/:service_name/*path", get(proxy_to_service))
        .with(Tracing)
        .data(app_state);
    
    // å¯åŠ¨æœåŠ¡å™¨
    Server::new(TcpListener::bind("0.0.0.0:3000"))
        .run(app)
        .await?;
    
    Ok(())
}
```

### 2. ä¸­é—´ä»¶å¼€å‘

```rust
use poem::{middleware::Middleware, Endpoint, EndpointExt, Request, Response};

// è¯·æ±‚æ—¥å¿—ä¸­é—´ä»¶
pub struct RequestLoggingMiddleware;

impl<E: Endpoint> Middleware<E> for RequestLoggingMiddleware {
    type Output = RequestLoggingMiddlewareImpl<E>;

    fn transform(&self, ep: E) -> Self::Output {
        RequestLoggingMiddlewareImpl { ep }
    }
}

struct RequestLoggingMiddlewareImpl<E> {
    ep: E,
}

#[poem::async_trait]
impl<E: Endpoint> Endpoint for RequestLoggingMiddlewareImpl<E> {
    type Output = E::Output;

    async fn call(&self, req: Request) -> Self::Output {
        let start_time = std::time::Instant::now();
        let method = req.method().clone();
        let path = req.uri().path().to_string();
        
        tracing::info!("è¯·æ±‚å¼€å§‹: {} {}", method, path);
        
        let response = self.ep.call(req).await;
        
        let duration = start_time.elapsed();
        tracing::info!("è¯·æ±‚å®Œæˆ: {} {} - {}ms", method, path, duration.as_millis());
        
        response
    }
}

// é™æµä¸­é—´ä»¶
pub struct RateLimitMiddleware {
    max_requests: u32,
    window: Duration,
    requests: Arc<RwLock<VecDeque<Instant>>>,
}

impl RateLimitMiddleware {
    pub fn new(max_requests: u32, window: Duration) -> Self {
        Self {
            max_requests,
            window,
            requests: Arc::new(RwLock::new(VecDeque::new())),
        }
    }
}

impl<E: Endpoint> Middleware<E> for RateLimitMiddleware {
    type Output = RateLimitMiddlewareImpl<E>;

    fn transform(&self, ep: E) -> Self::Output {
        RateLimitMiddlewareImpl {
            ep,
            max_requests: self.max_requests,
            window: self.window,
            requests: self.requests.clone(),
        }
    }
}

struct RateLimitMiddlewareImpl<E> {
    ep: E,
    max_requests: u32,
    window: Duration,
    requests: Arc<RwLock<VecDeque<Instant>>>,
}

#[poem::async_trait]
impl<E: Endpoint> Endpoint for RateLimitMiddlewareImpl<E> {
    type Output = E::Output;

    async fn call(&self, req: Request) -> Self::Output {
        let now = Instant::now();
        
        // æ¸…ç†è¿‡æœŸçš„è¯·æ±‚è®°å½•
        {
            let mut requests = self.requests.write().await;
            while let Some(&oldest) = requests.front() {
                if now.duration_since(oldest) > self.window {
                    requests.pop_front();
                } else {
                    break;
                }
            }
            
            if requests.len() >= self.max_requests as usize {
                return Response::builder()
                    .status(StatusCode::TOO_MANY_REQUESTS)
                    .body("Rate limit exceeded");
            }
            
            requests.push_back(now);
        }
        
        self.ep.call(req).await
    }
}

// ä½¿ç”¨ä¸­é—´ä»¶
let app = Route::new()
    .at("/api/*", api_routes)
    .with(RequestLoggingMiddleware)
    .with(RateLimitMiddleware::new(100, Duration::from_secs(1)))
    .with(Tracing);
```

## æœ€ä½³å®è·µ

### 1. é”™è¯¯å¤„ç†ç­–ç•¥

```rust
use poem::{error::Result, Error, Response, StatusCode};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum AppError {
    #[error("æ•°æ®åº“é”™è¯¯: {0}")]
    DatabaseError(#[from] sqlx::Error),
    #[error("Redisé”™è¯¯: {0}")]
    RedisError(#[from] redis::RedisError),
    #[error("JSONé”™è¯¯: {0}")]
    JsonError(#[from] serde_json::Error),
    #[error("HTTPé”™è¯¯: {0}")]
    HttpError(#[from] reqwest::Error),
    #[error("ç”¨æˆ·ä¸å­˜åœ¨: {0}")]
    UserNotFound(u64),
    #[error("è®¤è¯å¤±è´¥")]
    AuthenticationFailed,
    #[error("æƒé™ä¸è¶³")]
    InsufficientPermissions,
}

impl From<AppError> for Error {
    fn from(err: AppError) -> Self {
        let status = match err {
            AppError::DatabaseError(_) => StatusCode::INTERNAL_SERVER_ERROR,
            AppError::RedisError(_) => StatusCode::INTERNAL_SERVER_ERROR,
            AppError::JsonError(_) => StatusCode::BAD_REQUEST,
            AppError::HttpError(_) => StatusCode::BAD_GATEWAY,
            AppError::UserNotFound(_) => StatusCode::NOT_FOUND,
            AppError::AuthenticationFailed => StatusCode::UNAUTHORIZED,
            AppError::InsufficientPermissions => StatusCode::FORBIDDEN,
        };
        
        Error::from_string(err.to_string(), status)
    }
}
```

### 2. é…ç½®ç®¡ç†

```rust
use poem::{handler, web::Json, EndpointExt, Route};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AppConfig {
    pub server: ServerConfig,
    pub database: DatabaseConfig,
    pub redis: RedisConfig,
    pub logging: LoggingConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerConfig {
    pub host: String,
    pub port: u16,
    pub workers: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DatabaseConfig {
    pub url: String,
    pub max_connections: u32,
    pub min_connections: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RedisConfig {
    pub url: String,
    pub max_connections: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LoggingConfig {
    pub level: String,
    pub format: String,
}

impl AppConfig {
    pub fn from_env() -> Result<Self, config::ConfigError> {
        let mut settings = config::Config::default();
        
        // ä»ç¯å¢ƒå˜é‡åŠ è½½é…ç½®
        settings.merge(config::Environment::with_prefix("APP"))?;
        
        // ä»é…ç½®æ–‡ä»¶åŠ è½½
        if let Ok(config_file) = std::env::var("CONFIG_FILE") {
            settings.merge(config::File::with_name(&config_file))?;
        }
        
        settings.try_into()
    }
}

// é…ç½®ç«¯ç‚¹
#[handler]
async fn get_config(Data(config): Data<&AppConfig>) -> Json<AppConfig> {
    Json(config.clone())
}

#[handler]
async fn update_config(
    Json(new_config): Json<AppConfig>,
    Data(config): Data<&Arc<RwLock<AppConfig>>>,
) -> Result<Json<AppConfig>, ApiError> {
    let mut config = config.write().await;
    *config = new_config.clone();
    Ok(Json(new_config))
}
```

### 3. ç›‘æ§å’ŒæŒ‡æ ‡

```rust
use poem::{handler, web::Json, EndpointExt, Route};
use std::sync::Arc;
use tokio::sync::RwLock;
use std::time::Instant;

// åº”ç”¨æŒ‡æ ‡
#[derive(Debug, Clone, Default)]
pub struct AppMetrics {
    pub requests_total: u64,
    pub requests_success: u64,
    pub requests_error: u64,
    pub response_time_sum: u64,
    pub response_time_count: u64,
    pub active_connections: u32,
}

impl AppMetrics {
    pub fn record_request(&mut self, success: bool, response_time: Duration) {
        self.requests_total += 1;
        if success {
            self.requests_success += 1;
        } else {
            self.requests_error += 1;
        }
        
        self.response_time_sum += response_time.as_millis() as u64;
        self.response_time_count += 1;
    }
    
    pub fn average_response_time(&self) -> f64 {
        if self.response_time_count > 0 {
            self.response_time_sum as f64 / self.response_time_count as f64
        } else {
            0.0
        }
    }
    
    pub fn error_rate(&self) -> f64 {
        if self.requests_total > 0 {
            self.requests_error as f64 / self.requests_total as f64
        } else {
            0.0
        }
    }
}

// æŒ‡æ ‡ä¸­é—´ä»¶
pub struct MetricsMiddleware {
    metrics: Arc<RwLock<AppMetrics>>,
}

impl MetricsMiddleware {
    pub fn new() -> Self {
        Self {
            metrics: Arc::new(RwLock::new(AppMetrics::default())),
        }
    }
    
    pub fn get_metrics(&self) -> Arc<RwLock<AppMetrics>> {
        self.metrics.clone()
    }
}

impl<E: Endpoint> Middleware<E> for MetricsMiddleware {
    type Output = MetricsMiddlewareImpl<E>;

    fn transform(&self, ep: E) -> Self::Output {
        MetricsMiddlewareImpl {
            ep,
            metrics: self.metrics.clone(),
        }
    }
}

struct MetricsMiddlewareImpl<E> {
    ep: E,
    metrics: Arc<RwLock<AppMetrics>>,
}

#[poem::async_trait]
impl<E: Endpoint> Endpoint for MetricsMiddlewareImpl<E> {
    type Output = E::Output;

    async fn call(&self, req: Request) -> Self::Output {
        let start_time = Instant::now();
        
        let response = self.ep.call(req).await;
        
        let response_time = start_time.elapsed();
        let success = response.status().is_success();
        
        {
            let mut metrics = self.metrics.write().await;
            metrics.record_request(success, response_time);
        }
        
        response
    }
}

// æŒ‡æ ‡ç«¯ç‚¹
#[handler]
async fn get_metrics(Data(metrics): Data<&Arc<RwLock<AppMetrics>>>) -> Json<serde_json::Value> {
    let metrics = metrics.read().await;
    
    let metrics_json = serde_json::json!({
        "requests_total": metrics.requests_total,
        "requests_success": metrics.requests_success,
        "requests_error": metrics.requests_error,
        "average_response_time_ms": metrics.average_response_time(),
        "error_rate": metrics.error_rate(),
        "active_connections": metrics.active_connections,
    });
    
    Json(metrics_json)
}
```

## æ€»ç»“

Poem 2.0æ˜¯ä¸€ä¸ªåŠŸèƒ½å¼ºå¤§ã€æ€§èƒ½ä¼˜å¼‚çš„ç°ä»£åŒ–Webæ¡†æ¶ï¼Œç‰¹åˆ«é€‚åˆæ„å»ºå¾®æœåŠ¡æ¶æ„ï¼š

### ä¸»è¦ä¼˜åŠ¿1

1. **é«˜æ€§èƒ½**: åŸºäºTokioå¼‚æ­¥è¿è¡Œæ—¶ï¼Œæä¾›å“è¶Šçš„å¹¶å‘æ€§èƒ½
2. **ç±»å‹å®‰å…¨**: åˆ©ç”¨Rustçš„ç±»å‹ç³»ç»Ÿï¼Œç¡®ä¿ç¼–è¯‘æ—¶å®‰å…¨
3. **ç®€æ´API**: ç›´è§‚çš„APIè®¾è®¡ï¼Œé™ä½å­¦ä¹ æˆæœ¬
4. **ä¸°å¯Œç”Ÿæ€**: æ”¯æŒOpenAPIã€GraphQLã€ä¸­é—´ä»¶ç­‰
5. **å¾®æœåŠ¡å‹å¥½**: å†…ç½®æœåŠ¡å‘ç°ã€è´Ÿè½½å‡è¡¡ã€ç†”æ–­å™¨ç­‰æ”¯æŒ

### åº”ç”¨åœºæ™¯

1. **APIç½‘å…³**: æ„å»ºé«˜æ€§èƒ½çš„APIç½‘å…³
2. **å¾®æœåŠ¡**: å¼€å‘ç‹¬ç«‹çš„å¾®æœåŠ¡
3. **Webåº”ç”¨**: æ„å»ºç°ä»£åŒ–çš„Webåº”ç”¨
4. **GraphQLæœåŠ¡**: æä¾›GraphQL API
5. **å®æ—¶åº”ç”¨**: æ”¯æŒWebSocketå’ŒSSE

### æœ€ä½³å®è·µ1

1. **åˆç†ä½¿ç”¨ä¸­é—´ä»¶**: é¿å…è¿‡åº¦ä½¿ç”¨ä¸­é—´ä»¶å½±å“æ€§èƒ½
2. **é”™è¯¯å¤„ç†**: å®ç°ç»Ÿä¸€çš„é”™è¯¯å¤„ç†æœºåˆ¶
3. **é…ç½®ç®¡ç†**: ä½¿ç”¨ç¯å¢ƒå˜é‡å’Œé…ç½®æ–‡ä»¶ç®¡ç†é…ç½®
4. **ç›‘æ§æŒ‡æ ‡**: é›†æˆç›‘æ§å’ŒæŒ‡æ ‡æ”¶é›†
5. **ç¼“å­˜ç­–ç•¥**: å®ç°å¤šçº§ç¼“å­˜æå‡æ€§èƒ½

é€šè¿‡åˆç†ä½¿ç”¨Poem 2.0çš„å„ç§ç‰¹æ€§ï¼Œå¯ä»¥æ„å»ºé«˜æ€§èƒ½ã€å¯æ‰©å±•çš„ç°ä»£åŒ–å¾®æœåŠ¡æ¶æ„ï¼Œå……åˆ†å‘æŒ¥Ruståœ¨ç³»ç»Ÿç¼–ç¨‹æ–¹é¢çš„ä¼˜åŠ¿ã€‚
