# Â§öÊ°ÜÊû∂ÈõÜÊàêÊúÄ‰Ω≥ÂÆûË∑µ

> Âü∫‰∫éRust 1.90ÂíåÊúÄÊñ∞‰æùËµñÁâàÊú¨ÁöÑÂæÆÊúçÂä°Ê°ÜÊû∂ÈõÜÊàêÊåáÂçó

## üìã Ê¶ÇËø∞

Êú¨ÊñáÊ°£Êèê‰æõ‰∫ÜÂú®RustÂæÆÊúçÂä°È°πÁõÆ‰∏≠ÈõÜÊàêÂ§ö‰∏™Ê°ÜÊû∂ÁöÑÊúÄ‰Ω≥ÂÆûË∑µÔºåÂåÖÊã¨Axum„ÄÅPoem„ÄÅVoloÁ≠âÁé∞‰ª£Ê°ÜÊû∂ÁöÑÂçèÂêå‰ΩøÁî®Á≠ñÁï•„ÄÇ

## üéØ ÈõÜÊàêÁ≠ñÁï•

### 1. Ê°ÜÊû∂ÈÄâÊã©ÂéüÂàô

#### 1.1 Êåâ‰ΩøÁî®Âú∫ÊôØÈÄâÊã©

| Âú∫ÊôØ | Êé®ËçêÊ°ÜÊû∂ | ÁêÜÁî± |
|------|----------|------|
| REST API | Axum | ÊÄßËÉΩ‰ºòÁßÄÔºåÁîüÊÄÅÊàêÁÜü |
| Áé∞‰ª£ÂåñWebÊúçÂä° | Poem 3.1 | ÊúÄÊñ∞ÁâπÊÄßÔºåÁ±ªÂûãÂÆâÂÖ® |
| È´òÊÄßËÉΩRPC | Volo 0.11 | Â≠óËäÇË∑≥Âä®ÁîüÊÄÅÔºåÊÄßËÉΩÂçìË∂ä |
| ‰ºÅ‰∏öÁ∫ßÂ∫îÁî® | Actix-Web | ÂäüËÉΩÂÆåÊï¥ÔºåÁ§æÂå∫Ê¥ªË∑É |

#### 1.2 ÊäÄÊúØÊ†àÂÖºÂÆπÊÄß

```toml
# Cargo.toml - Â§öÊ°ÜÊû∂ÈõÜÊàêÈÖçÁΩÆ
[dependencies]
# WebÊ°ÜÊû∂
axum = { version = "0.8.5", features = ["macros", "multipart", "tracing"] }
poem = { version = "3.1", features = ["server"], optional = true }
actix-web = { version = "4.11.0", features = ["macros"], optional = true }

# RPCÊ°ÜÊû∂
volo = { version = "0.11", optional = true }
tonic = { version = "0.14.2", features = ["transport", "tls-ring"] }

# ÂÖ±‰∫´‰æùËµñ
tokio = { version = "1.47.1", features = ["full"] }
serde = { version = "1.0.228", features = ["derive"] }
tracing = "0.1.41"
```

### 2. Êû∂ÊûÑËÆæËÆ°Ê®°Âºè

#### 2.1 ÂàÜÂ±ÇÊû∂ÊûÑ

```rust
// src/architecture/mod.rs
pub mod web_layer;
pub mod rpc_layer;
pub mod service_layer;
pub mod data_layer;

// Áªü‰∏ÄÁöÑÊúçÂä°Êé•Âè£
pub trait Microservice {
    async fn start(&self) -> Result<(), Box<dyn std::error::Error>>;
    async fn stop(&self) -> Result<(), Box<dyn std::error::Error>>;
    async fn health_check(&self) -> Result<HealthStatus, Box<dyn std::error::Error>>;
}
```

#### 2.2 ÈÄÇÈÖçÂô®Ê®°Âºè

```rust
// src/adapters/mod.rs
use async_trait::async_trait;

#[async_trait]
pub trait ServiceAdapter {
    type Request;
    type Response;
    type Error;
    
    async fn handle(&self, request: Self::Request) -> Result<Self::Response, Self::Error>;
}

// AxumÈÄÇÈÖçÂô®
pub struct AxumAdapter {
    router: axum::Router,
}

#[async_trait]
impl ServiceAdapter for AxumAdapter {
    type Request = axum::http::Request<axum::body::Body>;
    type Response = axum::response::Response;
    type Error = axum::Error;
    
    async fn handle(&self, request: Self::Request) -> Result<Self::Response, Self::Error> {
        self.router.call(request).await
    }
}

// PoemÈÄÇÈÖçÂô®
pub struct PoemAdapter {
    app: poem::Server,
}

#[async_trait]
impl ServiceAdapter for PoemAdapter {
    type Request = poem::Request;
    type Response = poem::Response;
    type Error = poem::Error;
    
    async fn handle(&self, request: Self::Request) -> Result<Self::Response, Self::Error> {
        self.app.call(request).await
    }
}
```

## üîß ÂÖ∑‰ΩìÈõÜÊàêÂÆûÁé∞

### 1. Axum + Poem ÈõÜÊàê

#### 1.1 Ë∑ØÁî±Áªü‰∏Ä

```rust
// src/integration/axum_poem.rs
use axum::{
    extract::State,
    http::StatusCode,
    response::Json,
    routing::{get, post},
    Router,
};
use poem::{
    get, handler,
    listener::TcpListener,
    middleware::Tracing,
    EndpointExt, Route, Server,
};
use serde_json::{json, Value};

// ÂÖ±‰∫´ÁöÑ‰∏öÂä°ÈÄªËæë
pub struct UserService {
    // ‰∏öÂä°ÈÄªËæëÂÆûÁé∞
}

impl UserService {
    pub async fn get_user(&self, id: u64) -> Result<User, ServiceError> {
        // ÂÆûÁé∞Ëé∑ÂèñÁî®Êà∑ÈÄªËæë
        Ok(User { id, name: "test".to_string() })
    }
    
    pub async fn create_user(&self, user: CreateUser) -> Result<User, ServiceError> {
        // ÂÆûÁé∞ÂàõÂª∫Áî®Êà∑ÈÄªËæë
        Ok(User { id: 1, name: user.name })
    }
}

// AxumË∑ØÁî±
pub fn create_axum_router(user_service: UserService) -> Router {
    Router::new()
        .route("/users/:id", get(get_user_axum))
        .route("/users", post(create_user_axum))
        .with_state(user_service.clone())
}

async fn get_user_axum(
    State(user_service): State<UserService>,
    axum::extract::Path(id): axum::extract::Path<u64>,
) -> Result<Json<Value>, StatusCode> {
    match user_service.get_user(id).await {
        Ok(user) => Ok(Json(json!(user))),
        Err(_) => Err(StatusCode::NOT_FOUND),
    }
}

async fn create_user_axum(
    State(user_service): State<UserService>,
    Json(payload): Json<CreateUser>,
) -> Result<Json<Value>, StatusCode> {
    match user_service.create_user(payload).await {
        Ok(user) => Ok(Json(json!(user))),
        Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
    }
}

// PoemË∑ØÁî±
pub fn create_poem_router(user_service: UserService) -> Route {
    Route::new()
        .at("/users/:id", get(get_user_poem))
        .at("/users", post(create_user_poem))
        .data(user_service)
        .with(Tracing)
}

#[handler]
async fn get_user_poem(
    Path(id): Path<u64>,
    Data(user_service): Data<&UserService>,
) -> Result<Json<Value>, poem::Error> {
    match user_service.get_user(id).await {
        Ok(user) => Ok(Json(json!(user))),
        Err(_) => Err(poem::Error::from_string("User not found", StatusCode::NOT_FOUND)),
    }
}

#[handler]
async fn create_user_poem(
    Json(payload): Json<CreateUser>,
    Data(user_service): Data<&UserService>,
) -> Result<Json<Value>, poem::Error> {
    match user_service.create_user(payload).await {
        Ok(user) => Ok(Json(json!(user))),
        Err(_) => Err(poem::Error::from_string("Failed to create user", StatusCode::INTERNAL_SERVER_ERROR)),
    }
}
```

#### 1.2 Áªü‰∏ÄÂêØÂä®Âô®

```rust
// src/integration/unified_server.rs
use std::sync::Arc;
use tokio::task::JoinHandle;

pub struct UnifiedServer {
    axum_handle: Option<JoinHandle<()>>,
    poem_handle: Option<JoinHandle<()>>,
    volo_handle: Option<JoinHandle<()>>,
}

impl UnifiedServer {
    pub async fn start(
        &mut self,
        user_service: UserService,
        config: ServerConfig,
    ) -> Result<(), Box<dyn std::error::Error>> {
        // ÂêØÂä®AxumÊúçÂä°Âô®
        if config.enable_axum {
            let axum_router = create_axum_router(user_service.clone());
            let axum_handle = tokio::spawn(async move {
                let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await.unwrap();
                axum::serve(listener, axum_router).await.unwrap();
            });
            self.axum_handle = Some(axum_handle);
        }
        
        // ÂêØÂä®PoemÊúçÂä°Âô®
        if config.enable_poem {
            let poem_router = create_poem_router(user_service.clone());
            let poem_handle = tokio::spawn(async move {
                Server::new(TcpListener::bind("0.0.0.0:3001"))
                    .run(poem_router)
                    .await
                    .unwrap();
            });
            self.poem_handle = Some(poem_handle);
        }
        
        // ÂêØÂä®Volo RPCÊúçÂä°Âô®
        if config.enable_volo {
            let volo_handle = tokio::spawn(async move {
                // Volo RPCÊúçÂä°Âô®ÂêØÂä®ÈÄªËæë
                start_volo_server(user_service).await.unwrap();
            });
            self.volo_handle = Some(volo_handle);
        }
        
        Ok(())
    }
    
    pub async fn stop(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        // ‰ºòÈõÖÂÖ≥Èó≠ÊâÄÊúâÊúçÂä°Âô®
        if let Some(handle) = self.axum_handle.take() {
            handle.abort();
        }
        
        if let Some(handle) = self.poem_handle.take() {
            handle.abort();
        }
        
        if let Some(handle) = self.volo_handle.take() {
            handle.abort();
        }
        
        Ok(())
    }
}
```

### 2. Volo RPC ÈõÜÊàê

#### 2.1 RPCÊúçÂä°ÂÆö‰πâ

```rust
// src/rpc/user_service.rs
use volo_gen::user_service::{UserService, UserServiceServer};
use volo_gen::user_service::{GetUserRequest, GetUserResponse, CreateUserRequest, CreateUserResponse};

#[derive(Clone)]
pub struct UserServiceImpl {
    user_service: UserService,
}

#[volo::async_trait]
impl UserService for UserServiceImpl {
    async fn get_user(
        &self,
        req: GetUserRequest,
    ) -> Result<GetUserResponse, volo_thrift::AnyhowError> {
        let user = self.user_service.get_user(req.id).await?;
        Ok(GetUserResponse {
            user: Some(user.into()),
        })
    }
    
    async fn create_user(
        &self,
        req: CreateUserRequest,
    ) -> Result<CreateUserResponse, volo_thrift::AnyhowError> {
        let create_user = CreateUser {
            name: req.name,
        };
        let user = self.user_service.create_user(create_user).await?;
        Ok(CreateUserResponse {
            user: Some(user.into()),
        })
    }
}

pub async fn start_volo_server(user_service: UserService) -> Result<(), Box<dyn std::error::Error>> {
    let addr = "0.0.0.0:3002".parse()?;
    let user_service_impl = UserServiceImpl { user_service };
    
    Server::new(user_service_impl)
        .run(addr)
        .await?;
    
    Ok(())
}
```

### 3. ÈÖçÁΩÆÁÆ°ÁêÜ

#### 3.1 Áªü‰∏ÄÈÖçÁΩÆ

```rust
// src/config/mod.rs
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerConfig {
    pub axum: AxumConfig,
    pub poem: PoemConfig,
    pub volo: VoloConfig,
    pub database: DatabaseConfig,
    pub redis: RedisConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AxumConfig {
    pub enabled: bool,
    pub host: String,
    pub port: u16,
    pub workers: Option<usize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PoemConfig {
    pub enabled: bool,
    pub host: String,
    pub port: u16,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VoloConfig {
    pub enabled: bool,
    pub host: String,
    pub port: u16,
}

impl Default for ServerConfig {
    fn default() -> Self {
        Self {
            axum: AxumConfig {
                enabled: true,
                host: "0.0.0.0".to_string(),
                port: 3000,
                workers: None,
            },
            poem: PoemConfig {
                enabled: false,
                host: "0.0.0.0".to_string(),
                port: 3001,
            },
            volo: VoloConfig {
                enabled: false,
                host: "0.0.0.0".to_string(),
                port: 3002,
            },
            database: DatabaseConfig::default(),
            redis: RedisConfig::default(),
        }
    }
}
```

#### 3.2 ÁéØÂ¢ÉÈÖçÁΩÆ

```toml
# config/development.toml
[axum]
enabled = true
host = "0.0.0.0"
port = 3000

[poem]
enabled = true
host = "0.0.0.0"
port = 3001

[volo]
enabled = true
host = "0.0.0.0"
port = 3002

[database]
url = "postgresql://user:password@localhost:5432/microservice_dev"

[redis]
url = "redis://localhost:6379"
```

## üöÄ ÊÄßËÉΩ‰ºòÂåñ

### 1. ËøûÊé•Ê±†ÁÆ°ÁêÜ

```rust
// src/pool/mod.rs
use deadpool_postgres::{Config, Pool, Runtime};
use redis::aio::ConnectionManager;
use std::sync::Arc;

pub struct ConnectionPools {
    pub postgres: Pool,
    pub redis: Arc<ConnectionManager>,
}

impl ConnectionPools {
    pub async fn new(config: &ServerConfig) -> Result<Self, Box<dyn std::error::Error>> {
        // PostgreSQLËøûÊé•Ê±†
        let mut pg_config = Config::new();
        pg_config.url = Some(config.database.url.clone());
        let postgres = pg_config.create_pool(Some(Runtime::Tokio1), tokio_postgres::NoTls)?;
        
        // RedisËøûÊé•Ê±†
        let redis_client = redis::Client::open(config.redis.url.as_str())?;
        let redis = Arc::new(redis_client.get_connection_manager().await?);
        
        Ok(Self { postgres, redis })
    }
}
```

### 2. ÁºìÂ≠òÁ≠ñÁï•

```rust
// src/cache/mod.rs
use redis::AsyncCommands;
use serde::{Deserialize, Serialize};
use std::time::Duration;

pub struct CacheService {
    redis: Arc<ConnectionManager>,
}

impl CacheService {
    pub async fn get<T>(&self, key: &str) -> Result<Option<T>, Box<dyn std::error::Error>>
    where
        T: for<'de> Deserialize<'de>,
    {
        let mut conn = self.redis.clone();
        let data: Option<String> = conn.get(key).await?;
        
        match data {
            Some(json) => {
                let value: T = serde_json::from_str(&json)?;
                Ok(Some(value))
            }
            None => Ok(None),
        }
    }
    
    pub async fn set<T>(
        &self,
        key: &str,
        value: &T,
        ttl: Option<Duration>,
    ) -> Result<(), Box<dyn std::error::Error>>
    where
        T: Serialize,
    {
        let mut conn = self.redis.clone();
        let json = serde_json::to_string(value)?;
        
        match ttl {
            Some(duration) => {
                conn.set_ex(key, json, duration.as_secs() as usize).await?;
            }
            None => {
                conn.set(key, json).await?;
            }
        }
        
        Ok(())
    }
}
```

## üìä ÁõëÊéß‰∏éÂèØËßÇÊµãÊÄß

### 1. Áªü‰∏ÄÊåáÊ†áÊî∂ÈõÜ

```rust
// src/metrics/mod.rs
use prometheus::{Counter, Histogram, Registry};

pub struct Metrics {
    pub http_requests_total: Counter,
    pub http_request_duration: Histogram,
    pub rpc_requests_total: Counter,
    pub rpc_request_duration: Histogram,
}

impl Metrics {
    pub fn new(registry: &Registry) -> Self {
        let http_requests_total = Counter::new(
            "http_requests_total",
            "Total number of HTTP requests",
        ).unwrap();
        
        let http_request_duration = Histogram::new(
            "http_request_duration_seconds",
            "HTTP request duration in seconds",
        ).unwrap();
        
        let rpc_requests_total = Counter::new(
            "rpc_requests_total",
            "Total number of RPC requests",
        ).unwrap();
        
        let rpc_request_duration = Histogram::new(
            "rpc_request_duration_seconds",
            "RPC request duration in seconds",
        ).unwrap();
        
        registry.register(Box::new(http_requests_total.clone())).unwrap();
        registry.register(Box::new(http_request_duration.clone())).unwrap();
        registry.register(Box::new(rpc_requests_total.clone())).unwrap();
        registry.register(Box::new(rpc_request_duration.clone())).unwrap();
        
        Self {
            http_requests_total,
            http_request_duration,
            rpc_requests_total,
            rpc_request_duration,
        }
    }
}
```

### 2. ÂàÜÂ∏ÉÂºèËøΩË∏™

```rust
// src/tracing/mod.rs
use tracing::{info_span, Instrument};
use tracing_opentelemetry::OpenTelemetrySpanExt;

pub fn setup_tracing() -> Result<(), Box<dyn std::error::Error>> {
    // ÂàùÂßãÂåñOpenTelemetry
    let tracer = opentelemetry_jaeger::new_agent_pipeline()
        .with_service_name("microservice")
        .install_simple()?;
    
    // ËÆæÁΩÆtracing
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
        .with_tracer(tracer)
        .init();
    
    Ok(())
}

// Âú®ËØ∑Ê±ÇÂ§ÑÁêÜ‰∏≠‰ΩøÁî®
pub async fn handle_request_with_tracing<F, R>(
    operation: &str,
    f: F,
) -> Result<R, Box<dyn std::error::Error>>
where
    F: std::future::Future<Output = Result<R, Box<dyn std::error::Error>>>,
{
    let span = info_span!("operation", name = operation);
    f.instrument(span).await
}
```

## üõ°Ô∏è ÂÆâÂÖ®ÊúÄ‰Ω≥ÂÆûË∑µ

### 1. Áªü‰∏ÄËÆ§ËØÅ

```rust
// src/auth/mod.rs
use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: String,
    pub exp: usize,
    pub iat: usize,
}

pub struct AuthService {
    encoding_key: EncodingKey,
    decoding_key: DecodingKey,
}

impl AuthService {
    pub fn new(secret: &str) -> Self {
        let encoding_key = EncodingKey::from_secret(secret.as_ref());
        let decoding_key = DecodingKey::from_secret(secret.as_ref());
        
        Self {
            encoding_key,
            decoding_key,
        }
    }
    
    pub fn generate_token(&self, user_id: &str) -> Result<String, Box<dyn std::error::Error>> {
        let now = chrono::Utc::now().timestamp() as usize;
        let claims = Claims {
            sub: user_id.to_string(),
            exp: now + 3600, // 1Â∞èÊó∂ËøáÊúü
            iat: now,
        };
        
        let token = encode(&Header::default(), &claims, &self.encoding_key)?;
        Ok(token)
    }
    
    pub fn validate_token(&self, token: &str) -> Result<Claims, Box<dyn std::error::Error>> {
        let validation = Validation::new(Algorithm::HS256);
        let token_data = decode::<Claims>(token, &self.decoding_key, &validation)?;
        Ok(token_data.claims)
    }
}
```

### 2. ‰∏≠Èó¥‰ª∂ÈõÜÊàê

```rust
// src/middleware/mod.rs
use axum::{
    extract::Request,
    middleware::Next,
    response::Response,
};
use poem::{
    middleware::Middleware,
    Endpoint, MiddlewareResult, Request as PoemRequest, Response as PoemResponse,
};

// AxumËÆ§ËØÅ‰∏≠Èó¥‰ª∂
pub async fn auth_middleware(
    mut request: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    let auth_header = request.headers().get("Authorization");
    
    match auth_header {
        Some(header) => {
            let token = header.to_str().unwrap_or("").strip_prefix("Bearer ").unwrap_or("");
            // È™åËØÅtokenÈÄªËæë
            request.extensions_mut().insert("user_id", "123".to_string());
            Ok(next.run(request).await)
        }
        None => Err(StatusCode::UNAUTHORIZED),
    }
}

// PoemËÆ§ËØÅ‰∏≠Èó¥‰ª∂
pub struct AuthMiddleware;

impl<E: Endpoint> Middleware<E> for AuthMiddleware {
    type Output = AuthEndpoint<E>;
    
    fn transform(&self, ep: E) -> Self::Output {
        AuthEndpoint { ep }
    }
}

pub struct AuthEndpoint<E> {
    ep: E,
}

#[poem::async_trait]
impl<E: Endpoint> Endpoint for AuthEndpoint<E> {
    type Output = PoemResponse;
    
    async fn call(&self, mut req: PoemRequest) -> MiddlewareResult<Self::Output> {
        let auth_header = req.headers().get("Authorization");
        
        match auth_header {
            Some(header) => {
                let token = header.to_str().unwrap_or("").strip_prefix("Bearer ").unwrap_or("");
                // È™åËØÅtokenÈÄªËæë
                req.extensions_mut().insert("user_id", "123".to_string());
                self.ep.call(req).await
            }
            None => Ok(PoemResponse::builder()
                .status(StatusCode::UNAUTHORIZED)
                .body("Unauthorized")),
        }
    }
}
```

## üìö ÊúÄ‰Ω≥ÂÆûË∑µÊÄªÁªì

### 1. ËÆæËÆ°ÂéüÂàô

- **Âçï‰∏ÄËÅåË¥£**: ÊØè‰∏™Ê°ÜÊû∂Ë¥üË¥£ÁâπÂÆöÁöÑÂäüËÉΩÈ¢ÜÂüü
- **ÊùæËÄ¶Âêà**: ÈÄöËøáÈÄÇÈÖçÂô®Ê®°ÂºèÂÆûÁé∞Ê°ÜÊû∂Èó¥ÁöÑËß£ËÄ¶
- **Áªü‰∏ÄÊé•Âè£**: Êèê‰æõ‰∏ÄËá¥ÁöÑÊúçÂä°Êé•Âè£ÂíåÈÖçÁΩÆÁÆ°ÁêÜ
- **ÂèØÊâ©Â±ïÊÄß**: ÊîØÊåÅÊñ∞Ê°ÜÊû∂ÁöÑËΩªÊùæÈõÜÊàê

### 2. ÊÄßËÉΩËÄÉËôë

- **ËøûÊé•Ê±†**: ÂêàÁêÜÈÖçÁΩÆÊï∞ÊçÆÂ∫ìÂíåÁºìÂ≠òËøûÊé•Ê±†
- **ÂºÇÊ≠•Â§ÑÁêÜ**: ÂÖÖÂàÜÂà©Áî®RustÁöÑÂºÇÊ≠•ÁâπÊÄß
- **ËµÑÊ∫êÁÆ°ÁêÜ**: ÂèäÊó∂ÈáäÊîæ‰∏çÈúÄË¶ÅÁöÑËµÑÊ∫ê
- **ÁõëÊéßÊåáÊ†á**: Âª∫Á´ãÂÆåÂñÑÁöÑÊÄßËÉΩÁõëÊéß‰ΩìÁ≥ª

### 3. ÂÆâÂÖ®Êé™ÊñΩ

- **Áªü‰∏ÄËÆ§ËØÅ**: ÂÆûÁé∞Ë∑®Ê°ÜÊû∂ÁöÑË∫´‰ªΩÈ™åËØÅ
- **ËæìÂÖ•È™åËØÅ**: ÂØπÊâÄÊúâËæìÂÖ•ËøõË°å‰∏•Ê†ºÈ™åËØÅ
- **ÈîôËØØÂ§ÑÁêÜ**: ÈÅøÂÖçÊïèÊÑü‰ø°ÊÅØÊ≥ÑÈú≤
- **Êó•ÂøóÂÆ°ËÆ°**: ËÆ∞ÂΩïÊâÄÊúâÂÖ≥ÈîÆÊìç‰Ωú

### 4. ËøêÁª¥ÊîØÊåÅ

- **ÂÅ•Â∫∑Ê£ÄÊü•**: Êèê‰æõÁªü‰∏ÄÁöÑÂÅ•Â∫∑Ê£ÄÊü•Êé•Âè£
- **‰ºòÈõÖÂÖ≥Èó≠**: ÂÆûÁé∞ÊúçÂä°ÁöÑ‰ºòÈõÖÂÖ≥Èó≠Êú∫Âà∂
- **ÈÖçÁΩÆÁÆ°ÁêÜ**: ÊîØÊåÅÁéØÂ¢ÉÁõ∏ÂÖ≥ÁöÑÈÖçÁΩÆÁÆ°ÁêÜ
- **ÁõëÊéßÂëäË≠¶**: Âª∫Á´ãÂÆåÂñÑÁöÑÁõëÊéßÂíåÂëäË≠¶‰ΩìÁ≥ª

## üîó Áõ∏ÂÖ≥ËµÑÊ∫ê

- [AxumÂÆòÊñπÊñáÊ°£](https://docs.rs/axum/)
- [PoemÂÆòÊñπÊñáÊ°£](https://docs.rs/poem/)
- [VoloÂÆòÊñπÊñáÊ°£](https://docs.rs/volo/)
- [‰æùËµñÁÆ°ÁêÜ‰∏éÁâàÊú¨ÂçáÁ∫ßÁ≠ñÁï•](../13_2025Âπ¥ÊúÄÊñ∞ÊäÄÊúØË∂ãÂäø/13.10_‰æùËµñÁÆ°ÁêÜ‰∏éÁâàÊú¨ÂçáÁ∫ßÁ≠ñÁï•.md)
- [Rust 1.90Êñ∞ÁâπÊÄßÊñáÊ°£](../02_Rust_1.90_Êñ∞ÁâπÊÄß/)

---

**Ê≥®ÊÑè**: Êú¨ÊñáÊ°£Âü∫‰∫é2025Âπ¥9ÊúàÁöÑÊúÄÊñ∞‰æùËµñÁâàÊú¨ÔºåÂª∫ËÆÆÂÆöÊúüÊõ¥Êñ∞‰ª•‰øùÊåÅÊó∂ÊïàÊÄß„ÄÇ
