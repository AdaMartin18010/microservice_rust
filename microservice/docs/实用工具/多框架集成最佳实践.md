# å¤šæ¡†æ¶é›†æˆæœ€ä½³å®è·µ

> åŸºäºRust 1.90å’Œæœ€æ–°ä¾èµ–ç‰ˆæœ¬çš„å¾®æœåŠ¡æ¡†æ¶é›†æˆæŒ‡å—

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›äº†åœ¨Rustå¾®æœåŠ¡é¡¹ç›®ä¸­é›†æˆå¤šä¸ªæ¡†æ¶çš„æœ€ä½³å®è·µï¼ŒåŒ…æ‹¬Axumã€Poemã€Voloç­‰ç°ä»£æ¡†æ¶çš„ååŒä½¿ç”¨ç­–ç•¥ã€‚

## ğŸ¯ é›†æˆç­–ç•¥

### 1. æ¡†æ¶é€‰æ‹©åŸåˆ™

#### 1.1 æŒ‰ä½¿ç”¨åœºæ™¯é€‰æ‹©

| åœºæ™¯ | æ¨èæ¡†æ¶ | ç†ç”± |
|------|----------|------|
| REST API | Axum | æ€§èƒ½ä¼˜ç§€ï¼Œç”Ÿæ€æˆç†Ÿ |
| ç°ä»£åŒ–WebæœåŠ¡ | Poem 3.1 | æœ€æ–°ç‰¹æ€§ï¼Œç±»å‹å®‰å…¨ |
| é«˜æ€§èƒ½RPC | Volo 0.11 | å­—èŠ‚è·³åŠ¨ç”Ÿæ€ï¼Œæ€§èƒ½å“è¶Š |
| ä¼ä¸šçº§åº”ç”¨ | Actix-Web | åŠŸèƒ½å®Œæ•´ï¼Œç¤¾åŒºæ´»è·ƒ |

#### 1.2 æŠ€æœ¯æ ˆå…¼å®¹æ€§

```toml
# Cargo.toml - å¤šæ¡†æ¶é›†æˆé…ç½®
[dependencies]
# Webæ¡†æ¶
axum = { version = "0.8.5", features = ["macros", "multipart", "tracing"] }
poem = { version = "3.1", features = ["server"], optional = true }
actix-web = { version = "4.11.0", features = ["macros"], optional = true }

# RPCæ¡†æ¶
volo = { version = "0.11", optional = true }
tonic = { version = "0.14.2", features = ["transport", "tls-ring"] }

# å…±äº«ä¾èµ–
tokio = { version = "1.47.1", features = ["full"] }
serde = { version = "1.0.228", features = ["derive"] }
tracing = "0.1.41"
```

### 2. æ¶æ„è®¾è®¡æ¨¡å¼

#### 2.1 åˆ†å±‚æ¶æ„

```rust
// src/architecture/mod.rs
pub mod web_layer;
pub mod rpc_layer;
pub mod service_layer;
pub mod data_layer;

// ç»Ÿä¸€çš„æœåŠ¡æ¥å£
pub trait Microservice {
    async fn start(&self) -> Result<(), Box<dyn std::error::Error>>;
    async fn stop(&self) -> Result<(), Box<dyn std::error::Error>>;
    async fn health_check(&self) -> Result<HealthStatus, Box<dyn std::error::Error>>;
}
```

#### 2.2 é€‚é…å™¨æ¨¡å¼

```rust
// src/adapters/mod.rs
use async_trait::async_trait;

#[async_trait]
pub trait ServiceAdapter {
    type Request;
    type Response;
    type Error;
    
    async fn handle(&self, request: Self::Request) -> Result<Self::Response, Self::Error>;
}

// Axumé€‚é…å™¨
pub struct AxumAdapter {
    router: axum::Router,
}

#[async_trait]
impl ServiceAdapter for AxumAdapter {
    type Request = axum::http::Request<axum::body::Body>;
    type Response = axum::response::Response;
    type Error = axum::Error;
    
    async fn handle(&self, request: Self::Request) -> Result<Self::Response, Self::Error> {
        self.router.call(request).await
    }
}

// Poemé€‚é…å™¨
pub struct PoemAdapter {
    app: poem::Server,
}

#[async_trait]
impl ServiceAdapter for PoemAdapter {
    type Request = poem::Request;
    type Response = poem::Response;
    type Error = poem::Error;
    
    async fn handle(&self, request: Self::Request) -> Result<Self::Response, Self::Error> {
        self.app.call(request).await
    }
}
```

## ğŸ”§ å…·ä½“é›†æˆå®ç°

### 1. Axum + Poem é›†æˆ

#### 1.1 è·¯ç”±ç»Ÿä¸€

```rust
// src/integration/axum_poem.rs
use axum::{
    extract::State,
    http::StatusCode,
    response::Json,
    routing::{get, post},
    Router,
};
use poem::{
    get, handler,
    listener::TcpListener,
    middleware::Tracing,
    EndpointExt, Route, Server,
};
use serde_json::{json, Value};

// å…±äº«çš„ä¸šåŠ¡é€»è¾‘
pub struct UserService {
    // ä¸šåŠ¡é€»è¾‘å®ç°
}

impl UserService {
    pub async fn get_user(&self, id: u64) -> Result<User, ServiceError> {
        // å®ç°è·å–ç”¨æˆ·é€»è¾‘
        Ok(User { id, name: "test".to_string() })
    }
    
    pub async fn create_user(&self, user: CreateUser) -> Result<User, ServiceError> {
        // å®ç°åˆ›å»ºç”¨æˆ·é€»è¾‘
        Ok(User { id: 1, name: user.name })
    }
}

// Axumè·¯ç”±
pub fn create_axum_router(user_service: UserService) -> Router {
    Router::new()
        .route("/users/:id", get(get_user_axum))
        .route("/users", post(create_user_axum))
        .with_state(user_service.clone())
}

async fn get_user_axum(
    State(user_service): State<UserService>,
    axum::extract::Path(id): axum::extract::Path<u64>,
) -> Result<Json<Value>, StatusCode> {
    match user_service.get_user(id).await {
        Ok(user) => Ok(Json(json!(user))),
        Err(_) => Err(StatusCode::NOT_FOUND),
    }
}

async fn create_user_axum(
    State(user_service): State<UserService>,
    Json(payload): Json<CreateUser>,
) -> Result<Json<Value>, StatusCode> {
    match user_service.create_user(payload).await {
        Ok(user) => Ok(Json(json!(user))),
        Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
    }
}

// Poemè·¯ç”±
pub fn create_poem_router(user_service: UserService) -> Route {
    Route::new()
        .at("/users/:id", get(get_user_poem))
        .at("/users", post(create_user_poem))
        .data(user_service)
        .with(Tracing)
}

#[handler]
async fn get_user_poem(
    Path(id): Path<u64>,
    Data(user_service): Data<&UserService>,
) -> Result<Json<Value>, poem::Error> {
    match user_service.get_user(id).await {
        Ok(user) => Ok(Json(json!(user))),
        Err(_) => Err(poem::Error::from_string("User not found", StatusCode::NOT_FOUND)),
    }
}

#[handler]
async fn create_user_poem(
    Json(payload): Json<CreateUser>,
    Data(user_service): Data<&UserService>,
) -> Result<Json<Value>, poem::Error> {
    match user_service.create_user(payload).await {
        Ok(user) => Ok(Json(json!(user))),
        Err(_) => Err(poem::Error::from_string("Failed to create user", StatusCode::INTERNAL_SERVER_ERROR)),
    }
}
```

#### 1.2 ç»Ÿä¸€å¯åŠ¨å™¨

```rust
// src/integration/unified_server.rs
use std::sync::Arc;
use tokio::task::JoinHandle;

pub struct UnifiedServer {
    axum_handle: Option<JoinHandle<()>>,
    poem_handle: Option<JoinHandle<()>>,
    volo_handle: Option<JoinHandle<()>>,
}

impl UnifiedServer {
    pub async fn start(
        &mut self,
        user_service: UserService,
        config: ServerConfig,
    ) -> Result<(), Box<dyn std::error::Error>> {
        // å¯åŠ¨AxumæœåŠ¡å™¨
        if config.enable_axum {
            let axum_router = create_axum_router(user_service.clone());
            let axum_handle = tokio::spawn(async move {
                let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await.unwrap();
                axum::serve(listener, axum_router).await.unwrap();
            });
            self.axum_handle = Some(axum_handle);
        }
        
        // å¯åŠ¨PoemæœåŠ¡å™¨
        if config.enable_poem {
            let poem_router = create_poem_router(user_service.clone());
            let poem_handle = tokio::spawn(async move {
                Server::new(TcpListener::bind("0.0.0.0:3001"))
                    .run(poem_router)
                    .await
                    .unwrap();
            });
            self.poem_handle = Some(poem_handle);
        }
        
        // å¯åŠ¨Volo RPCæœåŠ¡å™¨
        if config.enable_volo {
            let volo_handle = tokio::spawn(async move {
                // Volo RPCæœåŠ¡å™¨å¯åŠ¨é€»è¾‘
                start_volo_server(user_service).await.unwrap();
            });
            self.volo_handle = Some(volo_handle);
        }
        
        Ok(())
    }
    
    pub async fn stop(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        // ä¼˜é›…å…³é—­æ‰€æœ‰æœåŠ¡å™¨
        if let Some(handle) = self.axum_handle.take() {
            handle.abort();
        }
        
        if let Some(handle) = self.poem_handle.take() {
            handle.abort();
        }
        
        if let Some(handle) = self.volo_handle.take() {
            handle.abort();
        }
        
        Ok(())
    }
}
```

### 2. Volo RPC é›†æˆ

#### 2.1 RPCæœåŠ¡å®šä¹‰

```rust
// src/rpc/user_service.rs
use volo_gen::user_service::{UserService, UserServiceServer};
use volo_gen::user_service::{GetUserRequest, GetUserResponse, CreateUserRequest, CreateUserResponse};

#[derive(Clone)]
pub struct UserServiceImpl {
    user_service: UserService,
}

#[volo::async_trait]
impl UserService for UserServiceImpl {
    async fn get_user(
        &self,
        req: GetUserRequest,
    ) -> Result<GetUserResponse, volo_thrift::AnyhowError> {
        let user = self.user_service.get_user(req.id).await?;
        Ok(GetUserResponse {
            user: Some(user.into()),
        })
    }
    
    async fn create_user(
        &self,
        req: CreateUserRequest,
    ) -> Result<CreateUserResponse, volo_thrift::AnyhowError> {
        let create_user = CreateUser {
            name: req.name,
        };
        let user = self.user_service.create_user(create_user).await?;
        Ok(CreateUserResponse {
            user: Some(user.into()),
        })
    }
}

pub async fn start_volo_server(user_service: UserService) -> Result<(), Box<dyn std::error::Error>> {
    let addr = "0.0.0.0:3002".parse()?;
    let user_service_impl = UserServiceImpl { user_service };
    
    Server::new(user_service_impl)
        .run(addr)
        .await?;
    
    Ok(())
}
```

### 3. é…ç½®ç®¡ç†

#### 3.1 ç»Ÿä¸€é…ç½®

```rust
// src/config/mod.rs
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerConfig {
    pub axum: AxumConfig,
    pub poem: PoemConfig,
    pub volo: VoloConfig,
    pub database: DatabaseConfig,
    pub redis: RedisConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AxumConfig {
    pub enabled: bool,
    pub host: String,
    pub port: u16,
    pub workers: Option<usize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PoemConfig {
    pub enabled: bool,
    pub host: String,
    pub port: u16,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VoloConfig {
    pub enabled: bool,
    pub host: String,
    pub port: u16,
}

impl Default for ServerConfig {
    fn default() -> Self {
        Self {
            axum: AxumConfig {
                enabled: true,
                host: "0.0.0.0".to_string(),
                port: 3000,
                workers: None,
            },
            poem: PoemConfig {
                enabled: false,
                host: "0.0.0.0".to_string(),
                port: 3001,
            },
            volo: VoloConfig {
                enabled: false,
                host: "0.0.0.0".to_string(),
                port: 3002,
            },
            database: DatabaseConfig::default(),
            redis: RedisConfig::default(),
        }
    }
}
```

#### 3.2 ç¯å¢ƒé…ç½®

```toml
# config/development.toml
[axum]
enabled = true
host = "0.0.0.0"
port = 3000

[poem]
enabled = true
host = "0.0.0.0"
port = 3001

[volo]
enabled = true
host = "0.0.0.0"
port = 3002

[database]
url = "postgresql://user:password@localhost:5432/microservice_dev"

[redis]
url = "redis://localhost:6379"
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–

### 1. è¿æ¥æ± ç®¡ç†

```rust
// src/pool/mod.rs
use deadpool_postgres::{Config, Pool, Runtime};
use redis::aio::ConnectionManager;
use std::sync::Arc;

pub struct ConnectionPools {
    pub postgres: Pool,
    pub redis: Arc<ConnectionManager>,
}

impl ConnectionPools {
    pub async fn new(config: &ServerConfig) -> Result<Self, Box<dyn std::error::Error>> {
        // PostgreSQLè¿æ¥æ± 
        let mut pg_config = Config::new();
        pg_config.url = Some(config.database.url.clone());
        let postgres = pg_config.create_pool(Some(Runtime::Tokio1), tokio_postgres::NoTls)?;
        
        // Redisè¿æ¥æ± 
        let redis_client = redis::Client::open(config.redis.url.as_str())?;
        let redis = Arc::new(redis_client.get_connection_manager().await?);
        
        Ok(Self { postgres, redis })
    }
}
```

### 2. ç¼“å­˜ç­–ç•¥

```rust
// src/cache/mod.rs
use redis::AsyncCommands;
use serde::{Deserialize, Serialize};
use std::time::Duration;

pub struct CacheService {
    redis: Arc<ConnectionManager>,
}

impl CacheService {
    pub async fn get<T>(&self, key: &str) -> Result<Option<T>, Box<dyn std::error::Error>>
    where
        T: for<'de> Deserialize<'de>,
    {
        let mut conn = self.redis.clone();
        let data: Option<String> = conn.get(key).await?;
        
        match data {
            Some(json) => {
                let value: T = serde_json::from_str(&json)?;
                Ok(Some(value))
            }
            None => Ok(None),
        }
    }
    
    pub async fn set<T>(
        &self,
        key: &str,
        value: &T,
        ttl: Option<Duration>,
    ) -> Result<(), Box<dyn std::error::Error>>
    where
        T: Serialize,
    {
        let mut conn = self.redis.clone();
        let json = serde_json::to_string(value)?;
        
        match ttl {
            Some(duration) => {
                conn.set_ex(key, json, duration.as_secs() as usize).await?;
            }
            None => {
                conn.set(key, json).await?;
            }
        }
        
        Ok(())
    }
}
```

## ğŸ“Š ç›‘æ§ä¸å¯è§‚æµ‹æ€§

### 1. ç»Ÿä¸€æŒ‡æ ‡æ”¶é›†

```rust
// src/metrics/mod.rs
use prometheus::{Counter, Histogram, Registry};

pub struct Metrics {
    pub http_requests_total: Counter,
    pub http_request_duration: Histogram,
    pub rpc_requests_total: Counter,
    pub rpc_request_duration: Histogram,
}

impl Metrics {
    pub fn new(registry: &Registry) -> Self {
        let http_requests_total = Counter::new(
            "http_requests_total",
            "Total number of HTTP requests",
        ).unwrap();
        
        let http_request_duration = Histogram::new(
            "http_request_duration_seconds",
            "HTTP request duration in seconds",
        ).unwrap();
        
        let rpc_requests_total = Counter::new(
            "rpc_requests_total",
            "Total number of RPC requests",
        ).unwrap();
        
        let rpc_request_duration = Histogram::new(
            "rpc_request_duration_seconds",
            "RPC request duration in seconds",
        ).unwrap();
        
        registry.register(Box::new(http_requests_total.clone())).unwrap();
        registry.register(Box::new(http_request_duration.clone())).unwrap();
        registry.register(Box::new(rpc_requests_total.clone())).unwrap();
        registry.register(Box::new(rpc_request_duration.clone())).unwrap();
        
        Self {
            http_requests_total,
            http_request_duration,
            rpc_requests_total,
            rpc_request_duration,
        }
    }
}
```

### 2. åˆ†å¸ƒå¼è¿½è¸ª

```rust
// src/tracing/mod.rs
use tracing::{info_span, Instrument};
use tracing_opentelemetry::OpenTelemetrySpanExt;

pub fn setup_tracing() -> Result<(), Box<dyn std::error::Error>> {
    // åˆå§‹åŒ–OpenTelemetry
    let tracer = opentelemetry_jaeger::new_agent_pipeline()
        .with_service_name("microservice")
        .install_simple()?;
    
    // è®¾ç½®tracing
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
        .with_tracer(tracer)
        .init();
    
    Ok(())
}

// åœ¨è¯·æ±‚å¤„ç†ä¸­ä½¿ç”¨
pub async fn handle_request_with_tracing<F, R>(
    operation: &str,
    f: F,
) -> Result<R, Box<dyn std::error::Error>>
where
    F: std::future::Future<Output = Result<R, Box<dyn std::error::Error>>>,
{
    let span = info_span!("operation", name = operation);
    f.instrument(span).await
}
```

## ğŸ›¡ï¸ å®‰å…¨æœ€ä½³å®è·µ

### 1. ç»Ÿä¸€è®¤è¯

```rust
// src/auth/mod.rs
use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: String,
    pub exp: usize,
    pub iat: usize,
}

pub struct AuthService {
    encoding_key: EncodingKey,
    decoding_key: DecodingKey,
}

impl AuthService {
    pub fn new(secret: &str) -> Self {
        let encoding_key = EncodingKey::from_secret(secret.as_ref());
        let decoding_key = DecodingKey::from_secret(secret.as_ref());
        
        Self {
            encoding_key,
            decoding_key,
        }
    }
    
    pub fn generate_token(&self, user_id: &str) -> Result<String, Box<dyn std::error::Error>> {
        let now = chrono::Utc::now().timestamp() as usize;
        let claims = Claims {
            sub: user_id.to_string(),
            exp: now + 3600, // 1å°æ—¶è¿‡æœŸ
            iat: now,
        };
        
        let token = encode(&Header::default(), &claims, &self.encoding_key)?;
        Ok(token)
    }
    
    pub fn validate_token(&self, token: &str) -> Result<Claims, Box<dyn std::error::Error>> {
        let validation = Validation::new(Algorithm::HS256);
        let token_data = decode::<Claims>(token, &self.decoding_key, &validation)?;
        Ok(token_data.claims)
    }
}
```

### 2. ä¸­é—´ä»¶é›†æˆ

```rust
// src/middleware/mod.rs
use axum::{
    extract::Request,
    middleware::Next,
    response::Response,
};
use poem::{
    middleware::Middleware,
    Endpoint, MiddlewareResult, Request as PoemRequest, Response as PoemResponse,
};

// Axumè®¤è¯ä¸­é—´ä»¶
pub async fn auth_middleware(
    mut request: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    let auth_header = request.headers().get("Authorization");
    
    match auth_header {
        Some(header) => {
            let token = header.to_str().unwrap_or("").strip_prefix("Bearer ").unwrap_or("");
            // éªŒè¯tokené€»è¾‘
            request.extensions_mut().insert("user_id", "123".to_string());
            Ok(next.run(request).await)
        }
        None => Err(StatusCode::UNAUTHORIZED),
    }
}

// Poemè®¤è¯ä¸­é—´ä»¶
pub struct AuthMiddleware;

impl<E: Endpoint> Middleware<E> for AuthMiddleware {
    type Output = AuthEndpoint<E>;
    
    fn transform(&self, ep: E) -> Self::Output {
        AuthEndpoint { ep }
    }
}

pub struct AuthEndpoint<E> {
    ep: E,
}

#[poem::async_trait]
impl<E: Endpoint> Endpoint for AuthEndpoint<E> {
    type Output = PoemResponse;
    
    async fn call(&self, mut req: PoemRequest) -> MiddlewareResult<Self::Output> {
        let auth_header = req.headers().get("Authorization");
        
        match auth_header {
            Some(header) => {
                let token = header.to_str().unwrap_or("").strip_prefix("Bearer ").unwrap_or("");
                // éªŒè¯tokené€»è¾‘
                req.extensions_mut().insert("user_id", "123".to_string());
                self.ep.call(req).await
            }
            None => Ok(PoemResponse::builder()
                .status(StatusCode::UNAUTHORIZED)
                .body("Unauthorized")),
        }
    }
}
```

## ğŸ“š æœ€ä½³å®è·µæ€»ç»“

### 1. è®¾è®¡åŸåˆ™

- **å•ä¸€èŒè´£**: æ¯ä¸ªæ¡†æ¶è´Ÿè´£ç‰¹å®šçš„åŠŸèƒ½é¢†åŸŸ
- **æ¾è€¦åˆ**: é€šè¿‡é€‚é…å™¨æ¨¡å¼å®ç°æ¡†æ¶é—´çš„è§£è€¦
- **ç»Ÿä¸€æ¥å£**: æä¾›ä¸€è‡´çš„æœåŠ¡æ¥å£å’Œé…ç½®ç®¡ç†
- **å¯æ‰©å±•æ€§**: æ”¯æŒæ–°æ¡†æ¶çš„è½»æ¾é›†æˆ

### 2. æ€§èƒ½è€ƒè™‘

- **è¿æ¥æ± **: åˆç†é…ç½®æ•°æ®åº“å’Œç¼“å­˜è¿æ¥æ± 
- **å¼‚æ­¥å¤„ç†**: å……åˆ†åˆ©ç”¨Rustçš„å¼‚æ­¥ç‰¹æ€§
- **èµ„æºç®¡ç†**: åŠæ—¶é‡Šæ”¾ä¸éœ€è¦çš„èµ„æº
- **ç›‘æ§æŒ‡æ ‡**: å»ºç«‹å®Œå–„çš„æ€§èƒ½ç›‘æ§ä½“ç³»

### 3. å®‰å…¨æªæ–½

- **ç»Ÿä¸€è®¤è¯**: å®ç°è·¨æ¡†æ¶çš„èº«ä»½éªŒè¯
- **è¾“å…¥éªŒè¯**: å¯¹æ‰€æœ‰è¾“å…¥è¿›è¡Œä¸¥æ ¼éªŒè¯
- **é”™è¯¯å¤„ç†**: é¿å…æ•æ„Ÿä¿¡æ¯æ³„éœ²
- **æ—¥å¿—å®¡è®¡**: è®°å½•æ‰€æœ‰å…³é”®æ“ä½œ

### 4. è¿ç»´æ”¯æŒ

- **å¥åº·æ£€æŸ¥**: æä¾›ç»Ÿä¸€çš„å¥åº·æ£€æŸ¥æ¥å£
- **ä¼˜é›…å…³é—­**: å®ç°æœåŠ¡çš„ä¼˜é›…å…³é—­æœºåˆ¶
- **é…ç½®ç®¡ç†**: æ”¯æŒç¯å¢ƒç›¸å…³çš„é…ç½®ç®¡ç†
- **ç›‘æ§å‘Šè­¦**: å»ºç«‹å®Œå–„çš„ç›‘æ§å’Œå‘Šè­¦ä½“ç³»

## ğŸ”— ç›¸å…³èµ„æº

- [Axumå®˜æ–¹æ–‡æ¡£](https://docs.rs/axum/)
- [Poemå®˜æ–¹æ–‡æ¡£](https://docs.rs/poem/)
- [Voloå®˜æ–¹æ–‡æ¡£](https://docs.rs/volo/)
- [ä¾èµ–ç®¡ç†ä¸ç‰ˆæœ¬å‡çº§ç­–ç•¥](../13_2025å¹´æœ€æ–°æŠ€æœ¯è¶‹åŠ¿/13.10_ä¾èµ–ç®¡ç†ä¸ç‰ˆæœ¬å‡çº§ç­–ç•¥.md)
- [Rust 1.90æ–°ç‰¹æ€§æ–‡æ¡£](../02_Rust_1.90_æ–°ç‰¹æ€§/)

---

**æ³¨æ„**: æœ¬æ–‡æ¡£åŸºäº2025å¹´9æœˆçš„æœ€æ–°ä¾èµ–ç‰ˆæœ¬ï¼Œå»ºè®®å®šæœŸæ›´æ–°ä»¥ä¿æŒæ—¶æ•ˆæ€§ã€‚
