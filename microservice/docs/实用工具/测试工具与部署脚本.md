# 测试工具与部署脚本

## 概述

本文档提供了完整的测试工具和部署脚本集合，帮助开发者进行微服务的自动化测试、部署和运维。这些工具大大提高了开发效率，确保了代码质量和部署的可靠性。

## 测试工具集

### 1. 自动化测试框架

```rust
// 测试框架主文件
use std::collections::HashMap;
use tokio_test;
use testcontainers::*;
use testcontainers::images::postgres::Postgres;
use testcontainers::images::redis::Redis;

pub struct TestFramework {
    test_containers: HashMap<String, Container<Cli, GenericImage>>,
    test_config: TestConfig,
}

#[derive(Debug, Clone)]
pub struct TestConfig {
    pub database_url: String,
    pub redis_url: String,
    pub test_timeout: Duration,
    pub parallel_tests: bool,
    pub test_data_path: String,
}

impl TestFramework {
    pub async fn new() -> Result<Self, TestError> {
        let docker = clients::Cli::default();
        let mut test_containers = HashMap::new();
        
        // 启动PostgreSQL测试容器
        let postgres_image = Postgres::default();
        let postgres_container = docker.run(postgres_image);
        let postgres_port = postgres_container.get_host_port_ipv4(5432);
        let database_url = format!("postgresql://postgres:postgres@localhost:{}/postgres", postgres_port);
        
        // 启动Redis测试容器
        let redis_image = Redis::default();
        let redis_container = docker.run(redis_image);
        let redis_port = redis_container.get_host_port_ipv4(6379);
        let redis_url = format!("redis://localhost:{}", redis_port);
        
        test_containers.insert("postgres".to_string(), postgres_container);
        test_containers.insert("redis".to_string(), redis_container);
        
        let test_config = TestConfig {
            database_url,
            redis_url,
            test_timeout: Duration::from_secs(30),
            parallel_tests: true,
            test_data_path: "tests/data".to_string(),
        };
        
        Ok(Self {
            test_containers,
            test_config,
        })
    }
    
    pub async fn setup_test_environment(&self) -> Result<TestEnvironment, TestError> {
        // 初始化数据库
        let database = Database::new(&self.test_config.database_url).await?;
        database.run_migrations().await?;
        
        // 初始化Redis
        let redis = RedisClient::new(&self.test_config.redis_url).await?;
        
        // 加载测试数据
        let test_data = self.load_test_data().await?;
        
        Ok(TestEnvironment {
            database,
            redis,
            test_data,
            config: self.test_config.clone(),
        })
    }
    
    async fn load_test_data(&self) -> Result<TestData, TestError> {
        let mut test_data = TestData::new();
        
        // 加载用户测试数据
        let users_data = tokio::fs::read_to_string(format!("{}/users.json", self.test_config.test_data_path)).await?;
        let users: Vec<User> = serde_json::from_str(&users_data)?;
        test_data.users = users;
        
        // 加载商品测试数据
        let products_data = tokio::fs::read_to_string(format!("{}/products.json", self.test_config.test_data_path)).await?;
        let products: Vec<Product> = serde_json::from_str(&products_data)?;
        test_data.products = products;
        
        Ok(test_data)
    }
}

// 测试环境
pub struct TestEnvironment {
    pub database: Database,
    pub redis: RedisClient,
    pub test_data: TestData,
    pub config: TestConfig,
}

impl TestEnvironment {
    pub async fn cleanup(&self) -> Result<(), TestError> {
        // 清理数据库
        self.database.cleanup().await?;
        
        // 清理Redis
        self.redis.cleanup().await?;
        
        Ok(())
    }
    
    pub async fn reset(&self) -> Result<(), TestError> {
        // 重置数据库
        self.database.reset().await?;
        
        // 重置Redis
        self.redis.reset().await?;
        
        Ok(())
    }
}
```

### 2. API测试工具

```rust
// API测试工具
use reqwest::Client;
use serde_json::Value;
use std::collections::HashMap;

pub struct ApiTestClient {
    client: Client,
    base_url: String,
    auth_token: Option<String>,
}

impl ApiTestClient {
    pub fn new(base_url: String) -> Self {
        Self {
            client: Client::new(),
            base_url,
            auth_token: None,
        }
    }
    
    pub fn with_auth(mut self, token: String) -> Self {
        self.auth_token = Some(token);
        self
    }
    
    pub async fn get(&self, path: &str) -> Result<ApiResponse, ApiTestError> {
        let url = format!("{}{}", self.base_url, path);
        let mut request = self.client.get(&url);
        
        if let Some(token) = &self.auth_token {
            request = request.bearer_auth(token);
        }
        
        let response = request.send().await?;
        let status = response.status();
        let headers = response.headers().clone();
        let body = response.text().await?;
        
        Ok(ApiResponse {
            status,
            headers,
            body,
        })
    }
    
    pub async fn post(&self, path: &str, body: Value) -> Result<ApiResponse, ApiTestError> {
        let url = format!("{}{}", self.base_url, path);
        let mut request = self.client.post(&url).json(&body);
        
        if let Some(token) = &self.auth_token {
            request = request.bearer_auth(token);
        }
        
        let response = request.send().await?;
        let status = response.status();
        let headers = response.headers().clone();
        let body = response.text().await?;
        
        Ok(ApiResponse {
            status,
            headers,
            body,
        })
    }
    
    pub async fn put(&self, path: &str, body: Value) -> Result<ApiResponse, ApiTestError> {
        let url = format!("{}{}", self.base_url, path);
        let mut request = self.client.put(&url).json(&body);
        
        if let Some(token) = &self.auth_token {
            request = request.bearer_auth(token);
        }
        
        let response = request.send().await?;
        let status = response.status();
        let headers = response.headers().clone();
        let body = response.text().await?;
        
        Ok(ApiResponse {
            status,
            headers,
            body,
        })
    }
    
    pub async fn delete(&self, path: &str) -> Result<ApiResponse, ApiTestError> {
        let url = format!("{}{}", self.base_url, path);
        let mut request = self.client.delete(&url);
        
        if let Some(token) = &self.auth_token {
            request = request.bearer_auth(token);
        }
        
        let response = request.send().await?;
        let status = response.status();
        let headers = response.headers().clone();
        let body = response.text().await?;
        
        Ok(ApiResponse {
            status,
            headers,
            body,
        })
    }
}

// API响应
#[derive(Debug)]
pub struct ApiResponse {
    pub status: reqwest::StatusCode,
    pub headers: reqwest::header::HeaderMap,
    pub body: String,
}

impl ApiResponse {
    pub fn json<T>(&self) -> Result<T, serde_json::Error>
    where
        T: serde::de::DeserializeOwned,
    {
        serde_json::from_str(&self.body)
    }
    
    pub fn assert_status(&self, expected_status: reqwest::StatusCode) -> Result<(), ApiTestError> {
        if self.status != expected_status {
            return Err(ApiTestError::StatusMismatch {
                expected: expected_status,
                actual: self.status,
            });
        }
        Ok(())
    }
    
    pub fn assert_json_contains(&self, key: &str, expected_value: Value) -> Result<(), ApiTestError> {
        let json: Value = self.json()?;
        
        if let Some(actual_value) = json.get(key) {
            if actual_value != &expected_value {
                return Err(ApiTestError::ValueMismatch {
                    key: key.to_string(),
                    expected: expected_value,
                    actual: actual_value.clone(),
                });
            }
        } else {
            return Err(ApiTestError::KeyNotFound(key.to_string()));
        }
        
        Ok(())
    }
}
```

### 3. 性能测试工具

```rust
// 性能测试工具
use std::time::{Duration, Instant};
use tokio::time::sleep;
use std::sync::Arc;
use tokio::sync::Semaphore;

pub struct PerformanceTester {
    client: ApiTestClient,
    config: PerformanceTestConfig,
}

#[derive(Debug, Clone)]
pub struct PerformanceTestConfig {
    pub concurrent_users: usize,
    pub test_duration: Duration,
    pub ramp_up_duration: Duration,
    pub target_rps: Option<u32>,
    pub timeout: Duration,
}

impl PerformanceTester {
    pub fn new(client: ApiTestClient, config: PerformanceTestConfig) -> Self {
        Self { client, config }
    }
    
    pub async fn run_load_test<F>(&self, test_function: F) -> Result<PerformanceTestResult, TestError>
    where
        F: Fn(&ApiTestClient) -> BoxFuture<'_, Result<(), TestError>> + Send + Sync + 'static,
    {
        let start_time = Instant::now();
        let semaphore = Arc::new(Semaphore::new(self.config.concurrent_users));
        let mut tasks = Vec::new();
        let mut results = Vec::new();
        
        // 创建并发任务
        for _ in 0..self.config.concurrent_users {
            let semaphore = semaphore.clone();
            let client = self.client.clone();
            let test_function = test_function.clone();
            
            let task = tokio::spawn(async move {
                let _permit = semaphore.acquire().await.unwrap();
                let task_start = Instant::now();
                
                let result = test_function(&client).await;
                let duration = task_start.elapsed();
                
                TestResult {
                    success: result.is_ok(),
                    duration,
                    error: result.err(),
                }
            });
            
            tasks.push(task);
        }
        
        // 等待所有任务完成
        for task in tasks {
            if let Ok(result) = task.await {
                results.push(result);
            }
        }
        
        let total_duration = start_time.elapsed();
        
        Ok(PerformanceTestResult {
            total_duration,
            total_requests: results.len(),
            successful_requests: results.iter().filter(|r| r.success).count(),
            failed_requests: results.iter().filter(|r| !r.success).count(),
            average_response_time: self.calculate_average_response_time(&results),
            min_response_time: self.calculate_min_response_time(&results),
            max_response_time: self.calculate_max_response_time(&results),
            p95_response_time: self.calculate_percentile_response_time(&results, 95),
            p99_response_time: self.calculate_percentile_response_time(&results, 99),
            requests_per_second: results.len() as f64 / total_duration.as_secs_f64(),
        })
    }
    
    fn calculate_average_response_time(&self, results: &[TestResult]) -> Duration {
        let total_duration: Duration = results.iter().map(|r| r.duration).sum();
        total_duration / results.len() as u32
    }
    
    fn calculate_min_response_time(&self, results: &[TestResult]) -> Duration {
        results.iter().map(|r| r.duration).min().unwrap_or(Duration::ZERO)
    }
    
    fn calculate_max_response_time(&self, results: &[TestResult]) -> Duration {
        results.iter().map(|r| r.duration).max().unwrap_or(Duration::ZERO)
    }
    
    fn calculate_percentile_response_time(&self, results: &[TestResult], percentile: u8) -> Duration {
        let mut durations: Vec<Duration> = results.iter().map(|r| r.duration).collect();
        durations.sort();
        
        let index = (durations.len() as f64 * percentile as f64 / 100.0) as usize;
        durations.get(index).copied().unwrap_or(Duration::ZERO)
    }
}

#[derive(Debug)]
pub struct TestResult {
    pub success: bool,
    pub duration: Duration,
    pub error: Option<TestError>,
}

#[derive(Debug)]
pub struct PerformanceTestResult {
    pub total_duration: Duration,
    pub total_requests: usize,
    pub successful_requests: usize,
    pub failed_requests: usize,
    pub average_response_time: Duration,
    pub min_response_time: Duration,
    pub max_response_time: Duration,
    pub p95_response_time: Duration,
    pub p99_response_time: Duration,
    pub requests_per_second: f64,
}
```

## 部署脚本集

### 1. Docker部署脚本

```bash
#!/bin/bash
# docker-deploy.sh - Docker部署脚本

set -e

# 配置变量
PROJECT_NAME="ecommerce-microservices"
VERSION=${1:-"latest"}
ENVIRONMENT=${2:-"development"}
REGISTRY_URL=${3:-"localhost:5000"}

echo "🚀 开始部署 $PROJECT_NAME v$VERSION 到 $ENVIRONMENT 环境"

# 构建镜像
build_image() {
    local service_name=$1
    local service_path=$2
    
    echo "📦 构建 $service_name 镜像..."
    docker build -t $REGISTRY_URL/$service_name:$VERSION $service_path
    
    if [ $? -eq 0 ]; then
        echo "✅ $service_name 镜像构建成功"
    else
        echo "❌ $service_name 镜像构建失败"
        exit 1
    fi
}

# 推送镜像
push_image() {
    local service_name=$1
    
    echo "📤 推送 $service_name 镜像到仓库..."
    docker push $REGISTRY_URL/$service_name:$VERSION
    
    if [ $? -eq 0 ]; then
        echo "✅ $service_name 镜像推送成功"
    else
        echo "❌ $service_name 镜像推送失败"
        exit 1
    fi
}

# 部署服务
deploy_service() {
    local service_name=$1
    
    echo "🚀 部署 $service_name 服务..."
    
    # 更新docker-compose文件中的镜像版本
    sed -i "s|image: $REGISTRY_URL/$service_name:.*|image: $REGISTRY_URL/$service_name:$VERSION|g" docker-compose.$ENVIRONMENT.yml
    
    # 重启服务
    docker-compose -f docker-compose.$ENVIRONMENT.yml up -d $service_name
    
    if [ $? -eq 0 ]; then
        echo "✅ $service_name 服务部署成功"
    else
        echo "❌ $service_name 服务部署失败"
        exit 1
    fi
}

# 健康检查
health_check() {
    local service_name=$1
    local health_url=$2
    local max_attempts=30
    local attempt=1
    
    echo "🔍 检查 $service_name 服务健康状态..."
    
    while [ $attempt -le $max_attempts ]; do
        if curl -f -s $health_url > /dev/null; then
            echo "✅ $service_name 服务健康检查通过"
            return 0
        fi
        
        echo "⏳ 等待 $service_name 服务启动... ($attempt/$max_attempts)"
        sleep 10
        ((attempt++))
    done
    
    echo "❌ $service_name 服务健康检查失败"
    return 1
}

# 主部署流程
main() {
    # 构建所有服务镜像
    build_image "user-service" "./services/user-service"
    build_image "product-service" "./services/product-service"
    build_image "order-service" "./services/order-service"
    build_image "payment-service" "./services/payment-service"
    build_image "api-gateway" "./gateway"
    
    # 推送镜像到仓库
    push_image "user-service"
    push_image "product-service"
    push_image "order-service"
    push_image "payment-service"
    push_image "api-gateway"
    
    # 部署服务
    deploy_service "user-service"
    deploy_service "product-service"
    deploy_service "order-service"
    deploy_service "payment-service"
    deploy_service "api-gateway"
    
    # 健康检查
    health_check "user-service" "http://localhost:3001/health"
    health_check "product-service" "http://localhost:3002/health"
    health_check "order-service" "http://localhost:3003/health"
    health_check "payment-service" "http://localhost:3004/health"
    health_check "api-gateway" "http://localhost:8080/health"
    
    echo "🎉 所有服务部署完成！"
}

# 执行主流程
main
```

### 2. Kubernetes部署脚本

```bash
#!/bin/bash
# k8s-deploy.sh - Kubernetes部署脚本

set -e

# 配置变量
NAMESPACE=${1:-"ecommerce"}
ENVIRONMENT=${2:-"development"}
VERSION=${3:-"latest"}

echo "🚀 开始部署到 Kubernetes 集群 (命名空间: $NAMESPACE, 环境: $ENVIRONMENT, 版本: $VERSION)"

# 创建命名空间
create_namespace() {
    echo "📁 创建命名空间 $NAMESPACE..."
    kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
}

# 部署配置
deploy_config() {
    echo "⚙️ 部署配置..."
    kubectl apply -f k8s/config/ -n $NAMESPACE
}

# 部署服务
deploy_service() {
    local service_name=$1
    local manifest_path=$2
    
    echo "🚀 部署 $service_name 服务..."
    
    # 更新镜像版本
    sed "s|IMAGE_TAG|$VERSION|g" $manifest_path | kubectl apply -f - -n $NAMESPACE
    
    # 等待部署完成
    kubectl rollout status deployment/$service_name -n $NAMESPACE --timeout=300s
    
    if [ $? -eq 0 ]; then
        echo "✅ $service_name 服务部署成功"
    else
        echo "❌ $service_name 服务部署失败"
        exit 1
    fi
}

# 部署Ingress
deploy_ingress() {
    echo "🌐 部署Ingress..."
    kubectl apply -f k8s/ingress/ -n $NAMESPACE
}

# 健康检查
health_check() {
    local service_name=$1
    local port=$2
    
    echo "🔍 检查 $service_name 服务健康状态..."
    
    # 获取Pod名称
    local pod_name=$(kubectl get pods -n $NAMESPACE -l app=$service_name -o jsonpath='{.items[0].metadata.name}')
    
    if [ -z "$pod_name" ]; then
        echo "❌ 未找到 $service_name 的Pod"
        return 1
    fi
    
    # 端口转发并健康检查
    kubectl port-forward -n $NAMESPACE pod/$pod_name $port:$port &
    local port_forward_pid=$!
    
    sleep 5
    
    if curl -f -s http://localhost:$port/health > /dev/null; then
        echo "✅ $service_name 服务健康检查通过"
        kill $port_forward_pid
        return 0
    else
        echo "❌ $service_name 服务健康检查失败"
        kill $port_forward_pid
        return 1
    fi
}

# 主部署流程
main() {
    # 创建命名空间
    create_namespace
    
    # 部署配置
    deploy_config
    
    # 部署服务
    deploy_service "user-service" "k8s/deployments/user-service.yaml"
    deploy_service "product-service" "k8s/deployments/product-service.yaml"
    deploy_service "order-service" "k8s/deployments/order-service.yaml"
    deploy_service "payment-service" "k8s/deployments/payment-service.yaml"
    deploy_service "api-gateway" "k8s/deployments/api-gateway.yaml"
    
    # 部署Ingress
    deploy_ingress
    
    # 健康检查
    health_check "user-service" 3001
    health_check "product-service" 3002
    health_check "order-service" 3003
    health_check "payment-service" 3004
    health_check "api-gateway" 8080
    
    echo "🎉 所有服务部署完成！"
    echo "📊 查看服务状态: kubectl get pods -n $NAMESPACE"
    echo "🌐 访问服务: kubectl get ingress -n $NAMESPACE"
}

# 执行主流程
main
```

### 3. 数据库迁移脚本

```bash
#!/bin/bash
# db-migrate.sh - 数据库迁移脚本

set -e

# 配置变量
DATABASE_URL=${1:-"postgresql://postgres:password@localhost:5432/ecommerce"}
MIGRATION_DIR=${2:-"./migrations"}
ENVIRONMENT=${3:-"development"}

echo "🗄️ 开始数据库迁移 (环境: $ENVIRONMENT)"

# 检查数据库连接
check_database_connection() {
    echo "🔍 检查数据库连接..."
    
    if psql "$DATABASE_URL" -c "SELECT 1;" > /dev/null 2>&1; then
        echo "✅ 数据库连接成功"
    else
        echo "❌ 数据库连接失败"
        exit 1
    fi
}

# 备份数据库
backup_database() {
    if [ "$ENVIRONMENT" = "production" ]; then
        echo "💾 备份生产数据库..."
        local backup_file="backup_$(date +%Y%m%d_%H%M%S).sql"
        pg_dump "$DATABASE_URL" > "$backup_file"
        echo "✅ 数据库备份完成: $backup_file"
    fi
}

# 运行迁移
run_migrations() {
    echo "🔄 运行数据库迁移..."
    
    # 使用sqlx-cli运行迁移
    sqlx migrate run --database-url "$DATABASE_URL"
    
    if [ $? -eq 0 ]; then
        echo "✅ 数据库迁移完成"
    else
        echo "❌ 数据库迁移失败"
        exit 1
    fi
}

# 验证迁移
verify_migrations() {
    echo "✅ 验证迁移结果..."
    
    # 检查迁移表
    local migration_count=$(psql "$DATABASE_URL" -t -c "SELECT COUNT(*) FROM _sqlx_migrations;")
    echo "📊 已应用迁移数量: $migration_count"
    
    # 检查表结构
    local table_count=$(psql "$DATABASE_URL" -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';")
    echo "📊 数据库表数量: $table_count"
}

# 回滚迁移（如果需要）
rollback_migrations() {
    local target_version=$1
    
    if [ -n "$target_version" ]; then
        echo "⏪ 回滚到版本 $target_version..."
        sqlx migrate revert --database-url "$DATABASE_URL"
    fi
}

# 主迁移流程
main() {
    # 检查数据库连接
    check_database_connection
    
    # 备份数据库
    backup_database
    
    # 运行迁移
    run_migrations
    
    # 验证迁移
    verify_migrations
    
    echo "🎉 数据库迁移完成！"
}

# 执行主流程
main
```

### 4. 监控部署脚本

```bash
#!/bin/bash
# monitoring-deploy.sh - 监控系统部署脚本

set -e

# 配置变量
NAMESPACE=${1:-"monitoring"}
ENVIRONMENT=${2:-"development"}

echo "📊 开始部署监控系统 (命名空间: $NAMESPACE, 环境: $ENVIRONMENT)"

# 部署Prometheus
deploy_prometheus() {
    echo "📈 部署Prometheus..."
    
    # 创建Prometheus配置
    kubectl apply -f monitoring/prometheus/ -n $NAMESPACE
    
    # 等待Prometheus启动
    kubectl rollout status deployment/prometheus -n $NAMESPACE --timeout=300s
    
    echo "✅ Prometheus部署完成"
}

# 部署Grafana
deploy_grafana() {
    echo "📊 部署Grafana..."
    
    # 创建Grafana配置
    kubectl apply -f monitoring/grafana/ -n $NAMESPACE
    
    # 等待Grafana启动
    kubectl rollout status deployment/grafana -n $NAMESPACE --timeout=300s
    
    echo "✅ Grafana部署完成"
}

# 部署Jaeger
deploy_jaeger() {
    echo "🔍 部署Jaeger..."
    
    # 创建Jaeger配置
    kubectl apply -f monitoring/jaeger/ -n $NAMESPACE
    
    # 等待Jaeger启动
    kubectl rollout status deployment/jaeger -n $NAMESPACE --timeout=300s
    
    echo "✅ Jaeger部署完成"
}

# 部署AlertManager
deploy_alertmanager() {
    echo "🚨 部署AlertManager..."
    
    # 创建AlertManager配置
    kubectl apply -f monitoring/alertmanager/ -n $NAMESPACE
    
    # 等待AlertManager启动
    kubectl rollout status deployment/alertmanager -n $NAMESPACE --timeout=300s
    
    echo "✅ AlertManager部署完成"
}

# 配置服务发现
configure_service_discovery() {
    echo "🔍 配置服务发现..."
    
    # 创建ServiceMonitor资源
    kubectl apply -f monitoring/servicemonitor/ -n $NAMESPACE
    
    echo "✅ 服务发现配置完成"
}

# 主部署流程
main() {
    # 创建监控命名空间
    kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
    
    # 部署监控组件
    deploy_prometheus
    deploy_grafana
    deploy_jaeger
    deploy_alertmanager
    
    # 配置服务发现
    configure_service_discovery
    
    echo "🎉 监控系统部署完成！"
    echo "📊 Prometheus: kubectl port-forward -n $NAMESPACE svc/prometheus 9090:9090"
    echo "📈 Grafana: kubectl port-forward -n $NAMESPACE svc/grafana 3000:3000"
    echo "🔍 Jaeger: kubectl port-forward -n $NAMESPACE svc/jaeger 16686:16686"
}

# 执行主流程
main
```

## 使用示例

### 1. 运行测试

```bash
# 运行单元测试
cargo test

# 运行集成测试
cargo test --test integration_tests

# 运行性能测试
cargo test --test performance_tests --release

# 运行API测试
cargo test --test api_tests
```

### 2. 部署服务

```bash
# Docker部署
./scripts/docker-deploy.sh latest development

# Kubernetes部署
./scripts/k8s-deploy.sh ecommerce production v1.2.3

# 数据库迁移
./scripts/db-migrate.sh postgresql://user:pass@localhost:5432/db

# 监控部署
./scripts/monitoring-deploy.sh monitoring production
```

### 3. 自动化CI/CD

```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [main]
    tags: ['v*']

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run tests
        run: |
          cargo test
          cargo test --test integration_tests
          cargo test --test performance_tests --release

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    steps:
      - uses: actions/checkout@v3
      - name: Deploy to production
        run: |
          ./scripts/k8s-deploy.sh ecommerce production ${{ github.ref_name }}
          ./scripts/monitoring-deploy.sh monitoring production
```

## 最佳实践

### 1. 测试策略

- **单元测试**: 测试单个函数和模块
- **集成测试**: 测试服务间的交互
- **API测试**: 测试HTTP接口
- **性能测试**: 测试系统性能指标
- **端到端测试**: 测试完整业务流程

### 2. 部署策略

- **蓝绿部署**: 零停机部署
- **金丝雀部署**: 渐进式发布
- **滚动更新**: 逐步替换实例
- **自动回滚**: 失败时自动回滚

### 3. 监控策略

- **指标收集**: 收集关键业务和技术指标
- **日志聚合**: 集中化日志收集和分析
- **分布式追踪**: 跨服务请求追踪
- **告警机制**: 智能告警和通知

### 4. 安全考虑

- **镜像扫描**: 扫描容器镜像漏洞
- **密钥管理**: 安全存储和管理密钥
- **网络策略**: 限制服务间网络访问
- **RBAC**: 基于角色的访问控制

---

**文档版本**: v1.0  
**最后更新**: 2025-01-XX  
**维护者**: 工具团队
