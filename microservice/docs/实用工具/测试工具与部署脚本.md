# æµ‹è¯•å·¥å…·ä¸éƒ¨ç½²è„šæœ¬

## æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›äº†å®Œæ•´çš„æµ‹è¯•å·¥å…·å’Œéƒ¨ç½²è„šæœ¬é›†åˆï¼Œå¸®åŠ©å¼€å‘è€…è¿›è¡Œå¾®æœåŠ¡çš„è‡ªåŠ¨åŒ–æµ‹è¯•ã€éƒ¨ç½²å’Œè¿ç»´ã€‚è¿™äº›å·¥å…·å¤§å¤§æé«˜äº†å¼€å‘æ•ˆç‡ï¼Œç¡®ä¿äº†ä»£ç è´¨é‡å’Œéƒ¨ç½²çš„å¯é æ€§ã€‚

## æµ‹è¯•å·¥å…·é›†

### 1. è‡ªåŠ¨åŒ–æµ‹è¯•æ¡†æ¶

```rust
// æµ‹è¯•æ¡†æ¶ä¸»æ–‡ä»¶
use std::collections::HashMap;
use tokio_test;
use testcontainers::*;
use testcontainers::images::postgres::Postgres;
use testcontainers::images::redis::Redis;

pub struct TestFramework {
    test_containers: HashMap<String, Container<Cli, GenericImage>>,
    test_config: TestConfig,
}

#[derive(Debug, Clone)]
pub struct TestConfig {
    pub database_url: String,
    pub redis_url: String,
    pub test_timeout: Duration,
    pub parallel_tests: bool,
    pub test_data_path: String,
}

impl TestFramework {
    pub async fn new() -> Result<Self, TestError> {
        let docker = clients::Cli::default();
        let mut test_containers = HashMap::new();
        
        // å¯åŠ¨PostgreSQLæµ‹è¯•å®¹å™¨
        let postgres_image = Postgres::default();
        let postgres_container = docker.run(postgres_image);
        let postgres_port = postgres_container.get_host_port_ipv4(5432);
        let database_url = format!("postgresql://postgres:postgres@localhost:{}/postgres", postgres_port);
        
        // å¯åŠ¨Redisæµ‹è¯•å®¹å™¨
        let redis_image = Redis::default();
        let redis_container = docker.run(redis_image);
        let redis_port = redis_container.get_host_port_ipv4(6379);
        let redis_url = format!("redis://localhost:{}", redis_port);
        
        test_containers.insert("postgres".to_string(), postgres_container);
        test_containers.insert("redis".to_string(), redis_container);
        
        let test_config = TestConfig {
            database_url,
            redis_url,
            test_timeout: Duration::from_secs(30),
            parallel_tests: true,
            test_data_path: "tests/data".to_string(),
        };
        
        Ok(Self {
            test_containers,
            test_config,
        })
    }
    
    pub async fn setup_test_environment(&self) -> Result<TestEnvironment, TestError> {
        // åˆå§‹åŒ–æ•°æ®åº“
        let database = Database::new(&self.test_config.database_url).await?;
        database.run_migrations().await?;
        
        // åˆå§‹åŒ–Redis
        let redis = RedisClient::new(&self.test_config.redis_url).await?;
        
        // åŠ è½½æµ‹è¯•æ•°æ®
        let test_data = self.load_test_data().await?;
        
        Ok(TestEnvironment {
            database,
            redis,
            test_data,
            config: self.test_config.clone(),
        })
    }
    
    async fn load_test_data(&self) -> Result<TestData, TestError> {
        let mut test_data = TestData::new();
        
        // åŠ è½½ç”¨æˆ·æµ‹è¯•æ•°æ®
        let users_data = tokio::fs::read_to_string(format!("{}/users.json", self.test_config.test_data_path)).await?;
        let users: Vec<User> = serde_json::from_str(&users_data)?;
        test_data.users = users;
        
        // åŠ è½½å•†å“æµ‹è¯•æ•°æ®
        let products_data = tokio::fs::read_to_string(format!("{}/products.json", self.test_config.test_data_path)).await?;
        let products: Vec<Product> = serde_json::from_str(&products_data)?;
        test_data.products = products;
        
        Ok(test_data)
    }
}

// æµ‹è¯•ç¯å¢ƒ
pub struct TestEnvironment {
    pub database: Database,
    pub redis: RedisClient,
    pub test_data: TestData,
    pub config: TestConfig,
}

impl TestEnvironment {
    pub async fn cleanup(&self) -> Result<(), TestError> {
        // æ¸…ç†æ•°æ®åº“
        self.database.cleanup().await?;
        
        // æ¸…ç†Redis
        self.redis.cleanup().await?;
        
        Ok(())
    }
    
    pub async fn reset(&self) -> Result<(), TestError> {
        // é‡ç½®æ•°æ®åº“
        self.database.reset().await?;
        
        // é‡ç½®Redis
        self.redis.reset().await?;
        
        Ok(())
    }
}
```

### 2. APIæµ‹è¯•å·¥å…·

```rust
// APIæµ‹è¯•å·¥å…·
use reqwest::Client;
use serde_json::Value;
use std::collections::HashMap;

pub struct ApiTestClient {
    client: Client,
    base_url: String,
    auth_token: Option<String>,
}

impl ApiTestClient {
    pub fn new(base_url: String) -> Self {
        Self {
            client: Client::new(),
            base_url,
            auth_token: None,
        }
    }
    
    pub fn with_auth(mut self, token: String) -> Self {
        self.auth_token = Some(token);
        self
    }
    
    pub async fn get(&self, path: &str) -> Result<ApiResponse, ApiTestError> {
        let url = format!("{}{}", self.base_url, path);
        let mut request = self.client.get(&url);
        
        if let Some(token) = &self.auth_token {
            request = request.bearer_auth(token);
        }
        
        let response = request.send().await?;
        let status = response.status();
        let headers = response.headers().clone();
        let body = response.text().await?;
        
        Ok(ApiResponse {
            status,
            headers,
            body,
        })
    }
    
    pub async fn post(&self, path: &str, body: Value) -> Result<ApiResponse, ApiTestError> {
        let url = format!("{}{}", self.base_url, path);
        let mut request = self.client.post(&url).json(&body);
        
        if let Some(token) = &self.auth_token {
            request = request.bearer_auth(token);
        }
        
        let response = request.send().await?;
        let status = response.status();
        let headers = response.headers().clone();
        let body = response.text().await?;
        
        Ok(ApiResponse {
            status,
            headers,
            body,
        })
    }
    
    pub async fn put(&self, path: &str, body: Value) -> Result<ApiResponse, ApiTestError> {
        let url = format!("{}{}", self.base_url, path);
        let mut request = self.client.put(&url).json(&body);
        
        if let Some(token) = &self.auth_token {
            request = request.bearer_auth(token);
        }
        
        let response = request.send().await?;
        let status = response.status();
        let headers = response.headers().clone();
        let body = response.text().await?;
        
        Ok(ApiResponse {
            status,
            headers,
            body,
        })
    }
    
    pub async fn delete(&self, path: &str) -> Result<ApiResponse, ApiTestError> {
        let url = format!("{}{}", self.base_url, path);
        let mut request = self.client.delete(&url);
        
        if let Some(token) = &self.auth_token {
            request = request.bearer_auth(token);
        }
        
        let response = request.send().await?;
        let status = response.status();
        let headers = response.headers().clone();
        let body = response.text().await?;
        
        Ok(ApiResponse {
            status,
            headers,
            body,
        })
    }
}

// APIå“åº”
#[derive(Debug)]
pub struct ApiResponse {
    pub status: reqwest::StatusCode,
    pub headers: reqwest::header::HeaderMap,
    pub body: String,
}

impl ApiResponse {
    pub fn json<T>(&self) -> Result<T, serde_json::Error>
    where
        T: serde::de::DeserializeOwned,
    {
        serde_json::from_str(&self.body)
    }
    
    pub fn assert_status(&self, expected_status: reqwest::StatusCode) -> Result<(), ApiTestError> {
        if self.status != expected_status {
            return Err(ApiTestError::StatusMismatch {
                expected: expected_status,
                actual: self.status,
            });
        }
        Ok(())
    }
    
    pub fn assert_json_contains(&self, key: &str, expected_value: Value) -> Result<(), ApiTestError> {
        let json: Value = self.json()?;
        
        if let Some(actual_value) = json.get(key) {
            if actual_value != &expected_value {
                return Err(ApiTestError::ValueMismatch {
                    key: key.to_string(),
                    expected: expected_value,
                    actual: actual_value.clone(),
                });
            }
        } else {
            return Err(ApiTestError::KeyNotFound(key.to_string()));
        }
        
        Ok(())
    }
}
```

### 3. æ€§èƒ½æµ‹è¯•å·¥å…·

```rust
// æ€§èƒ½æµ‹è¯•å·¥å…·
use std::time::{Duration, Instant};
use tokio::time::sleep;
use std::sync::Arc;
use tokio::sync::Semaphore;

pub struct PerformanceTester {
    client: ApiTestClient,
    config: PerformanceTestConfig,
}

#[derive(Debug, Clone)]
pub struct PerformanceTestConfig {
    pub concurrent_users: usize,
    pub test_duration: Duration,
    pub ramp_up_duration: Duration,
    pub target_rps: Option<u32>,
    pub timeout: Duration,
}

impl PerformanceTester {
    pub fn new(client: ApiTestClient, config: PerformanceTestConfig) -> Self {
        Self { client, config }
    }
    
    pub async fn run_load_test<F>(&self, test_function: F) -> Result<PerformanceTestResult, TestError>
    where
        F: Fn(&ApiTestClient) -> BoxFuture<'_, Result<(), TestError>> + Send + Sync + 'static,
    {
        let start_time = Instant::now();
        let semaphore = Arc::new(Semaphore::new(self.config.concurrent_users));
        let mut tasks = Vec::new();
        let mut results = Vec::new();
        
        // åˆ›å»ºå¹¶å‘ä»»åŠ¡
        for _ in 0..self.config.concurrent_users {
            let semaphore = semaphore.clone();
            let client = self.client.clone();
            let test_function = test_function.clone();
            
            let task = tokio::spawn(async move {
                let _permit = semaphore.acquire().await.unwrap();
                let task_start = Instant::now();
                
                let result = test_function(&client).await;
                let duration = task_start.elapsed();
                
                TestResult {
                    success: result.is_ok(),
                    duration,
                    error: result.err(),
                }
            });
            
            tasks.push(task);
        }
        
        // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        for task in tasks {
            if let Ok(result) = task.await {
                results.push(result);
            }
        }
        
        let total_duration = start_time.elapsed();
        
        Ok(PerformanceTestResult {
            total_duration,
            total_requests: results.len(),
            successful_requests: results.iter().filter(|r| r.success).count(),
            failed_requests: results.iter().filter(|r| !r.success).count(),
            average_response_time: self.calculate_average_response_time(&results),
            min_response_time: self.calculate_min_response_time(&results),
            max_response_time: self.calculate_max_response_time(&results),
            p95_response_time: self.calculate_percentile_response_time(&results, 95),
            p99_response_time: self.calculate_percentile_response_time(&results, 99),
            requests_per_second: results.len() as f64 / total_duration.as_secs_f64(),
        })
    }
    
    fn calculate_average_response_time(&self, results: &[TestResult]) -> Duration {
        let total_duration: Duration = results.iter().map(|r| r.duration).sum();
        total_duration / results.len() as u32
    }
    
    fn calculate_min_response_time(&self, results: &[TestResult]) -> Duration {
        results.iter().map(|r| r.duration).min().unwrap_or(Duration::ZERO)
    }
    
    fn calculate_max_response_time(&self, results: &[TestResult]) -> Duration {
        results.iter().map(|r| r.duration).max().unwrap_or(Duration::ZERO)
    }
    
    fn calculate_percentile_response_time(&self, results: &[TestResult], percentile: u8) -> Duration {
        let mut durations: Vec<Duration> = results.iter().map(|r| r.duration).collect();
        durations.sort();
        
        let index = (durations.len() as f64 * percentile as f64 / 100.0) as usize;
        durations.get(index).copied().unwrap_or(Duration::ZERO)
    }
}

#[derive(Debug)]
pub struct TestResult {
    pub success: bool,
    pub duration: Duration,
    pub error: Option<TestError>,
}

#[derive(Debug)]
pub struct PerformanceTestResult {
    pub total_duration: Duration,
    pub total_requests: usize,
    pub successful_requests: usize,
    pub failed_requests: usize,
    pub average_response_time: Duration,
    pub min_response_time: Duration,
    pub max_response_time: Duration,
    pub p95_response_time: Duration,
    pub p99_response_time: Duration,
    pub requests_per_second: f64,
}
```

## éƒ¨ç½²è„šæœ¬é›†

### 1. Dockeréƒ¨ç½²è„šæœ¬

```bash
#!/bin/bash
# docker-deploy.sh - Dockeréƒ¨ç½²è„šæœ¬

set -e

# é…ç½®å˜é‡
PROJECT_NAME="ecommerce-microservices"
VERSION=${1:-"latest"}
ENVIRONMENT=${2:-"development"}
REGISTRY_URL=${3:-"localhost:5000"}

echo "ğŸš€ å¼€å§‹éƒ¨ç½² $PROJECT_NAME v$VERSION åˆ° $ENVIRONMENT ç¯å¢ƒ"

# æ„å»ºé•œåƒ
build_image() {
    local service_name=$1
    local service_path=$2
    
    echo "ğŸ“¦ æ„å»º $service_name é•œåƒ..."
    docker build -t $REGISTRY_URL/$service_name:$VERSION $service_path
    
    if [ $? -eq 0 ]; then
        echo "âœ… $service_name é•œåƒæ„å»ºæˆåŠŸ"
    else
        echo "âŒ $service_name é•œåƒæ„å»ºå¤±è´¥"
        exit 1
    fi
}

# æ¨é€é•œåƒ
push_image() {
    local service_name=$1
    
    echo "ğŸ“¤ æ¨é€ $service_name é•œåƒåˆ°ä»“åº“..."
    docker push $REGISTRY_URL/$service_name:$VERSION
    
    if [ $? -eq 0 ]; then
        echo "âœ… $service_name é•œåƒæ¨é€æˆåŠŸ"
    else
        echo "âŒ $service_name é•œåƒæ¨é€å¤±è´¥"
        exit 1
    fi
}

# éƒ¨ç½²æœåŠ¡
deploy_service() {
    local service_name=$1
    
    echo "ğŸš€ éƒ¨ç½² $service_name æœåŠ¡..."
    
    # æ›´æ–°docker-composeæ–‡ä»¶ä¸­çš„é•œåƒç‰ˆæœ¬
    sed -i "s|image: $REGISTRY_URL/$service_name:.*|image: $REGISTRY_URL/$service_name:$VERSION|g" docker-compose.$ENVIRONMENT.yml
    
    # é‡å¯æœåŠ¡
    docker-compose -f docker-compose.$ENVIRONMENT.yml up -d $service_name
    
    if [ $? -eq 0 ]; then
        echo "âœ… $service_name æœåŠ¡éƒ¨ç½²æˆåŠŸ"
    else
        echo "âŒ $service_name æœåŠ¡éƒ¨ç½²å¤±è´¥"
        exit 1
    fi
}

# å¥åº·æ£€æŸ¥
health_check() {
    local service_name=$1
    local health_url=$2
    local max_attempts=30
    local attempt=1
    
    echo "ğŸ” æ£€æŸ¥ $service_name æœåŠ¡å¥åº·çŠ¶æ€..."
    
    while [ $attempt -le $max_attempts ]; do
        if curl -f -s $health_url > /dev/null; then
            echo "âœ… $service_name æœåŠ¡å¥åº·æ£€æŸ¥é€šè¿‡"
            return 0
        fi
        
        echo "â³ ç­‰å¾… $service_name æœåŠ¡å¯åŠ¨... ($attempt/$max_attempts)"
        sleep 10
        ((attempt++))
    done
    
    echo "âŒ $service_name æœåŠ¡å¥åº·æ£€æŸ¥å¤±è´¥"
    return 1
}

# ä¸»éƒ¨ç½²æµç¨‹
main() {
    # æ„å»ºæ‰€æœ‰æœåŠ¡é•œåƒ
    build_image "user-service" "./services/user-service"
    build_image "product-service" "./services/product-service"
    build_image "order-service" "./services/order-service"
    build_image "payment-service" "./services/payment-service"
    build_image "api-gateway" "./gateway"
    
    # æ¨é€é•œåƒåˆ°ä»“åº“
    push_image "user-service"
    push_image "product-service"
    push_image "order-service"
    push_image "payment-service"
    push_image "api-gateway"
    
    # éƒ¨ç½²æœåŠ¡
    deploy_service "user-service"
    deploy_service "product-service"
    deploy_service "order-service"
    deploy_service "payment-service"
    deploy_service "api-gateway"
    
    # å¥åº·æ£€æŸ¥
    health_check "user-service" "http://localhost:3001/health"
    health_check "product-service" "http://localhost:3002/health"
    health_check "order-service" "http://localhost:3003/health"
    health_check "payment-service" "http://localhost:3004/health"
    health_check "api-gateway" "http://localhost:8080/health"
    
    echo "ğŸ‰ æ‰€æœ‰æœåŠ¡éƒ¨ç½²å®Œæˆï¼"
}

# æ‰§è¡Œä¸»æµç¨‹
main
```

### 2. Kuberneteséƒ¨ç½²è„šæœ¬

```bash
#!/bin/bash
# k8s-deploy.sh - Kuberneteséƒ¨ç½²è„šæœ¬

set -e

# é…ç½®å˜é‡
NAMESPACE=${1:-"ecommerce"}
ENVIRONMENT=${2:-"development"}
VERSION=${3:-"latest"}

echo "ğŸš€ å¼€å§‹éƒ¨ç½²åˆ° Kubernetes é›†ç¾¤ (å‘½åç©ºé—´: $NAMESPACE, ç¯å¢ƒ: $ENVIRONMENT, ç‰ˆæœ¬: $VERSION)"

# åˆ›å»ºå‘½åç©ºé—´
create_namespace() {
    echo "ğŸ“ åˆ›å»ºå‘½åç©ºé—´ $NAMESPACE..."
    kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
}

# éƒ¨ç½²é…ç½®
deploy_config() {
    echo "âš™ï¸ éƒ¨ç½²é…ç½®..."
    kubectl apply -f k8s/config/ -n $NAMESPACE
}

# éƒ¨ç½²æœåŠ¡
deploy_service() {
    local service_name=$1
    local manifest_path=$2
    
    echo "ğŸš€ éƒ¨ç½² $service_name æœåŠ¡..."
    
    # æ›´æ–°é•œåƒç‰ˆæœ¬
    sed "s|IMAGE_TAG|$VERSION|g" $manifest_path | kubectl apply -f - -n $NAMESPACE
    
    # ç­‰å¾…éƒ¨ç½²å®Œæˆ
    kubectl rollout status deployment/$service_name -n $NAMESPACE --timeout=300s
    
    if [ $? -eq 0 ]; then
        echo "âœ… $service_name æœåŠ¡éƒ¨ç½²æˆåŠŸ"
    else
        echo "âŒ $service_name æœåŠ¡éƒ¨ç½²å¤±è´¥"
        exit 1
    fi
}

# éƒ¨ç½²Ingress
deploy_ingress() {
    echo "ğŸŒ éƒ¨ç½²Ingress..."
    kubectl apply -f k8s/ingress/ -n $NAMESPACE
}

# å¥åº·æ£€æŸ¥
health_check() {
    local service_name=$1
    local port=$2
    
    echo "ğŸ” æ£€æŸ¥ $service_name æœåŠ¡å¥åº·çŠ¶æ€..."
    
    # è·å–Podåç§°
    local pod_name=$(kubectl get pods -n $NAMESPACE -l app=$service_name -o jsonpath='{.items[0].metadata.name}')
    
    if [ -z "$pod_name" ]; then
        echo "âŒ æœªæ‰¾åˆ° $service_name çš„Pod"
        return 1
    fi
    
    # ç«¯å£è½¬å‘å¹¶å¥åº·æ£€æŸ¥
    kubectl port-forward -n $NAMESPACE pod/$pod_name $port:$port &
    local port_forward_pid=$!
    
    sleep 5
    
    if curl -f -s http://localhost:$port/health > /dev/null; then
        echo "âœ… $service_name æœåŠ¡å¥åº·æ£€æŸ¥é€šè¿‡"
        kill $port_forward_pid
        return 0
    else
        echo "âŒ $service_name æœåŠ¡å¥åº·æ£€æŸ¥å¤±è´¥"
        kill $port_forward_pid
        return 1
    fi
}

# ä¸»éƒ¨ç½²æµç¨‹
main() {
    # åˆ›å»ºå‘½åç©ºé—´
    create_namespace
    
    # éƒ¨ç½²é…ç½®
    deploy_config
    
    # éƒ¨ç½²æœåŠ¡
    deploy_service "user-service" "k8s/deployments/user-service.yaml"
    deploy_service "product-service" "k8s/deployments/product-service.yaml"
    deploy_service "order-service" "k8s/deployments/order-service.yaml"
    deploy_service "payment-service" "k8s/deployments/payment-service.yaml"
    deploy_service "api-gateway" "k8s/deployments/api-gateway.yaml"
    
    # éƒ¨ç½²Ingress
    deploy_ingress
    
    # å¥åº·æ£€æŸ¥
    health_check "user-service" 3001
    health_check "product-service" 3002
    health_check "order-service" 3003
    health_check "payment-service" 3004
    health_check "api-gateway" 8080
    
    echo "ğŸ‰ æ‰€æœ‰æœåŠ¡éƒ¨ç½²å®Œæˆï¼"
    echo "ğŸ“Š æŸ¥çœ‹æœåŠ¡çŠ¶æ€: kubectl get pods -n $NAMESPACE"
    echo "ğŸŒ è®¿é—®æœåŠ¡: kubectl get ingress -n $NAMESPACE"
}

# æ‰§è¡Œä¸»æµç¨‹
main
```

### 3. æ•°æ®åº“è¿ç§»è„šæœ¬

```bash
#!/bin/bash
# db-migrate.sh - æ•°æ®åº“è¿ç§»è„šæœ¬

set -e

# é…ç½®å˜é‡
DATABASE_URL=${1:-"postgresql://postgres:password@localhost:5432/ecommerce"}
MIGRATION_DIR=${2:-"./migrations"}
ENVIRONMENT=${3:-"development"}

echo "ğŸ—„ï¸ å¼€å§‹æ•°æ®åº“è¿ç§» (ç¯å¢ƒ: $ENVIRONMENT)"

# æ£€æŸ¥æ•°æ®åº“è¿æ¥
check_database_connection() {
    echo "ğŸ” æ£€æŸ¥æ•°æ®åº“è¿æ¥..."
    
    if psql "$DATABASE_URL" -c "SELECT 1;" > /dev/null 2>&1; then
        echo "âœ… æ•°æ®åº“è¿æ¥æˆåŠŸ"
    else
        echo "âŒ æ•°æ®åº“è¿æ¥å¤±è´¥"
        exit 1
    fi
}

# å¤‡ä»½æ•°æ®åº“
backup_database() {
    if [ "$ENVIRONMENT" = "production" ]; then
        echo "ğŸ’¾ å¤‡ä»½ç”Ÿäº§æ•°æ®åº“..."
        local backup_file="backup_$(date +%Y%m%d_%H%M%S).sql"
        pg_dump "$DATABASE_URL" > "$backup_file"
        echo "âœ… æ•°æ®åº“å¤‡ä»½å®Œæˆ: $backup_file"
    fi
}

# è¿è¡Œè¿ç§»
run_migrations() {
    echo "ğŸ”„ è¿è¡Œæ•°æ®åº“è¿ç§»..."
    
    # ä½¿ç”¨sqlx-cliè¿è¡Œè¿ç§»
    sqlx migrate run --database-url "$DATABASE_URL"
    
    if [ $? -eq 0 ]; then
        echo "âœ… æ•°æ®åº“è¿ç§»å®Œæˆ"
    else
        echo "âŒ æ•°æ®åº“è¿ç§»å¤±è´¥"
        exit 1
    fi
}

# éªŒè¯è¿ç§»
verify_migrations() {
    echo "âœ… éªŒè¯è¿ç§»ç»“æœ..."
    
    # æ£€æŸ¥è¿ç§»è¡¨
    local migration_count=$(psql "$DATABASE_URL" -t -c "SELECT COUNT(*) FROM _sqlx_migrations;")
    echo "ğŸ“Š å·²åº”ç”¨è¿ç§»æ•°é‡: $migration_count"
    
    # æ£€æŸ¥è¡¨ç»“æ„
    local table_count=$(psql "$DATABASE_URL" -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';")
    echo "ğŸ“Š æ•°æ®åº“è¡¨æ•°é‡: $table_count"
}

# å›æ»šè¿ç§»ï¼ˆå¦‚æœéœ€è¦ï¼‰
rollback_migrations() {
    local target_version=$1
    
    if [ -n "$target_version" ]; then
        echo "âª å›æ»šåˆ°ç‰ˆæœ¬ $target_version..."
        sqlx migrate revert --database-url "$DATABASE_URL"
    fi
}

# ä¸»è¿ç§»æµç¨‹
main() {
    # æ£€æŸ¥æ•°æ®åº“è¿æ¥
    check_database_connection
    
    # å¤‡ä»½æ•°æ®åº“
    backup_database
    
    # è¿è¡Œè¿ç§»
    run_migrations
    
    # éªŒè¯è¿ç§»
    verify_migrations
    
    echo "ğŸ‰ æ•°æ®åº“è¿ç§»å®Œæˆï¼"
}

# æ‰§è¡Œä¸»æµç¨‹
main
```

### 4. ç›‘æ§éƒ¨ç½²è„šæœ¬

```bash
#!/bin/bash
# monitoring-deploy.sh - ç›‘æ§ç³»ç»Ÿéƒ¨ç½²è„šæœ¬

set -e

# é…ç½®å˜é‡
NAMESPACE=${1:-"monitoring"}
ENVIRONMENT=${2:-"development"}

echo "ğŸ“Š å¼€å§‹éƒ¨ç½²ç›‘æ§ç³»ç»Ÿ (å‘½åç©ºé—´: $NAMESPACE, ç¯å¢ƒ: $ENVIRONMENT)"

# éƒ¨ç½²Prometheus
deploy_prometheus() {
    echo "ğŸ“ˆ éƒ¨ç½²Prometheus..."
    
    # åˆ›å»ºPrometheusé…ç½®
    kubectl apply -f monitoring/prometheus/ -n $NAMESPACE
    
    # ç­‰å¾…Prometheuså¯åŠ¨
    kubectl rollout status deployment/prometheus -n $NAMESPACE --timeout=300s
    
    echo "âœ… Prometheuséƒ¨ç½²å®Œæˆ"
}

# éƒ¨ç½²Grafana
deploy_grafana() {
    echo "ğŸ“Š éƒ¨ç½²Grafana..."
    
    # åˆ›å»ºGrafanaé…ç½®
    kubectl apply -f monitoring/grafana/ -n $NAMESPACE
    
    # ç­‰å¾…Grafanaå¯åŠ¨
    kubectl rollout status deployment/grafana -n $NAMESPACE --timeout=300s
    
    echo "âœ… Grafanaéƒ¨ç½²å®Œæˆ"
}

# éƒ¨ç½²Jaeger
deploy_jaeger() {
    echo "ğŸ” éƒ¨ç½²Jaeger..."
    
    # åˆ›å»ºJaegeré…ç½®
    kubectl apply -f monitoring/jaeger/ -n $NAMESPACE
    
    # ç­‰å¾…Jaegerå¯åŠ¨
    kubectl rollout status deployment/jaeger -n $NAMESPACE --timeout=300s
    
    echo "âœ… Jaegeréƒ¨ç½²å®Œæˆ"
}

# éƒ¨ç½²AlertManager
deploy_alertmanager() {
    echo "ğŸš¨ éƒ¨ç½²AlertManager..."
    
    # åˆ›å»ºAlertManageré…ç½®
    kubectl apply -f monitoring/alertmanager/ -n $NAMESPACE
    
    # ç­‰å¾…AlertManagerå¯åŠ¨
    kubectl rollout status deployment/alertmanager -n $NAMESPACE --timeout=300s
    
    echo "âœ… AlertManageréƒ¨ç½²å®Œæˆ"
}

# é…ç½®æœåŠ¡å‘ç°
configure_service_discovery() {
    echo "ğŸ” é…ç½®æœåŠ¡å‘ç°..."
    
    # åˆ›å»ºServiceMonitorèµ„æº
    kubectl apply -f monitoring/servicemonitor/ -n $NAMESPACE
    
    echo "âœ… æœåŠ¡å‘ç°é…ç½®å®Œæˆ"
}

# ä¸»éƒ¨ç½²æµç¨‹
main() {
    # åˆ›å»ºç›‘æ§å‘½åç©ºé—´
    kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
    
    # éƒ¨ç½²ç›‘æ§ç»„ä»¶
    deploy_prometheus
    deploy_grafana
    deploy_jaeger
    deploy_alertmanager
    
    # é…ç½®æœåŠ¡å‘ç°
    configure_service_discovery
    
    echo "ğŸ‰ ç›‘æ§ç³»ç»Ÿéƒ¨ç½²å®Œæˆï¼"
    echo "ğŸ“Š Prometheus: kubectl port-forward -n $NAMESPACE svc/prometheus 9090:9090"
    echo "ğŸ“ˆ Grafana: kubectl port-forward -n $NAMESPACE svc/grafana 3000:3000"
    echo "ğŸ” Jaeger: kubectl port-forward -n $NAMESPACE svc/jaeger 16686:16686"
}

# æ‰§è¡Œä¸»æµç¨‹
main
```

## ä½¿ç”¨ç¤ºä¾‹

### 1. è¿è¡Œæµ‹è¯•

```bash
# è¿è¡Œå•å…ƒæµ‹è¯•
cargo test

# è¿è¡Œé›†æˆæµ‹è¯•
cargo test --test integration_tests

# è¿è¡Œæ€§èƒ½æµ‹è¯•
cargo test --test performance_tests --release

# è¿è¡ŒAPIæµ‹è¯•
cargo test --test api_tests
```

### 2. éƒ¨ç½²æœåŠ¡

```bash
# Dockeréƒ¨ç½²
./scripts/docker-deploy.sh latest development

# Kuberneteséƒ¨ç½²
./scripts/k8s-deploy.sh ecommerce production v1.2.3

# æ•°æ®åº“è¿ç§»
./scripts/db-migrate.sh postgresql://user:pass@localhost:5432/db

# ç›‘æ§éƒ¨ç½²
./scripts/monitoring-deploy.sh monitoring production
```

### 3. è‡ªåŠ¨åŒ–CI/CD

```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [main]
    tags: ['v*']

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run tests
        run: |
          cargo test
          cargo test --test integration_tests
          cargo test --test performance_tests --release

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    steps:
      - uses: actions/checkout@v3
      - name: Deploy to production
        run: |
          ./scripts/k8s-deploy.sh ecommerce production ${{ github.ref_name }}
          ./scripts/monitoring-deploy.sh monitoring production
```

## æœ€ä½³å®è·µ

### 1. æµ‹è¯•ç­–ç•¥

- **å•å…ƒæµ‹è¯•**: æµ‹è¯•å•ä¸ªå‡½æ•°å’Œæ¨¡å—
- **é›†æˆæµ‹è¯•**: æµ‹è¯•æœåŠ¡é—´çš„äº¤äº’
- **APIæµ‹è¯•**: æµ‹è¯•HTTPæ¥å£
- **æ€§èƒ½æµ‹è¯•**: æµ‹è¯•ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡
- **ç«¯åˆ°ç«¯æµ‹è¯•**: æµ‹è¯•å®Œæ•´ä¸šåŠ¡æµç¨‹

### 2. éƒ¨ç½²ç­–ç•¥

- **è“ç»¿éƒ¨ç½²**: é›¶åœæœºéƒ¨ç½²
- **é‡‘ä¸é›€éƒ¨ç½²**: æ¸è¿›å¼å‘å¸ƒ
- **æ»šåŠ¨æ›´æ–°**: é€æ­¥æ›¿æ¢å®ä¾‹
- **è‡ªåŠ¨å›æ»š**: å¤±è´¥æ—¶è‡ªåŠ¨å›æ»š

### 3. ç›‘æ§ç­–ç•¥

- **æŒ‡æ ‡æ”¶é›†**: æ”¶é›†å…³é”®ä¸šåŠ¡å’ŒæŠ€æœ¯æŒ‡æ ‡
- **æ—¥å¿—èšåˆ**: é›†ä¸­åŒ–æ—¥å¿—æ”¶é›†å’Œåˆ†æ
- **åˆ†å¸ƒå¼è¿½è¸ª**: è·¨æœåŠ¡è¯·æ±‚è¿½è¸ª
- **å‘Šè­¦æœºåˆ¶**: æ™ºèƒ½å‘Šè­¦å’Œé€šçŸ¥

### 4. å®‰å…¨è€ƒè™‘

- **é•œåƒæ‰«æ**: æ‰«æå®¹å™¨é•œåƒæ¼æ´
- **å¯†é’¥ç®¡ç†**: å®‰å…¨å­˜å‚¨å’Œç®¡ç†å¯†é’¥
- **ç½‘ç»œç­–ç•¥**: é™åˆ¶æœåŠ¡é—´ç½‘ç»œè®¿é—®
- **RBAC**: åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-01-XX  
**ç»´æŠ¤è€…**: å·¥å…·å›¢é˜Ÿ
