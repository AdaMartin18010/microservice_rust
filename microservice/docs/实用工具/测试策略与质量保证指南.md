# 测试策略与质量保证指南

> 基于Rust 1.90和最新依赖版本的微服务测试完整解决方案

## 📋 概述

本文档提供了完整的微服务测试策略指南，包括单元测试、集成测试、端到端测试、性能测试、混沌工程等全方位测试解决方案。

## 🎯 测试目标

### 1. 测试金字塔

```mermaid
graph TB
    A[端到端测试 E2E] --> B[集成测试 Integration]
    B --> C[单元测试 Unit]
    
    A --> A1[用户场景测试]
    A --> A2[业务流程测试]
    A --> A3[系统兼容性测试]
    
    B --> B1[API集成测试]
    B --> B2[数据库集成测试]
    B --> B3[外部服务集成测试]
    
    C --> C1[函数测试]
    C --> C2[模块测试]
    C --> C3[组件测试]
```

### 2. 测试覆盖率目标

| 测试类型 | 覆盖率目标 | 重要性 |
|----------|------------|--------|
| 单元测试 | > 90% | 高 |
| 集成测试 | > 80% | 高 |
| 端到端测试 | > 70% | 中 |
| 性能测试 | 关键路径100% | 高 |
| 安全测试 | 安全相关100% | 高 |

## 🧪 单元测试

### 1. 基础单元测试

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tokio_test;
    use mockall::mock;
    use std::sync::Arc;

    // 用户服务测试
    #[tokio::test]
    async fn test_user_service_create_user() {
        // 准备测试数据
        let user_data = CreateUser {
            username: "testuser".to_string(),
            email: "test@example.com".to_string(),
            password: "password123".to_string(),
        };

        // 创建模拟数据库
        let mut mock_db = MockDatabase::new();
        mock_db
            .expect_create_user()
            .with(eq(user_data.clone()))
            .times(1)
            .returning(|_| Ok(User {
                id: 1,
                username: "testuser".to_string(),
                email: "test@example.com".to_string(),
                created_at: SystemTime::now(),
            }));

        // 创建用户服务
        let user_service = UserServiceImpl::new(Arc::new(mock_db));

        // 执行测试
        let result = user_service.create_user(user_data).await;

        // 验证结果
        assert!(result.is_ok());
        let user = result.unwrap();
        assert_eq!(user.username, "testuser");
        assert_eq!(user.email, "test@example.com");
    }

    #[tokio::test]
    async fn test_user_service_get_user_not_found() {
        // 准备测试数据
        let user_id = 999;

        // 创建模拟数据库
        let mut mock_db = MockDatabase::new();
        mock_db
            .expect_get_user()
            .with(eq(user_id))
            .times(1)
            .returning(|_| Err(DatabaseError::NotFound));

        // 创建用户服务
        let user_service = UserServiceImpl::new(Arc::new(mock_db));

        // 执行测试
        let result = user_service.get_user(user_id).await;

        // 验证结果
        assert!(result.is_err());
        match result.unwrap_err() {
            ServiceError::NotFound => {}
            _ => panic!("Expected NotFound error"),
        }
    }

    // 参数化测试
    #[test]
    fn test_password_validation() {
        let test_cases = vec![
            ("password123", true),
            ("short", false),
            ("nouppercase123", false),
            ("NOLOWERCASE123", false),
            ("NoNumbers", false),
            ("ValidPass123!", true),
        ];

        for (password, expected) in test_cases {
            let result = validate_password(password);
            assert_eq!(result.is_ok(), expected, "Password: {}", password);
        }
    }

    // 属性测试
    #[test]
    fn test_user_id_generation() {
        use proptest::prelude::*;

        proptest!(|(username: String, email: String)| {
            // 假设用户名和邮箱不为空
            prop_assume!(!username.is_empty());
            prop_assume!(!email.is_empty());
            prop_assume!(email.contains('@'));

            let user_data = CreateUser {
                username: username.clone(),
                email: email.clone(),
                password: "password123".to_string(),
            };

            let user_id = generate_user_id(&user_data);
            
            // 验证用户ID的唯一性
            prop_assert!(!user_id.is_empty());
            prop_assert!(user_id.len() > 10);
        });
    }
}

// Mock对象定义
mock! {
    Database {}

    #[async_trait]
    impl Database for Database {
        async fn create_user(&self, user_data: CreateUser) -> Result<User, DatabaseError>;
        async fn get_user(&self, id: u64) -> Result<User, DatabaseError>;
        async fn update_user(&self, id: u64, user_data: UpdateUser) -> Result<User, DatabaseError>;
        async fn delete_user(&self, id: u64) -> Result<(), DatabaseError>;
    }
}
```

### 2. 异步测试

```rust
#[cfg(test)]
mod async_tests {
    use super::*;
    use tokio::time::{sleep, Duration, timeout};
    use tokio_test::task;

    #[tokio::test]
    async fn test_concurrent_user_creation() {
        let user_service = create_test_user_service();
        let user_data = CreateUser {
            username: "concurrent_user".to_string(),
            email: "concurrent@example.com".to_string(),
            password: "password123".to_string(),
        };

        // 并发创建用户
        let handles: Vec<_> = (0..10)
            .map(|i| {
                let service = user_service.clone();
                let data = user_data.clone();
                tokio::spawn(async move {
                    service.create_user(data).await
                })
            })
            .collect();

        // 等待所有任务完成
        let results = futures::future::join_all(handles).await;

        // 验证结果
        let mut success_count = 0;
        for result in results {
            if let Ok(Ok(_)) = result {
                success_count += 1;
            }
        }

        // 由于并发创建相同用户，只有一个应该成功
        assert_eq!(success_count, 1);
    }

    #[tokio::test]
    async fn test_timeout_handling() {
        let user_service = create_slow_user_service();
        let user_data = CreateUser {
            username: "timeout_user".to_string(),
            email: "timeout@example.com".to_string(),
            password: "password123".to_string(),
        };

        // 测试超时处理
        let result = timeout(
            Duration::from_millis(100),
            user_service.create_user(user_data)
        ).await;

        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_retry_mechanism() {
        let user_service = create_flaky_user_service();
        let user_data = CreateUser {
            username: "retry_user".to_string(),
            email: "retry@example.com".to_string(),
            password: "password123".to_string(),
        };

        // 测试重试机制
        let result = user_service.create_user_with_retry(user_data, 3).await;
        assert!(result.is_ok());
    }
}
```

## 🔗 集成测试

### 1. API集成测试

```rust
#[cfg(test)]
mod integration_tests {
    use super::*;
    use axum::{
        body::Body,
        http::{Request, StatusCode},
        Router,
    };
    use tower::ServiceExt;
    use serde_json::json;

    // 测试服务器设置
    async fn create_test_server() -> Router {
        let db = create_test_database().await;
        let user_service = UserServiceImpl::new(db);
        let app_state = AppState {
            user_service: Arc::new(user_service),
        };
        
        create_router(app_state)
    }

    #[tokio::test]
    async fn test_create_user_endpoint() {
        let app = create_test_server().await;
        
        let user_data = json!({
            "username": "integration_user",
            "email": "integration@example.com",
            "password": "password123"
        });

        let request = Request::builder()
            .method("POST")
            .uri("/users")
            .header("content-type", "application/json")
            .body(Body::from(user_data.to_string()))
            .unwrap();

        let response = app.oneshot(request).await.unwrap();
        assert_eq!(response.status(), StatusCode::CREATED);

        let body = hyper::body::to_bytes(response.into_body()).await.unwrap();
        let user: User = serde_json::from_slice(&body).unwrap();
        assert_eq!(user.username, "integration_user");
    }

    #[tokio::test]
    async fn test_get_user_endpoint() {
        let app = create_test_server().await;
        
        // 先创建用户
        let user_data = json!({
            "username": "get_user",
            "email": "get@example.com",
            "password": "password123"
        });

        let create_request = Request::builder()
            .method("POST")
            .uri("/users")
            .header("content-type", "application/json")
            .body(Body::from(user_data.to_string()))
            .unwrap();

        let create_response = app.clone().oneshot(create_request).await.unwrap();
        let create_body = hyper::body::to_bytes(create_response.into_body()).await.unwrap();
        let created_user: User = serde_json::from_slice(&create_body).unwrap();

        // 获取用户
        let get_request = Request::builder()
            .method("GET")
            .uri(&format!("/users/{}", created_user.id))
            .body(Body::empty())
            .unwrap();

        let get_response = app.oneshot(get_request).await.unwrap();
        assert_eq!(get_response.status(), StatusCode::OK);

        let get_body = hyper::body::to_bytes(get_response.into_body()).await.unwrap();
        let user: User = serde_json::from_slice(&get_body).unwrap();
        assert_eq!(user.id, created_user.id);
        assert_eq!(user.username, "get_user");
    }

    #[tokio::test]
    async fn test_authentication_flow() {
        let app = create_test_server().await;
        
        // 创建用户
        let user_data = json!({
            "username": "auth_user",
            "email": "auth@example.com",
            "password": "password123"
        });

        let create_request = Request::builder()
            .method("POST")
            .uri("/users")
            .header("content-type", "application/json")
            .body(Body::from(user_data.to_string()))
            .unwrap();

        app.clone().oneshot(create_request).await.unwrap();

        // 登录
        let login_data = json!({
            "username": "auth_user",
            "password": "password123"
        });

        let login_request = Request::builder()
            .method("POST")
            .uri("/auth/login")
            .header("content-type", "application/json")
            .body(Body::from(login_data.to_string()))
            .unwrap();

        let login_response = app.clone().oneshot(login_request).await.unwrap();
        assert_eq!(login_response.status(), StatusCode::OK);

        let login_body = hyper::body::to_bytes(login_response.into_body()).await.unwrap();
        let login_result: LoginResponse = serde_json::from_slice(&login_body).unwrap();
        
        // 使用token访问受保护的端点
        let protected_request = Request::builder()
            .method("GET")
            .uri("/users/profile")
            .header("authorization", format!("Bearer {}", login_result.token))
            .body(Body::empty())
            .unwrap();

        let protected_response = app.oneshot(protected_request).await.unwrap();
        assert_eq!(protected_response.status(), StatusCode::OK);
    }
}
```

### 2. 数据库集成测试

```rust
#[cfg(test)]
mod database_tests {
    use super::*;
    use sqlx::PgPool;
    use testcontainers::{clients, Container, images::Postgres};

    // 使用testcontainers进行数据库测试
    #[tokio::test]
    async fn test_database_operations() {
        let docker = clients::Cli::default();
        let postgres_image = Postgres::default();
        let container = docker.run(postgres_image);
        
        let connection_string = format!(
            "postgres://postgres:postgres@localhost:{}/postgres",
            container.get_host_port_ipv4(5432)
        );

        let pool = PgPool::connect(&connection_string).await.unwrap();
        
        // 运行迁移
        sqlx::migrate!("./migrations").run(&pool).await.unwrap();

        // 测试数据库操作
        let user_repository = UserRepository::new(pool);
        
        // 创建用户
        let user_data = CreateUser {
            username: "db_test_user".to_string(),
            email: "db_test@example.com".to_string(),
            password: "password123".to_string(),
        };

        let user = user_repository.create_user(user_data).await.unwrap();
        assert_eq!(user.username, "db_test_user");

        // 获取用户
        let retrieved_user = user_repository.get_user(user.id).await.unwrap();
        assert_eq!(retrieved_user.id, user.id);

        // 更新用户
        let update_data = UpdateUser {
            email: Some("updated@example.com".to_string()),
            ..Default::default()
        };

        let updated_user = user_repository.update_user(user.id, update_data).await.unwrap();
        assert_eq!(updated_user.email, "updated@example.com");

        // 删除用户
        user_repository.delete_user(user.id).await.unwrap();
        
        // 验证用户已删除
        let result = user_repository.get_user(user.id).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_database_transactions() {
        let docker = clients::Cli::default();
        let postgres_image = Postgres::default();
        let container = docker.run(postgres_image);
        
        let connection_string = format!(
            "postgres://postgres:postgres@localhost:{}/postgres",
            container.get_host_port_ipv4(5432)
        );

        let pool = PgPool::connect(&connection_string).await.unwrap();
        sqlx::migrate!("./migrations").run(&pool).await.unwrap();

        let user_repository = UserRepository::new(pool);

        // 测试事务回滚
        let result = user_repository.create_user_with_transaction(
            CreateUser {
                username: "transaction_user".to_string(),
                email: "transaction@example.com".to_string(),
                password: "password123".to_string(),
            },
            true, // 强制失败
        ).await;

        assert!(result.is_err());

        // 验证用户未创建
        let users = user_repository.get_users_by_username("transaction_user").await.unwrap();
        assert!(users.is_empty());
    }
}
```

## 🌐 端到端测试

### 1. 用户场景测试

```rust
#[cfg(test)]
mod e2e_tests {
    use super::*;
    use reqwest::Client;
    use serde_json::json;
    use std::time::Duration;

    // 测试环境设置
    struct TestEnvironment {
        client: Client,
        base_url: String,
        auth_token: Option<String>,
    }

    impl TestEnvironment {
        async fn new() -> Self {
            let client = Client::new();
            let base_url = std::env::var("TEST_BASE_URL")
                .unwrap_or_else(|_| "http://localhost:8080".to_string());

            Self {
                client,
                base_url,
                auth_token: None,
            }
        }

        async fn create_user(&self, username: &str, email: &str) -> User {
            let user_data = json!({
                "username": username,
                "email": email,
                "password": "password123"
            });

            let response = self.client
                .post(&format!("{}/users", self.base_url))
                .json(&user_data)
                .send()
                .await
                .unwrap();

            assert_eq!(response.status(), 201);
            response.json().await.unwrap()
        }

        async fn login(&mut self, username: &str, password: &str) -> String {
            let login_data = json!({
                "username": username,
                "password": password
            });

            let response = self.client
                .post(&format!("{}/auth/login", self.base_url))
                .json(&login_data)
                .send()
                .await
                .unwrap();

            assert_eq!(response.status(), 200);
            let login_result: LoginResponse = response.json().await.unwrap();
            self.auth_token = Some(login_result.token.clone());
            login_result.token
        }

        async fn create_order(&self, user_id: u64, items: Vec<OrderItem>) -> Order {
            let order_data = json!({
                "user_id": user_id,
                "items": items
            });

            let mut request = self.client
                .post(&format!("{}/orders", self.base_url))
                .json(&order_data);

            if let Some(token) = &self.auth_token {
                request = request.bearer_auth(token);
            }

            let response = request.send().await.unwrap();
            assert_eq!(response.status(), 201);
            response.json().await.unwrap()
        }
    }

    #[tokio::test]
    async fn test_complete_user_journey() {
        let mut env = TestEnvironment::new().await;

        // 1. 用户注册
        let user = env.create_user("e2e_user", "e2e@example.com").await;
        assert_eq!(user.username, "e2e_user");

        // 2. 用户登录
        let token = env.login("e2e_user", "password123").await;
        assert!(!token.is_empty());

        // 3. 创建订单
        let items = vec![
            OrderItem {
                product_id: 1,
                quantity: 2,
                price: 10.99,
            },
            OrderItem {
                product_id: 2,
                quantity: 1,
                price: 5.99,
            },
        ];

        let order = env.create_order(user.id, items).await;
        assert_eq!(order.user_id, user.id);
        assert_eq!(order.items.len(), 2);

        // 4. 查看订单
        let response = env.client
            .get(&format!("{}/orders/{}", env.base_url, order.id))
            .bearer_auth(&token)
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), 200);
        let retrieved_order: Order = response.json().await.unwrap();
        assert_eq!(retrieved_order.id, order.id);

        // 5. 更新订单状态
        let update_data = json!({
            "status": "shipped"
        });

        let response = env.client
            .patch(&format!("{}/orders/{}", env.base_url, order.id))
            .bearer_auth(&token)
            .json(&update_data)
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), 200);
        let updated_order: Order = response.json().await.unwrap();
        assert_eq!(updated_order.status, "shipped");
    }

    #[tokio::test]
    async fn test_error_handling_flow() {
        let env = TestEnvironment::new().await;

        // 1. 尝试创建重复用户
        env.create_user("duplicate_user", "duplicate@example.com").await;
        
        let user_data = json!({
            "username": "duplicate_user",
            "email": "duplicate2@example.com",
            "password": "password123"
        });

        let response = env.client
            .post(&format!("{}/users", env.base_url))
            .json(&user_data)
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), 409); // Conflict

        // 2. 尝试使用无效凭据登录
        let login_data = json!({
            "username": "nonexistent_user",
            "password": "wrong_password"
        });

        let response = env.client
            .post(&format!("{}/auth/login", env.base_url))
            .json(&login_data)
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), 401); // Unauthorized

        // 3. 尝试访问受保护的端点而不提供token
        let response = env.client
            .get(&format!("{}/users/profile", env.base_url))
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), 401); // Unauthorized
    }
}
```

### 2. 性能测试

```rust
#[cfg(test)]
mod performance_tests {
    use super::*;
    use std::time::Instant;
    use tokio::time::sleep;

    #[tokio::test]
    async fn test_concurrent_user_creation_performance() {
        let env = TestEnvironment::new().await;
        let start_time = Instant::now();
        
        // 并发创建100个用户
        let handles: Vec<_> = (0..100)
            .map(|i| {
                let env = env.clone();
                tokio::spawn(async move {
                    env.create_user(&format!("perf_user_{}", i), &format!("perf{}@example.com", i)).await
                })
            })
            .collect();

        let results = futures::future::join_all(handles).await;
        let duration = start_time.elapsed();

        // 验证所有用户都创建成功
        let mut success_count = 0;
        for result in results {
            if let Ok(Ok(_)) = result {
                success_count += 1;
            }
        }

        assert_eq!(success_count, 100);
        assert!(duration.as_secs() < 10); // 应该在10秒内完成

        println!("Created 100 users in {:?}", duration);
    }

    #[tokio::test]
    async fn test_api_response_time() {
        let env = TestEnvironment::new().await;
        let user = env.create_user("response_time_user", "response@example.com").await;

        // 测试API响应时间
        let start_time = Instant::now();
        let response = env.client
            .get(&format!("{}/users/{}", env.base_url, user.id))
            .send()
            .await
            .unwrap();
        let duration = start_time.elapsed();

        assert_eq!(response.status(), 200);
        assert!(duration.as_millis() < 100); // 响应时间应该小于100ms

        println!("API response time: {:?}", duration);
    }

    #[tokio::test]
    async fn test_memory_usage_under_load() {
        let env = TestEnvironment::new().await;
        
        // 创建大量用户并监控内存使用
        for i in 0..1000 {
            env.create_user(&format!("memory_user_{}", i), &format!("memory{}@example.com", i)).await;
            
            if i % 100 == 0 {
                // 每100个用户检查一次内存使用
                let memory_usage = get_memory_usage();
                assert!(memory_usage < 512 * 1024 * 1024); // 内存使用应该小于512MB
                println!("Memory usage after {} users: {} MB", i, memory_usage / 1024 / 1024);
            }
        }
    }

    fn get_memory_usage() -> usize {
        // 获取当前进程的内存使用量
        // 这里使用简化的实现
        0
    }
}
```

## 🎭 混沌工程

### 1. 故障注入测试

```rust
#[cfg(test)]
mod chaos_tests {
    use super::*;
    use std::time::Duration;
    use tokio::time::timeout;

    // 故障注入器
    struct FaultInjector {
        failure_rate: f64,
        latency_ms: u64,
    }

    impl FaultInjector {
        fn new(failure_rate: f64, latency_ms: u64) -> Self {
            Self {
                failure_rate,
                latency_ms,
            }
        }

        async fn inject_fault<T>(&self, operation: impl Future<Output = Result<T, Box<dyn std::error::Error>>>) -> Result<T, Box<dyn std::error::Error>> {
            // 注入延迟
            if self.latency_ms > 0 {
                sleep(Duration::from_millis(self.latency_ms)).await;
            }

            // 注入故障
            if rand::random::<f64>() < self.failure_rate {
                return Err("Injected fault".into());
            }

            operation.await
        }
    }

    #[tokio::test]
    async fn test_database_failure_recovery() {
        let fault_injector = FaultInjector::new(0.3, 100); // 30%故障率，100ms延迟
        let user_service = create_test_user_service();

        let mut success_count = 0;
        let mut failure_count = 0;

        // 执行100次操作
        for i in 0..100 {
            let user_data = CreateUser {
                username: format!("chaos_user_{}", i),
                email: format!("chaos{}@example.com", i),
                password: "password123".to_string(),
            };

            let result = fault_injector.inject_fault(
                user_service.create_user(user_data)
            ).await;

            match result {
                Ok(_) => success_count += 1,
                Err(_) => failure_count += 1,
            }
        }

        // 验证系统在故障情况下的行为
        assert!(success_count > 0);
        assert!(failure_count > 0);
        println!("Success: {}, Failures: {}", success_count, failure_count);
    }

    #[tokio::test]
    async fn test_network_partition_simulation() {
        let user_service = create_test_user_service();
        
        // 模拟网络分区
        let partition_duration = Duration::from_secs(5);
        
        // 在分区期间尝试操作
        let result = timeout(
            partition_duration,
            user_service.create_user(CreateUser {
                username: "partition_user".to_string(),
                email: "partition@example.com".to_string(),
                password: "password123".to_string(),
            })
        ).await;

        // 验证超时处理
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_cascade_failure_prevention() {
        let user_service = create_test_user_service();
        
        // 模拟级联故障
        let mut handles = Vec::new();
        
        for i in 0..50 {
            let service = user_service.clone();
            let handle = tokio::spawn(async move {
                let user_data = CreateUser {
                    username: format!("cascade_user_{}", i),
                    email: format!("cascade{}@example.com", i),
                    password: "password123".to_string(),
                };
                
                service.create_user(user_data).await
            });
            handles.push(handle);
        }

        // 等待所有操作完成
        let results = futures::future::join_all(handles).await;
        
        // 验证系统没有完全崩溃
        let success_count = results.iter()
            .filter(|r| r.is_ok() && r.as_ref().unwrap().is_ok())
            .count();
        
        assert!(success_count > 0);
        println!("Cascade failure test - Success count: {}", success_count);
    }
}
```

### 2. 负载测试

```rust
#[cfg(test)]
mod load_tests {
    use super::*;
    use std::sync::atomic::{AtomicUsize, Ordering};
    use std::sync::Arc;

    #[tokio::test]
    async fn test_sustained_load() {
        let env = TestEnvironment::new().await;
        let request_count = Arc::new(AtomicUsize::new(0));
        let error_count = Arc::new(AtomicUsize::new(0));
        
        // 创建用户
        let user = env.create_user("load_test_user", "load@example.com").await;
        let token = env.login("load_test_user", "password123").await;

        // 持续负载测试
        let duration = Duration::from_secs(30);
        let start_time = Instant::now();
        
        while start_time.elapsed() < duration {
            let request_count = request_count.clone();
            let error_count = error_count.clone();
            let env = env.clone();
            let token = token.clone();
            
            tokio::spawn(async move {
                let response = env.client
                    .get(&format!("{}/users/{}", env.base_url, user.id))
                    .bearer_auth(&token)
                    .send()
                    .await;

                request_count.fetch_add(1, Ordering::Relaxed);
                
                if let Err(_) = response {
                    error_count.fetch_add(1, Ordering::Relaxed);
                }
            });

            // 控制请求速率
            sleep(Duration::from_millis(10)).await;
        }

        // 等待所有请求完成
        sleep(Duration::from_secs(5)).await;

        let total_requests = request_count.load(Ordering::Relaxed);
        let total_errors = error_count.load(Ordering::Relaxed);
        let error_rate = total_errors as f64 / total_requests as f64;

        println!("Load test results:");
        println!("Total requests: {}", total_requests);
        println!("Total errors: {}", total_errors);
        println!("Error rate: {:.2}%", error_rate * 100.0);

        // 验证错误率在可接受范围内
        assert!(error_rate < 0.01); // 错误率应该小于1%
    }

    #[tokio::test]
    async fn test_peak_load_handling() {
        let env = TestEnvironment::new().await;
        
        // 峰值负载测试
        let peak_duration = Duration::from_secs(10);
        let start_time = Instant::now();
        
        while start_time.elapsed() < peak_duration {
            let env = env.clone();
            
            // 并发发送大量请求
            for _ in 0..100 {
                tokio::spawn(async move {
                    let _ = env.client
                        .get(&format!("{}/health", env.base_url))
                        .send()
                        .await;
                });
            }
            
            sleep(Duration::from_millis(100)).await;
        }

        // 验证系统在峰值负载下的稳定性
        let response = env.client
            .get(&format!("{}/health", env.base_url))
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), 200);
    }
}
```

## 📊 测试报告与指标

### 1. 测试覆盖率报告

```rust
// 测试覆盖率配置
#[cfg(test)]
mod coverage_tests {
    use super::*;
    use tarpaulin::{Config, RunType};

    #[test]
    fn test_coverage_configuration() {
        let config = Config::default()
            .set_include("src/")
            .set_exclude("src/bin/")
            .set_exclude("src/tests/")
            .set_exclude("src/examples/")
            .set_include_ignored(true)
            .set_include_tests(true)
            .set_verbose(true);

        // 运行覆盖率测试
        let result = tarpaulin::run_tests(&config);
        assert!(result.is_ok());
    }
}
```

### 2. 性能基准测试

```rust
#[cfg(test)]
mod benchmark_tests {
    use super::*;
    use criterion::{black_box, criterion_group, criterion_main, Criterion};

    fn benchmark_user_creation(c: &mut Criterion) {
        let rt = tokio::runtime::Runtime::new().unwrap();
        let user_service = rt.block_on(create_test_user_service());

        c.bench_function("user_creation", |b| {
            b.to_async(&rt).iter(|| async {
                let user_data = CreateUser {
                    username: "benchmark_user".to_string(),
                    email: "benchmark@example.com".to_string(),
                    password: "password123".to_string(),
                };
                
                black_box(user_service.create_user(user_data).await)
            })
        });
    }

    fn benchmark_user_retrieval(c: &mut Criterion) {
        let rt = tokio::runtime::Runtime::new().unwrap();
        let user_service = rt.block_on(create_test_user_service());
        let user_id = rt.block_on(async {
            let user_data = CreateUser {
                username: "benchmark_retrieval_user".to_string(),
                email: "benchmark_retrieval@example.com".to_string(),
                password: "password123".to_string(),
            };
            let user = user_service.create_user(user_data).await.unwrap();
            user.id
        });

        c.bench_function("user_retrieval", |b| {
            b.to_async(&rt).iter(|| async {
                black_box(user_service.get_user(user_id).await)
            })
        });
    }

    criterion_group!(benches, benchmark_user_creation, benchmark_user_retrieval);
    criterion_main!(benches);
}
```

## 🚀 持续集成测试

### 1. CI/CD测试流水线

```yaml
# .github/workflows/test.yml
name: Test Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: 1.90
        components: rustfmt, clippy
    
    - name: Run unit tests
      run: cargo test --lib
    
    - name: Run integration tests
      run: cargo test --test integration
    
    - name: Generate coverage report
      run: |
        cargo install cargo-tarpaulin
        cargo tarpaulin --out Html --output-dir coverage/
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: coverage/cobertura.xml

  e2e-tests:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: 1.90
    
    - name: Run database migrations
      run: |
        cargo install sqlx-cli
        sqlx migrate run
    
    - name: Run E2E tests
      run: cargo test --test e2e
      env:
        DATABASE_URL: postgres://postgres:postgres@localhost:5432/postgres

  performance-tests:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: 1.90
    
    - name: Run performance tests
      run: cargo test --test performance
    
    - name: Run benchmarks
      run: cargo bench
```

### 2. 测试质量门禁

```rust
// 测试质量检查
#[cfg(test)]
mod quality_gates {
    use super::*;

    #[test]
    fn test_minimum_coverage() {
        // 检查测试覆盖率是否达到最低要求
        let coverage = get_test_coverage();
        assert!(coverage >= 80.0, "Test coverage {}% is below minimum 80%", coverage);
    }

    #[test]
    fn test_performance_requirements() {
        // 检查性能是否满足要求
        let response_time = measure_api_response_time();
        assert!(response_time < 100, "API response time {}ms exceeds 100ms limit", response_time);
    }

    #[test]
    fn test_security_requirements() {
        // 检查安全测试是否通过
        let security_tests_passed = run_security_tests();
        assert!(security_tests_passed, "Security tests failed");
    }

    fn get_test_coverage() -> f64 {
        // 获取测试覆盖率
        85.0 // 模拟值
    }

    fn measure_api_response_time() -> u64 {
        // 测量API响应时间
        50 // 模拟值
    }

    fn run_security_tests() -> bool {
        // 运行安全测试
        true // 模拟值
    }
}
```

## 📚 最佳实践总结

### 1. 测试策略原则

- **测试金字塔**: 大量单元测试，适量集成测试，少量端到端测试
- **测试隔离**: 每个测试独立运行，不依赖其他测试
- **测试数据**: 使用测试专用的数据和环境
- **持续测试**: 在CI/CD流水线中自动运行测试

### 2. 测试质量指标

- **覆盖率**: 代码覆盖率 > 80%
- **性能**: API响应时间 < 100ms
- **可靠性**: 错误率 < 0.1%
- **安全性**: 安全测试100%通过

### 3. 测试工具链

- **单元测试**: `cargo test`, `tokio-test`
- **集成测试**: `testcontainers`, `reqwest`
- **性能测试**: `criterion`, `k6`
- **覆盖率**: `tarpaulin`, `cargo-llvm-cov`
- **混沌工程**: `chaos-monkey`, `litmus`

### 4. 测试环境管理

- **开发环境**: 本地Docker容器
- **测试环境**: 独立的测试数据库
- **预生产环境**: 与生产环境相似的配置
- **生产环境**: 监控和告警

## 🔗 相关资源

- [Rust测试文档](https://doc.rust-lang.org/book/ch11-00-testing.html)
- [Tokio测试指南](https://tokio.rs/tokio/tutorial)
- [测试最佳实践](https://testing.googleblog.com/)
- [混沌工程实践](https://principlesofchaos.org/)

---

**注意**: 本文档基于2025年9月的最新技术栈，建议定期更新以保持时效性。
