# æµ‹è¯•ç­–ç•¥ä¸è´¨é‡ä¿è¯æŒ‡å—

> åŸºäºRust 1.90å’Œæœ€æ–°ä¾èµ–ç‰ˆæœ¬çš„å¾®æœåŠ¡æµ‹è¯•å®Œæ•´è§£å†³æ–¹æ¡ˆ

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›äº†å®Œæ•´çš„å¾®æœåŠ¡æµ‹è¯•ç­–ç•¥æŒ‡å—ï¼ŒåŒ…æ‹¬å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€ç«¯åˆ°ç«¯æµ‹è¯•ã€æ€§èƒ½æµ‹è¯•ã€æ··æ²Œå·¥ç¨‹ç­‰å…¨æ–¹ä½æµ‹è¯•è§£å†³æ–¹æ¡ˆã€‚

## ğŸ¯ æµ‹è¯•ç›®æ ‡

### 1. æµ‹è¯•é‡‘å­—å¡”

```mermaid
graph TB
    A[ç«¯åˆ°ç«¯æµ‹è¯• E2E] --> B[é›†æˆæµ‹è¯• Integration]
    B --> C[å•å…ƒæµ‹è¯• Unit]
    
    A --> A1[ç”¨æˆ·åœºæ™¯æµ‹è¯•]
    A --> A2[ä¸šåŠ¡æµç¨‹æµ‹è¯•]
    A --> A3[ç³»ç»Ÿå…¼å®¹æ€§æµ‹è¯•]
    
    B --> B1[APIé›†æˆæµ‹è¯•]
    B --> B2[æ•°æ®åº“é›†æˆæµ‹è¯•]
    B --> B3[å¤–éƒ¨æœåŠ¡é›†æˆæµ‹è¯•]
    
    C --> C1[å‡½æ•°æµ‹è¯•]
    C --> C2[æ¨¡å—æµ‹è¯•]
    C --> C3[ç»„ä»¶æµ‹è¯•]
```

### 2. æµ‹è¯•è¦†ç›–ç‡ç›®æ ‡

| æµ‹è¯•ç±»å‹ | è¦†ç›–ç‡ç›®æ ‡ | é‡è¦æ€§ |
|----------|------------|--------|
| å•å…ƒæµ‹è¯• | > 90% | é«˜ |
| é›†æˆæµ‹è¯• | > 80% | é«˜ |
| ç«¯åˆ°ç«¯æµ‹è¯• | > 70% | ä¸­ |
| æ€§èƒ½æµ‹è¯• | å…³é”®è·¯å¾„100% | é«˜ |
| å®‰å…¨æµ‹è¯• | å®‰å…¨ç›¸å…³100% | é«˜ |

## ğŸ§ª å•å…ƒæµ‹è¯•

### 1. åŸºç¡€å•å…ƒæµ‹è¯•

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tokio_test;
    use mockall::mock;
    use std::sync::Arc;

    // ç”¨æˆ·æœåŠ¡æµ‹è¯•
    #[tokio::test]
    async fn test_user_service_create_user() {
        // å‡†å¤‡æµ‹è¯•æ•°æ®
        let user_data = CreateUser {
            username: "testuser".to_string(),
            email: "test@example.com".to_string(),
            password: "password123".to_string(),
        };

        // åˆ›å»ºæ¨¡æ‹Ÿæ•°æ®åº“
        let mut mock_db = MockDatabase::new();
        mock_db
            .expect_create_user()
            .with(eq(user_data.clone()))
            .times(1)
            .returning(|_| Ok(User {
                id: 1,
                username: "testuser".to_string(),
                email: "test@example.com".to_string(),
                created_at: SystemTime::now(),
            }));

        // åˆ›å»ºç”¨æˆ·æœåŠ¡
        let user_service = UserServiceImpl::new(Arc::new(mock_db));

        // æ‰§è¡Œæµ‹è¯•
        let result = user_service.create_user(user_data).await;

        // éªŒè¯ç»“æœ
        assert!(result.is_ok());
        let user = result.unwrap();
        assert_eq!(user.username, "testuser");
        assert_eq!(user.email, "test@example.com");
    }

    #[tokio::test]
    async fn test_user_service_get_user_not_found() {
        // å‡†å¤‡æµ‹è¯•æ•°æ®
        let user_id = 999;

        // åˆ›å»ºæ¨¡æ‹Ÿæ•°æ®åº“
        let mut mock_db = MockDatabase::new();
        mock_db
            .expect_get_user()
            .with(eq(user_id))
            .times(1)
            .returning(|_| Err(DatabaseError::NotFound));

        // åˆ›å»ºç”¨æˆ·æœåŠ¡
        let user_service = UserServiceImpl::new(Arc::new(mock_db));

        // æ‰§è¡Œæµ‹è¯•
        let result = user_service.get_user(user_id).await;

        // éªŒè¯ç»“æœ
        assert!(result.is_err());
        match result.unwrap_err() {
            ServiceError::NotFound => {}
            _ => panic!("Expected NotFound error"),
        }
    }

    // å‚æ•°åŒ–æµ‹è¯•
    #[test]
    fn test_password_validation() {
        let test_cases = vec![
            ("password123", true),
            ("short", false),
            ("nouppercase123", false),
            ("NOLOWERCASE123", false),
            ("NoNumbers", false),
            ("ValidPass123!", true),
        ];

        for (password, expected) in test_cases {
            let result = validate_password(password);
            assert_eq!(result.is_ok(), expected, "Password: {}", password);
        }
    }

    // å±æ€§æµ‹è¯•
    #[test]
    fn test_user_id_generation() {
        use proptest::prelude::*;

        proptest!(|(username: String, email: String)| {
            // å‡è®¾ç”¨æˆ·åå’Œé‚®ç®±ä¸ä¸ºç©º
            prop_assume!(!username.is_empty());
            prop_assume!(!email.is_empty());
            prop_assume!(email.contains('@'));

            let user_data = CreateUser {
                username: username.clone(),
                email: email.clone(),
                password: "password123".to_string(),
            };

            let user_id = generate_user_id(&user_data);
            
            // éªŒè¯ç”¨æˆ·IDçš„å”¯ä¸€æ€§
            prop_assert!(!user_id.is_empty());
            prop_assert!(user_id.len() > 10);
        });
    }
}

// Mockå¯¹è±¡å®šä¹‰
mock! {
    Database {}

    #[async_trait]
    impl Database for Database {
        async fn create_user(&self, user_data: CreateUser) -> Result<User, DatabaseError>;
        async fn get_user(&self, id: u64) -> Result<User, DatabaseError>;
        async fn update_user(&self, id: u64, user_data: UpdateUser) -> Result<User, DatabaseError>;
        async fn delete_user(&self, id: u64) -> Result<(), DatabaseError>;
    }
}
```

### 2. å¼‚æ­¥æµ‹è¯•

```rust
#[cfg(test)]
mod async_tests {
    use super::*;
    use tokio::time::{sleep, Duration, timeout};
    use tokio_test::task;

    #[tokio::test]
    async fn test_concurrent_user_creation() {
        let user_service = create_test_user_service();
        let user_data = CreateUser {
            username: "concurrent_user".to_string(),
            email: "concurrent@example.com".to_string(),
            password: "password123".to_string(),
        };

        // å¹¶å‘åˆ›å»ºç”¨æˆ·
        let handles: Vec<_> = (0..10)
            .map(|i| {
                let service = user_service.clone();
                let data = user_data.clone();
                tokio::spawn(async move {
                    service.create_user(data).await
                })
            })
            .collect();

        // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        let results = futures::future::join_all(handles).await;

        // éªŒè¯ç»“æœ
        let mut success_count = 0;
        for result in results {
            if let Ok(Ok(_)) = result {
                success_count += 1;
            }
        }

        // ç”±äºå¹¶å‘åˆ›å»ºç›¸åŒç”¨æˆ·ï¼Œåªæœ‰ä¸€ä¸ªåº”è¯¥æˆåŠŸ
        assert_eq!(success_count, 1);
    }

    #[tokio::test]
    async fn test_timeout_handling() {
        let user_service = create_slow_user_service();
        let user_data = CreateUser {
            username: "timeout_user".to_string(),
            email: "timeout@example.com".to_string(),
            password: "password123".to_string(),
        };

        // æµ‹è¯•è¶…æ—¶å¤„ç†
        let result = timeout(
            Duration::from_millis(100),
            user_service.create_user(user_data)
        ).await;

        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_retry_mechanism() {
        let user_service = create_flaky_user_service();
        let user_data = CreateUser {
            username: "retry_user".to_string(),
            email: "retry@example.com".to_string(),
            password: "password123".to_string(),
        };

        // æµ‹è¯•é‡è¯•æœºåˆ¶
        let result = user_service.create_user_with_retry(user_data, 3).await;
        assert!(result.is_ok());
    }
}
```

## ğŸ”— é›†æˆæµ‹è¯•

### 1. APIé›†æˆæµ‹è¯•

```rust
#[cfg(test)]
mod integration_tests {
    use super::*;
    use axum::{
        body::Body,
        http::{Request, StatusCode},
        Router,
    };
    use tower::ServiceExt;
    use serde_json::json;

    // æµ‹è¯•æœåŠ¡å™¨è®¾ç½®
    async fn create_test_server() -> Router {
        let db = create_test_database().await;
        let user_service = UserServiceImpl::new(db);
        let app_state = AppState {
            user_service: Arc::new(user_service),
        };
        
        create_router(app_state)
    }

    #[tokio::test]
    async fn test_create_user_endpoint() {
        let app = create_test_server().await;
        
        let user_data = json!({
            "username": "integration_user",
            "email": "integration@example.com",
            "password": "password123"
        });

        let request = Request::builder()
            .method("POST")
            .uri("/users")
            .header("content-type", "application/json")
            .body(Body::from(user_data.to_string()))
            .unwrap();

        let response = app.oneshot(request).await.unwrap();
        assert_eq!(response.status(), StatusCode::CREATED);

        let body = hyper::body::to_bytes(response.into_body()).await.unwrap();
        let user: User = serde_json::from_slice(&body).unwrap();
        assert_eq!(user.username, "integration_user");
    }

    #[tokio::test]
    async fn test_get_user_endpoint() {
        let app = create_test_server().await;
        
        // å…ˆåˆ›å»ºç”¨æˆ·
        let user_data = json!({
            "username": "get_user",
            "email": "get@example.com",
            "password": "password123"
        });

        let create_request = Request::builder()
            .method("POST")
            .uri("/users")
            .header("content-type", "application/json")
            .body(Body::from(user_data.to_string()))
            .unwrap();

        let create_response = app.clone().oneshot(create_request).await.unwrap();
        let create_body = hyper::body::to_bytes(create_response.into_body()).await.unwrap();
        let created_user: User = serde_json::from_slice(&create_body).unwrap();

        // è·å–ç”¨æˆ·
        let get_request = Request::builder()
            .method("GET")
            .uri(&format!("/users/{}", created_user.id))
            .body(Body::empty())
            .unwrap();

        let get_response = app.oneshot(get_request).await.unwrap();
        assert_eq!(get_response.status(), StatusCode::OK);

        let get_body = hyper::body::to_bytes(get_response.into_body()).await.unwrap();
        let user: User = serde_json::from_slice(&get_body).unwrap();
        assert_eq!(user.id, created_user.id);
        assert_eq!(user.username, "get_user");
    }

    #[tokio::test]
    async fn test_authentication_flow() {
        let app = create_test_server().await;
        
        // åˆ›å»ºç”¨æˆ·
        let user_data = json!({
            "username": "auth_user",
            "email": "auth@example.com",
            "password": "password123"
        });

        let create_request = Request::builder()
            .method("POST")
            .uri("/users")
            .header("content-type", "application/json")
            .body(Body::from(user_data.to_string()))
            .unwrap();

        app.clone().oneshot(create_request).await.unwrap();

        // ç™»å½•
        let login_data = json!({
            "username": "auth_user",
            "password": "password123"
        });

        let login_request = Request::builder()
            .method("POST")
            .uri("/auth/login")
            .header("content-type", "application/json")
            .body(Body::from(login_data.to_string()))
            .unwrap();

        let login_response = app.clone().oneshot(login_request).await.unwrap();
        assert_eq!(login_response.status(), StatusCode::OK);

        let login_body = hyper::body::to_bytes(login_response.into_body()).await.unwrap();
        let login_result: LoginResponse = serde_json::from_slice(&login_body).unwrap();
        
        // ä½¿ç”¨tokenè®¿é—®å—ä¿æŠ¤çš„ç«¯ç‚¹
        let protected_request = Request::builder()
            .method("GET")
            .uri("/users/profile")
            .header("authorization", format!("Bearer {}", login_result.token))
            .body(Body::empty())
            .unwrap();

        let protected_response = app.oneshot(protected_request).await.unwrap();
        assert_eq!(protected_response.status(), StatusCode::OK);
    }
}
```

### 2. æ•°æ®åº“é›†æˆæµ‹è¯•

```rust
#[cfg(test)]
mod database_tests {
    use super::*;
    use sqlx::PgPool;
    use testcontainers::{clients, Container, images::Postgres};

    // ä½¿ç”¨testcontainersè¿›è¡Œæ•°æ®åº“æµ‹è¯•
    #[tokio::test]
    async fn test_database_operations() {
        let docker = clients::Cli::default();
        let postgres_image = Postgres::default();
        let container = docker.run(postgres_image);
        
        let connection_string = format!(
            "postgres://postgres:postgres@localhost:{}/postgres",
            container.get_host_port_ipv4(5432)
        );

        let pool = PgPool::connect(&connection_string).await.unwrap();
        
        // è¿è¡Œè¿ç§»
        sqlx::migrate!("./migrations").run(&pool).await.unwrap();

        // æµ‹è¯•æ•°æ®åº“æ“ä½œ
        let user_repository = UserRepository::new(pool);
        
        // åˆ›å»ºç”¨æˆ·
        let user_data = CreateUser {
            username: "db_test_user".to_string(),
            email: "db_test@example.com".to_string(),
            password: "password123".to_string(),
        };

        let user = user_repository.create_user(user_data).await.unwrap();
        assert_eq!(user.username, "db_test_user");

        // è·å–ç”¨æˆ·
        let retrieved_user = user_repository.get_user(user.id).await.unwrap();
        assert_eq!(retrieved_user.id, user.id);

        // æ›´æ–°ç”¨æˆ·
        let update_data = UpdateUser {
            email: Some("updated@example.com".to_string()),
            ..Default::default()
        };

        let updated_user = user_repository.update_user(user.id, update_data).await.unwrap();
        assert_eq!(updated_user.email, "updated@example.com");

        // åˆ é™¤ç”¨æˆ·
        user_repository.delete_user(user.id).await.unwrap();
        
        // éªŒè¯ç”¨æˆ·å·²åˆ é™¤
        let result = user_repository.get_user(user.id).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_database_transactions() {
        let docker = clients::Cli::default();
        let postgres_image = Postgres::default();
        let container = docker.run(postgres_image);
        
        let connection_string = format!(
            "postgres://postgres:postgres@localhost:{}/postgres",
            container.get_host_port_ipv4(5432)
        );

        let pool = PgPool::connect(&connection_string).await.unwrap();
        sqlx::migrate!("./migrations").run(&pool).await.unwrap();

        let user_repository = UserRepository::new(pool);

        // æµ‹è¯•äº‹åŠ¡å›æ»š
        let result = user_repository.create_user_with_transaction(
            CreateUser {
                username: "transaction_user".to_string(),
                email: "transaction@example.com".to_string(),
                password: "password123".to_string(),
            },
            true, // å¼ºåˆ¶å¤±è´¥
        ).await;

        assert!(result.is_err());

        // éªŒè¯ç”¨æˆ·æœªåˆ›å»º
        let users = user_repository.get_users_by_username("transaction_user").await.unwrap();
        assert!(users.is_empty());
    }
}
```

## ğŸŒ ç«¯åˆ°ç«¯æµ‹è¯•

### 1. ç”¨æˆ·åœºæ™¯æµ‹è¯•

```rust
#[cfg(test)]
mod e2e_tests {
    use super::*;
    use reqwest::Client;
    use serde_json::json;
    use std::time::Duration;

    // æµ‹è¯•ç¯å¢ƒè®¾ç½®
    struct TestEnvironment {
        client: Client,
        base_url: String,
        auth_token: Option<String>,
    }

    impl TestEnvironment {
        async fn new() -> Self {
            let client = Client::new();
            let base_url = std::env::var("TEST_BASE_URL")
                .unwrap_or_else(|_| "http://localhost:8080".to_string());

            Self {
                client,
                base_url,
                auth_token: None,
            }
        }

        async fn create_user(&self, username: &str, email: &str) -> User {
            let user_data = json!({
                "username": username,
                "email": email,
                "password": "password123"
            });

            let response = self.client
                .post(&format!("{}/users", self.base_url))
                .json(&user_data)
                .send()
                .await
                .unwrap();

            assert_eq!(response.status(), 201);
            response.json().await.unwrap()
        }

        async fn login(&mut self, username: &str, password: &str) -> String {
            let login_data = json!({
                "username": username,
                "password": password
            });

            let response = self.client
                .post(&format!("{}/auth/login", self.base_url))
                .json(&login_data)
                .send()
                .await
                .unwrap();

            assert_eq!(response.status(), 200);
            let login_result: LoginResponse = response.json().await.unwrap();
            self.auth_token = Some(login_result.token.clone());
            login_result.token
        }

        async fn create_order(&self, user_id: u64, items: Vec<OrderItem>) -> Order {
            let order_data = json!({
                "user_id": user_id,
                "items": items
            });

            let mut request = self.client
                .post(&format!("{}/orders", self.base_url))
                .json(&order_data);

            if let Some(token) = &self.auth_token {
                request = request.bearer_auth(token);
            }

            let response = request.send().await.unwrap();
            assert_eq!(response.status(), 201);
            response.json().await.unwrap()
        }
    }

    #[tokio::test]
    async fn test_complete_user_journey() {
        let mut env = TestEnvironment::new().await;

        // 1. ç”¨æˆ·æ³¨å†Œ
        let user = env.create_user("e2e_user", "e2e@example.com").await;
        assert_eq!(user.username, "e2e_user");

        // 2. ç”¨æˆ·ç™»å½•
        let token = env.login("e2e_user", "password123").await;
        assert!(!token.is_empty());

        // 3. åˆ›å»ºè®¢å•
        let items = vec![
            OrderItem {
                product_id: 1,
                quantity: 2,
                price: 10.99,
            },
            OrderItem {
                product_id: 2,
                quantity: 1,
                price: 5.99,
            },
        ];

        let order = env.create_order(user.id, items).await;
        assert_eq!(order.user_id, user.id);
        assert_eq!(order.items.len(), 2);

        // 4. æŸ¥çœ‹è®¢å•
        let response = env.client
            .get(&format!("{}/orders/{}", env.base_url, order.id))
            .bearer_auth(&token)
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), 200);
        let retrieved_order: Order = response.json().await.unwrap();
        assert_eq!(retrieved_order.id, order.id);

        // 5. æ›´æ–°è®¢å•çŠ¶æ€
        let update_data = json!({
            "status": "shipped"
        });

        let response = env.client
            .patch(&format!("{}/orders/{}", env.base_url, order.id))
            .bearer_auth(&token)
            .json(&update_data)
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), 200);
        let updated_order: Order = response.json().await.unwrap();
        assert_eq!(updated_order.status, "shipped");
    }

    #[tokio::test]
    async fn test_error_handling_flow() {
        let env = TestEnvironment::new().await;

        // 1. å°è¯•åˆ›å»ºé‡å¤ç”¨æˆ·
        env.create_user("duplicate_user", "duplicate@example.com").await;
        
        let user_data = json!({
            "username": "duplicate_user",
            "email": "duplicate2@example.com",
            "password": "password123"
        });

        let response = env.client
            .post(&format!("{}/users", env.base_url))
            .json(&user_data)
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), 409); // Conflict

        // 2. å°è¯•ä½¿ç”¨æ— æ•ˆå‡­æ®ç™»å½•
        let login_data = json!({
            "username": "nonexistent_user",
            "password": "wrong_password"
        });

        let response = env.client
            .post(&format!("{}/auth/login", env.base_url))
            .json(&login_data)
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), 401); // Unauthorized

        // 3. å°è¯•è®¿é—®å—ä¿æŠ¤çš„ç«¯ç‚¹è€Œä¸æä¾›token
        let response = env.client
            .get(&format!("{}/users/profile", env.base_url))
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), 401); // Unauthorized
    }
}
```

### 2. æ€§èƒ½æµ‹è¯•

```rust
#[cfg(test)]
mod performance_tests {
    use super::*;
    use std::time::Instant;
    use tokio::time::sleep;

    #[tokio::test]
    async fn test_concurrent_user_creation_performance() {
        let env = TestEnvironment::new().await;
        let start_time = Instant::now();
        
        // å¹¶å‘åˆ›å»º100ä¸ªç”¨æˆ·
        let handles: Vec<_> = (0..100)
            .map(|i| {
                let env = env.clone();
                tokio::spawn(async move {
                    env.create_user(&format!("perf_user_{}", i), &format!("perf{}@example.com", i)).await
                })
            })
            .collect();

        let results = futures::future::join_all(handles).await;
        let duration = start_time.elapsed();

        // éªŒè¯æ‰€æœ‰ç”¨æˆ·éƒ½åˆ›å»ºæˆåŠŸ
        let mut success_count = 0;
        for result in results {
            if let Ok(Ok(_)) = result {
                success_count += 1;
            }
        }

        assert_eq!(success_count, 100);
        assert!(duration.as_secs() < 10); // åº”è¯¥åœ¨10ç§’å†…å®Œæˆ

        println!("Created 100 users in {:?}", duration);
    }

    #[tokio::test]
    async fn test_api_response_time() {
        let env = TestEnvironment::new().await;
        let user = env.create_user("response_time_user", "response@example.com").await;

        // æµ‹è¯•APIå“åº”æ—¶é—´
        let start_time = Instant::now();
        let response = env.client
            .get(&format!("{}/users/{}", env.base_url, user.id))
            .send()
            .await
            .unwrap();
        let duration = start_time.elapsed();

        assert_eq!(response.status(), 200);
        assert!(duration.as_millis() < 100); // å“åº”æ—¶é—´åº”è¯¥å°äº100ms

        println!("API response time: {:?}", duration);
    }

    #[tokio::test]
    async fn test_memory_usage_under_load() {
        let env = TestEnvironment::new().await;
        
        // åˆ›å»ºå¤§é‡ç”¨æˆ·å¹¶ç›‘æ§å†…å­˜ä½¿ç”¨
        for i in 0..1000 {
            env.create_user(&format!("memory_user_{}", i), &format!("memory{}@example.com", i)).await;
            
            if i % 100 == 0 {
                // æ¯100ä¸ªç”¨æˆ·æ£€æŸ¥ä¸€æ¬¡å†…å­˜ä½¿ç”¨
                let memory_usage = get_memory_usage();
                assert!(memory_usage < 512 * 1024 * 1024); // å†…å­˜ä½¿ç”¨åº”è¯¥å°äº512MB
                println!("Memory usage after {} users: {} MB", i, memory_usage / 1024 / 1024);
            }
        }
    }

    fn get_memory_usage() -> usize {
        // è·å–å½“å‰è¿›ç¨‹çš„å†…å­˜ä½¿ç”¨é‡
        // è¿™é‡Œä½¿ç”¨ç®€åŒ–çš„å®ç°
        0
    }
}
```

## ğŸ­ æ··æ²Œå·¥ç¨‹

### 1. æ•…éšœæ³¨å…¥æµ‹è¯•

```rust
#[cfg(test)]
mod chaos_tests {
    use super::*;
    use std::time::Duration;
    use tokio::time::timeout;

    // æ•…éšœæ³¨å…¥å™¨
    struct FaultInjector {
        failure_rate: f64,
        latency_ms: u64,
    }

    impl FaultInjector {
        fn new(failure_rate: f64, latency_ms: u64) -> Self {
            Self {
                failure_rate,
                latency_ms,
            }
        }

        async fn inject_fault<T>(&self, operation: impl Future<Output = Result<T, Box<dyn std::error::Error>>>) -> Result<T, Box<dyn std::error::Error>> {
            // æ³¨å…¥å»¶è¿Ÿ
            if self.latency_ms > 0 {
                sleep(Duration::from_millis(self.latency_ms)).await;
            }

            // æ³¨å…¥æ•…éšœ
            if rand::random::<f64>() < self.failure_rate {
                return Err("Injected fault".into());
            }

            operation.await
        }
    }

    #[tokio::test]
    async fn test_database_failure_recovery() {
        let fault_injector = FaultInjector::new(0.3, 100); // 30%æ•…éšœç‡ï¼Œ100mså»¶è¿Ÿ
        let user_service = create_test_user_service();

        let mut success_count = 0;
        let mut failure_count = 0;

        // æ‰§è¡Œ100æ¬¡æ“ä½œ
        for i in 0..100 {
            let user_data = CreateUser {
                username: format!("chaos_user_{}", i),
                email: format!("chaos{}@example.com", i),
                password: "password123".to_string(),
            };

            let result = fault_injector.inject_fault(
                user_service.create_user(user_data)
            ).await;

            match result {
                Ok(_) => success_count += 1,
                Err(_) => failure_count += 1,
            }
        }

        // éªŒè¯ç³»ç»Ÿåœ¨æ•…éšœæƒ…å†µä¸‹çš„è¡Œä¸º
        assert!(success_count > 0);
        assert!(failure_count > 0);
        println!("Success: {}, Failures: {}", success_count, failure_count);
    }

    #[tokio::test]
    async fn test_network_partition_simulation() {
        let user_service = create_test_user_service();
        
        // æ¨¡æ‹Ÿç½‘ç»œåˆ†åŒº
        let partition_duration = Duration::from_secs(5);
        
        // åœ¨åˆ†åŒºæœŸé—´å°è¯•æ“ä½œ
        let result = timeout(
            partition_duration,
            user_service.create_user(CreateUser {
                username: "partition_user".to_string(),
                email: "partition@example.com".to_string(),
                password: "password123".to_string(),
            })
        ).await;

        // éªŒè¯è¶…æ—¶å¤„ç†
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_cascade_failure_prevention() {
        let user_service = create_test_user_service();
        
        // æ¨¡æ‹Ÿçº§è”æ•…éšœ
        let mut handles = Vec::new();
        
        for i in 0..50 {
            let service = user_service.clone();
            let handle = tokio::spawn(async move {
                let user_data = CreateUser {
                    username: format!("cascade_user_{}", i),
                    email: format!("cascade{}@example.com", i),
                    password: "password123".to_string(),
                };
                
                service.create_user(user_data).await
            });
            handles.push(handle);
        }

        // ç­‰å¾…æ‰€æœ‰æ“ä½œå®Œæˆ
        let results = futures::future::join_all(handles).await;
        
        // éªŒè¯ç³»ç»Ÿæ²¡æœ‰å®Œå…¨å´©æºƒ
        let success_count = results.iter()
            .filter(|r| r.is_ok() && r.as_ref().unwrap().is_ok())
            .count();
        
        assert!(success_count > 0);
        println!("Cascade failure test - Success count: {}", success_count);
    }
}
```

### 2. è´Ÿè½½æµ‹è¯•

```rust
#[cfg(test)]
mod load_tests {
    use super::*;
    use std::sync::atomic::{AtomicUsize, Ordering};
    use std::sync::Arc;

    #[tokio::test]
    async fn test_sustained_load() {
        let env = TestEnvironment::new().await;
        let request_count = Arc::new(AtomicUsize::new(0));
        let error_count = Arc::new(AtomicUsize::new(0));
        
        // åˆ›å»ºç”¨æˆ·
        let user = env.create_user("load_test_user", "load@example.com").await;
        let token = env.login("load_test_user", "password123").await;

        // æŒç»­è´Ÿè½½æµ‹è¯•
        let duration = Duration::from_secs(30);
        let start_time = Instant::now();
        
        while start_time.elapsed() < duration {
            let request_count = request_count.clone();
            let error_count = error_count.clone();
            let env = env.clone();
            let token = token.clone();
            
            tokio::spawn(async move {
                let response = env.client
                    .get(&format!("{}/users/{}", env.base_url, user.id))
                    .bearer_auth(&token)
                    .send()
                    .await;

                request_count.fetch_add(1, Ordering::Relaxed);
                
                if let Err(_) = response {
                    error_count.fetch_add(1, Ordering::Relaxed);
                }
            });

            // æ§åˆ¶è¯·æ±‚é€Ÿç‡
            sleep(Duration::from_millis(10)).await;
        }

        // ç­‰å¾…æ‰€æœ‰è¯·æ±‚å®Œæˆ
        sleep(Duration::from_secs(5)).await;

        let total_requests = request_count.load(Ordering::Relaxed);
        let total_errors = error_count.load(Ordering::Relaxed);
        let error_rate = total_errors as f64 / total_requests as f64;

        println!("Load test results:");
        println!("Total requests: {}", total_requests);
        println!("Total errors: {}", total_errors);
        println!("Error rate: {:.2}%", error_rate * 100.0);

        // éªŒè¯é”™è¯¯ç‡åœ¨å¯æ¥å—èŒƒå›´å†…
        assert!(error_rate < 0.01); // é”™è¯¯ç‡åº”è¯¥å°äº1%
    }

    #[tokio::test]
    async fn test_peak_load_handling() {
        let env = TestEnvironment::new().await;
        
        // å³°å€¼è´Ÿè½½æµ‹è¯•
        let peak_duration = Duration::from_secs(10);
        let start_time = Instant::now();
        
        while start_time.elapsed() < peak_duration {
            let env = env.clone();
            
            // å¹¶å‘å‘é€å¤§é‡è¯·æ±‚
            for _ in 0..100 {
                tokio::spawn(async move {
                    let _ = env.client
                        .get(&format!("{}/health", env.base_url))
                        .send()
                        .await;
                });
            }
            
            sleep(Duration::from_millis(100)).await;
        }

        // éªŒè¯ç³»ç»Ÿåœ¨å³°å€¼è´Ÿè½½ä¸‹çš„ç¨³å®šæ€§
        let response = env.client
            .get(&format!("{}/health", env.base_url))
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), 200);
    }
}
```

## ğŸ“Š æµ‹è¯•æŠ¥å‘Šä¸æŒ‡æ ‡

### 1. æµ‹è¯•è¦†ç›–ç‡æŠ¥å‘Š

```rust
// æµ‹è¯•è¦†ç›–ç‡é…ç½®
#[cfg(test)]
mod coverage_tests {
    use super::*;
    use tarpaulin::{Config, RunType};

    #[test]
    fn test_coverage_configuration() {
        let config = Config::default()
            .set_include("src/")
            .set_exclude("src/bin/")
            .set_exclude("src/tests/")
            .set_exclude("src/examples/")
            .set_include_ignored(true)
            .set_include_tests(true)
            .set_verbose(true);

        // è¿è¡Œè¦†ç›–ç‡æµ‹è¯•
        let result = tarpaulin::run_tests(&config);
        assert!(result.is_ok());
    }
}
```

### 2. æ€§èƒ½åŸºå‡†æµ‹è¯•

```rust
#[cfg(test)]
mod benchmark_tests {
    use super::*;
    use criterion::{black_box, criterion_group, criterion_main, Criterion};

    fn benchmark_user_creation(c: &mut Criterion) {
        let rt = tokio::runtime::Runtime::new().unwrap();
        let user_service = rt.block_on(create_test_user_service());

        c.bench_function("user_creation", |b| {
            b.to_async(&rt).iter(|| async {
                let user_data = CreateUser {
                    username: "benchmark_user".to_string(),
                    email: "benchmark@example.com".to_string(),
                    password: "password123".to_string(),
                };
                
                black_box(user_service.create_user(user_data).await)
            })
        });
    }

    fn benchmark_user_retrieval(c: &mut Criterion) {
        let rt = tokio::runtime::Runtime::new().unwrap();
        let user_service = rt.block_on(create_test_user_service());
        let user_id = rt.block_on(async {
            let user_data = CreateUser {
                username: "benchmark_retrieval_user".to_string(),
                email: "benchmark_retrieval@example.com".to_string(),
                password: "password123".to_string(),
            };
            let user = user_service.create_user(user_data).await.unwrap();
            user.id
        });

        c.bench_function("user_retrieval", |b| {
            b.to_async(&rt).iter(|| async {
                black_box(user_service.get_user(user_id).await)
            })
        });
    }

    criterion_group!(benches, benchmark_user_creation, benchmark_user_retrieval);
    criterion_main!(benches);
}
```

## ğŸš€ æŒç»­é›†æˆæµ‹è¯•

### 1. CI/CDæµ‹è¯•æµæ°´çº¿

```yaml
# .github/workflows/test.yml
name: Test Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: 1.90
        components: rustfmt, clippy
    
    - name: Run unit tests
      run: cargo test --lib
    
    - name: Run integration tests
      run: cargo test --test integration
    
    - name: Generate coverage report
      run: |
        cargo install cargo-tarpaulin
        cargo tarpaulin --out Html --output-dir coverage/
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: coverage/cobertura.xml

  e2e-tests:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: 1.90
    
    - name: Run database migrations
      run: |
        cargo install sqlx-cli
        sqlx migrate run
    
    - name: Run E2E tests
      run: cargo test --test e2e
      env:
        DATABASE_URL: postgres://postgres:postgres@localhost:5432/postgres

  performance-tests:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: 1.90
    
    - name: Run performance tests
      run: cargo test --test performance
    
    - name: Run benchmarks
      run: cargo bench
```

### 2. æµ‹è¯•è´¨é‡é—¨ç¦

```rust
// æµ‹è¯•è´¨é‡æ£€æŸ¥
#[cfg(test)]
mod quality_gates {
    use super::*;

    #[test]
    fn test_minimum_coverage() {
        // æ£€æŸ¥æµ‹è¯•è¦†ç›–ç‡æ˜¯å¦è¾¾åˆ°æœ€ä½è¦æ±‚
        let coverage = get_test_coverage();
        assert!(coverage >= 80.0, "Test coverage {}% is below minimum 80%", coverage);
    }

    #[test]
    fn test_performance_requirements() {
        // æ£€æŸ¥æ€§èƒ½æ˜¯å¦æ»¡è¶³è¦æ±‚
        let response_time = measure_api_response_time();
        assert!(response_time < 100, "API response time {}ms exceeds 100ms limit", response_time);
    }

    #[test]
    fn test_security_requirements() {
        // æ£€æŸ¥å®‰å…¨æµ‹è¯•æ˜¯å¦é€šè¿‡
        let security_tests_passed = run_security_tests();
        assert!(security_tests_passed, "Security tests failed");
    }

    fn get_test_coverage() -> f64 {
        // è·å–æµ‹è¯•è¦†ç›–ç‡
        85.0 // æ¨¡æ‹Ÿå€¼
    }

    fn measure_api_response_time() -> u64 {
        // æµ‹é‡APIå“åº”æ—¶é—´
        50 // æ¨¡æ‹Ÿå€¼
    }

    fn run_security_tests() -> bool {
        // è¿è¡Œå®‰å…¨æµ‹è¯•
        true // æ¨¡æ‹Ÿå€¼
    }
}
```

## ğŸ“š æœ€ä½³å®è·µæ€»ç»“

### 1. æµ‹è¯•ç­–ç•¥åŸåˆ™

- **æµ‹è¯•é‡‘å­—å¡”**: å¤§é‡å•å…ƒæµ‹è¯•ï¼Œé€‚é‡é›†æˆæµ‹è¯•ï¼Œå°‘é‡ç«¯åˆ°ç«¯æµ‹è¯•
- **æµ‹è¯•éš”ç¦»**: æ¯ä¸ªæµ‹è¯•ç‹¬ç«‹è¿è¡Œï¼Œä¸ä¾èµ–å…¶ä»–æµ‹è¯•
- **æµ‹è¯•æ•°æ®**: ä½¿ç”¨æµ‹è¯•ä¸“ç”¨çš„æ•°æ®å’Œç¯å¢ƒ
- **æŒç»­æµ‹è¯•**: åœ¨CI/CDæµæ°´çº¿ä¸­è‡ªåŠ¨è¿è¡Œæµ‹è¯•

### 2. æµ‹è¯•è´¨é‡æŒ‡æ ‡

- **è¦†ç›–ç‡**: ä»£ç è¦†ç›–ç‡ > 80%
- **æ€§èƒ½**: APIå“åº”æ—¶é—´ < 100ms
- **å¯é æ€§**: é”™è¯¯ç‡ < 0.1%
- **å®‰å…¨æ€§**: å®‰å…¨æµ‹è¯•100%é€šè¿‡

### 3. æµ‹è¯•å·¥å…·é“¾

- **å•å…ƒæµ‹è¯•**: `cargo test`, `tokio-test`
- **é›†æˆæµ‹è¯•**: `testcontainers`, `reqwest`
- **æ€§èƒ½æµ‹è¯•**: `criterion`, `k6`
- **è¦†ç›–ç‡**: `tarpaulin`, `cargo-llvm-cov`
- **æ··æ²Œå·¥ç¨‹**: `chaos-monkey`, `litmus`

### 4. æµ‹è¯•ç¯å¢ƒç®¡ç†

- **å¼€å‘ç¯å¢ƒ**: æœ¬åœ°Dockerå®¹å™¨
- **æµ‹è¯•ç¯å¢ƒ**: ç‹¬ç«‹çš„æµ‹è¯•æ•°æ®åº“
- **é¢„ç”Ÿäº§ç¯å¢ƒ**: ä¸ç”Ÿäº§ç¯å¢ƒç›¸ä¼¼çš„é…ç½®
- **ç”Ÿäº§ç¯å¢ƒ**: ç›‘æ§å’Œå‘Šè­¦

## ğŸ”— ç›¸å…³èµ„æº

- [Rustæµ‹è¯•æ–‡æ¡£](https://doc.rust-lang.org/book/ch11-00-testing.html)
- [Tokioæµ‹è¯•æŒ‡å—](https://tokio.rs/tokio/tutorial)
- [æµ‹è¯•æœ€ä½³å®è·µ](https://testing.googleblog.com/)
- [æ··æ²Œå·¥ç¨‹å®è·µ](https://principlesofchaos.org/)

---

**æ³¨æ„**: æœ¬æ–‡æ¡£åŸºäº2025å¹´9æœˆçš„æœ€æ–°æŠ€æœ¯æ ˆï¼Œå»ºè®®å®šæœŸæ›´æ–°ä»¥ä¿æŒæ—¶æ•ˆæ€§ã€‚
