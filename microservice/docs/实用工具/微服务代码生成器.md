# 微服务代码生成器

## 概述

微服务代码生成器是一个强大的工具，可以根据模板和配置自动生成Rust微服务的完整代码结构，包括服务框架、API接口、数据库模型、测试代码等。这个工具大大提高了开发效率，确保代码的一致性和最佳实践。

## 功能特性

- **服务模板生成**: 基于预定义模板生成完整的微服务结构
- **API接口生成**: 自动生成RESTful API接口和gRPC服务
- **数据库模型生成**: 从数据库schema生成Rust数据模型
- **测试代码生成**: 自动生成单元测试和集成测试代码
- **配置文件生成**: 生成Docker、Kubernetes等部署配置
- **文档生成**: 自动生成API文档和项目文档

## 安装和使用

### 安装

```bash
# 从源码安装
cargo install --path ./tools/microservice-generator

# 或使用预编译版本
cargo install microservice-generator
```

### 基本使用

```bash
# 生成新的微服务项目
microservice-generator new user-service --template axum --database postgresql

# 生成API接口
microservice-generator generate api User --methods create,read,update,delete

# 生成数据库模型
microservice-generator generate model User --database postgresql

# 生成测试代码
microservice-generator generate tests User
```

## 代码生成器实现

### 1. 主生成器结构

```rust
// 微服务代码生成器
use std::path::PathBuf;
use serde::{Deserialize, Serialize};
use handlebars::Handlebars;

pub struct MicroserviceGenerator {
    templates: Handlebars<'static>,
    config: GeneratorConfig,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GeneratorConfig {
    pub project_name: String,
    pub template: ServiceTemplate,
    pub database: DatabaseType,
    pub framework: WebFramework,
    pub features: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum ServiceTemplate {
    Basic,
    CRUD,
    EventDriven,
    GraphQL,
    gRPC,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum DatabaseType {
    PostgreSQL,
    MySQL,
    SQLite,
    MongoDB,
    Redis,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum WebFramework {
    Axum,
    ActixWeb,
    Warp,
    Poem,
    Salvo,
}

impl MicroserviceGenerator {
    pub fn new(config: GeneratorConfig) -> Result<Self, GeneratorError> {
        let mut templates = Handlebars::new();
        
        // 注册模板
        Self::register_templates(&mut templates)?;
        
        Ok(Self {
            templates,
            config,
        })
    }
    
    pub async fn generate_project(&self, output_dir: PathBuf) -> Result<(), GeneratorError> {
        // 1. 创建项目目录结构
        self.create_project_structure(&output_dir).await?;
        
        // 2. 生成Cargo.toml
        self.generate_cargo_toml(&output_dir).await?;
        
        // 3. 生成主服务文件
        self.generate_main_service(&output_dir).await?;
        
        // 4. 生成配置文件
        self.generate_config_files(&output_dir).await?;
        
        // 5. 生成Docker配置
        self.generate_docker_config(&output_dir).await?;
        
        // 6. 生成测试文件
        self.generate_test_files(&output_dir).await?;
        
        // 7. 生成文档
        self.generate_documentation(&output_dir).await?;
        
        Ok(())
    }
    
    async fn create_project_structure(&self, output_dir: &PathBuf) -> Result<(), GeneratorError> {
        let directories = vec![
            "src",
            "src/handlers",
            "src/models",
            "src/repositories",
            "src/services",
            "src/middleware",
            "src/config",
            "tests",
            "docs",
            "docker",
            "k8s",
        ];
        
        for dir in directories {
            let dir_path = output_dir.join(dir);
            tokio::fs::create_dir_all(&dir_path).await?;
        }
        
        Ok(())
    }
    
    async fn generate_cargo_toml(&self, output_dir: &PathBuf) -> Result<(), GeneratorError> {
        let cargo_content = self.templates.render("cargo_toml", &self.config)?;
        let cargo_path = output_dir.join("Cargo.toml");
        tokio::fs::write(cargo_path, cargo_content).await?;
        Ok(())
    }
    
    async fn generate_main_service(&self, output_dir: &PathBuf) -> Result<(), GeneratorError> {
        let main_content = self.templates.render("main_rs", &self.config)?;
        let main_path = output_dir.join("src/main.rs");
        tokio::fs::write(main_path, main_content).await?;
        
        // 生成lib.rs
        let lib_content = self.templates.render("lib_rs", &self.config)?;
        let lib_path = output_dir.join("src/lib.rs");
        tokio::fs::write(lib_path, lib_content).await?;
        
        Ok(())
    }
    
    fn register_templates(templates: &mut Handlebars) -> Result<(), GeneratorError> {
        // 注册Cargo.toml模板
        templates.register_template_string("cargo_toml", include_str!("../templates/cargo.toml.hbs"))?;
        
        // 注册main.rs模板
        templates.register_template_string("main_rs", include_str!("../templates/main.rs.hbs"))?;
        
        // 注册lib.rs模板
        templates.register_template_string("lib_rs", include_str!("../templates/lib.rs.hbs"))?;
        
        // 注册handler模板
        templates.register_template_string("handler", include_str!("../templates/handler.rs.hbs"))?;
        
        // 注册model模板
        templates.register_template_string("model", include_str!("../templates/model.rs.hbs"))?;
        
        // 注册service模板
        templates.register_template_string("service", include_str!("../templates/service.rs.hbs"))?;
        
        // 注册repository模板
        templates.register_template_string("repository", include_str!("../templates/repository.rs.hbs"))?;
        
        // 注册Dockerfile模板
        templates.register_template_string("dockerfile", include_str!("../templates/Dockerfile.hbs"))?;
        
        // 注册docker-compose模板
        templates.register_template_string("docker_compose", include_str!("../templates/docker-compose.yml.hbs"))?;
        
        Ok(())
    }
}
```

### 2. API生成器

```rust
// API生成器
pub struct ApiGenerator {
    templates: Handlebars<'static>,
}

impl ApiGenerator {
    pub fn new() -> Result<Self, GeneratorError> {
        let mut templates = Handlebars::new();
        
        // 注册API相关模板
        templates.register_template_string("api_handler", include_str!("../templates/api_handler.rs.hbs"))?;
        templates.register_template_string("api_model", include_str!("../templates/api_model.rs.hbs"))?;
        templates.register_template_string("api_service", include_str!("../templates/api_service.rs.hbs"))?;
        
        Ok(Self { templates })
    }
    
    pub async fn generate_crud_api(
        &self,
        entity_name: &str,
        fields: Vec<FieldDefinition>,
        output_dir: &PathBuf,
    ) -> Result<(), GeneratorError> {
        let context = ApiContext {
            entity_name: entity_name.to_string(),
            fields,
            methods: vec![
                "create".to_string(),
                "read".to_string(),
                "update".to_string(),
                "delete".to_string(),
                "list".to_string(),
            ],
        };
        
        // 生成模型
        let model_content = self.templates.render("api_model", &context)?;
        let model_path = output_dir.join(format!("src/models/{}.rs", entity_name.to_lowercase()));
        tokio::fs::write(model_path, model_content).await?;
        
        // 生成服务
        let service_content = self.templates.render("api_service", &context)?;
        let service_path = output_dir.join(format!("src/services/{}_service.rs", entity_name.to_lowercase()));
        tokio::fs::write(service_path, service_content).await?;
        
        // 生成处理器
        let handler_content = self.templates.render("api_handler", &context)?;
        let handler_path = output_dir.join(format!("src/handlers/{}_handler.rs", entity_name.to_lowercase()));
        tokio::fs::write(handler_path, handler_content).await?;
        
        // 生成测试
        self.generate_api_tests(&context, output_dir).await?;
        
        Ok(())
    }
    
    async fn generate_api_tests(
        &self,
        context: &ApiContext,
        output_dir: &PathBuf,
    ) -> Result<(), GeneratorError> {
        let test_content = self.templates.render("api_tests", context)?;
        let test_path = output_dir.join(format!("tests/{}_tests.rs", context.entity_name.to_lowercase()));
        tokio::fs::write(test_path, test_content).await?;
        Ok(())
    }
}

#[derive(Debug, Serialize)]
pub struct ApiContext {
    pub entity_name: String,
    pub fields: Vec<FieldDefinition>,
    pub methods: Vec<String>,
}

#[derive(Debug, Serialize)]
pub struct FieldDefinition {
    pub name: String,
    pub field_type: String,
    pub is_optional: bool,
    pub is_primary_key: bool,
    pub validation_rules: Vec<String>,
}
```

### 3. 数据库模型生成器

```rust
// 数据库模型生成器
pub struct ModelGenerator {
    templates: Handlebars<'static>,
}

impl ModelGenerator {
    pub fn new() -> Result<Self, GeneratorError> {
        let mut templates = Handlebars::new();
        
        templates.register_template_string("sqlx_model", include_str!("../templates/sqlx_model.rs.hbs"))?;
        templates.register_template_string("diesel_model", include_str!("../templates/diesel_model.rs.hbs"))?;
        templates.register_template_string("sea_orm_model", include_str!("../templates/sea_orm_model.rs.hbs"))?;
        
        Ok(Self { templates })
    }
    
    pub async fn generate_from_schema(
        &self,
        schema: DatabaseSchema,
        orm_type: OrmType,
        output_dir: &PathBuf,
    ) -> Result<(), GeneratorError> {
        for table in schema.tables {
            let context = ModelContext {
                table_name: table.name.clone(),
                fields: table.fields,
                relationships: table.relationships,
                orm_type: orm_type.clone(),
            };
            
            let template_name = match orm_type {
                OrmType::SQLx => "sqlx_model",
                OrmType::Diesel => "diesel_model",
                OrmType::SeaORM => "sea_orm_model",
            };
            
            let model_content = self.templates.render(template_name, &context)?;
            let model_path = output_dir.join(format!("src/models/{}.rs", table.name.to_lowercase()));
            tokio::fs::write(model_path, model_content).await?;
        }
        
        Ok(())
    }
}

#[derive(Debug, Serialize)]
pub struct ModelContext {
    pub table_name: String,
    pub fields: Vec<FieldDefinition>,
    pub relationships: Vec<RelationshipDefinition>,
    pub orm_type: OrmType,
}

#[derive(Debug, Serialize, Clone)]
pub enum OrmType {
    SQLx,
    Diesel,
    SeaORM,
}

#[derive(Debug, Serialize)]
pub struct RelationshipDefinition {
    pub name: String,
    pub target_table: String,
    pub relationship_type: RelationshipType,
    pub foreign_key: String,
}

#[derive(Debug, Serialize)]
pub enum RelationshipType {
    OneToOne,
    OneToMany,
    ManyToMany,
}
```

### 4. 测试生成器

```rust
// 测试生成器
pub struct TestGenerator {
    templates: Handlebars<'static>,
}

impl TestGenerator {
    pub fn new() -> Result<Self, GeneratorError> {
        let mut templates = Handlebars::new();
        
        templates.register_template_string("unit_test", include_str!("../templates/unit_test.rs.hbs"))?;
        templates.register_template_string("integration_test", include_str!("../templates/integration_test.rs.hbs"))?;
        templates.register_template_string("api_test", include_str!("../templates/api_test.rs.hbs"))?;
        
        Ok(Self { templates })
    }
    
    pub async fn generate_unit_tests(
        &self,
        module_name: &str,
        functions: Vec<FunctionDefinition>,
        output_dir: &PathBuf,
    ) -> Result<(), GeneratorError> {
        let context = TestContext {
            module_name: module_name.to_string(),
            functions,
            test_type: TestType::Unit,
        };
        
        let test_content = self.templates.render("unit_test", &context)?;
        let test_path = output_dir.join(format!("tests/{}_unit_tests.rs", module_name.to_lowercase()));
        tokio::fs::write(test_path, test_content).await?;
        
        Ok(())
    }
    
    pub async fn generate_integration_tests(
        &self,
        service_name: &str,
        endpoints: Vec<EndpointDefinition>,
        output_dir: &PathBuf,
    ) -> Result<(), GeneratorError> {
        let context = TestContext {
            module_name: service_name.to_string(),
            functions: vec![], // 集成测试不需要函数定义
            test_type: TestType::Integration,
        };
        
        let test_content = self.templates.render("integration_test", &context)?;
        let test_path = output_dir.join(format!("tests/{}_integration_tests.rs", service_name.to_lowercase()));
        tokio::fs::write(test_path, test_content).await?;
        
        Ok(())
    }
}

#[derive(Debug, Serialize)]
pub struct TestContext {
    pub module_name: String,
    pub functions: Vec<FunctionDefinition>,
    pub test_type: TestType,
}

#[derive(Debug, Serialize)]
pub struct FunctionDefinition {
    pub name: String,
    pub parameters: Vec<ParameterDefinition>,
    pub return_type: String,
    pub test_cases: Vec<TestCaseDefinition>,
}

#[derive(Debug, Serialize)]
pub struct TestCaseDefinition {
    pub name: String,
    pub input: String,
    pub expected_output: String,
    pub should_panic: bool,
}

#[derive(Debug, Serialize)]
pub enum TestType {
    Unit,
    Integration,
    API,
}
```

## 模板示例

### 1. Cargo.toml模板

```handlebars
[package]
name = "{{project_name}}"
version = "0.1.0"
edition = "2021"

[dependencies]
{{#if (eq framework "Axum")}}
axum = "0.7"
tokio = { version = "1.0", features = ["full"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "trace"] }
{{/if}}
{{#if (eq framework "ActixWeb")}}
actix-web = "4.0"
actix-rt = "2.0"
{{/if}}

# 数据库依赖
{{#if (eq database "PostgreSQL")}}
sqlx = { version = "0.7", features = ["runtime-tokio-rustls", "postgres", "chrono", "uuid"] }
{{/if}}
{{#if (eq database "MySQL")}}
sqlx = { version = "0.7", features = ["runtime-tokio-rustls", "mysql", "chrono", "uuid"] }
{{/if}}

# 序列化
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# 配置管理
config = "0.13"
dotenv = "0.15"

# 日志
tracing = "0.1"
tracing-subscriber = "0.3"

# 错误处理
anyhow = "1.0"
thiserror = "1.0"

# 时间处理
chrono = { version = "0.4", features = ["serde"] }

# UUID
uuid = { version = "1.0", features = ["v4", "serde"] }

# 验证
validator = { version = "0.16", features = ["derive"] }

[dev-dependencies]
tokio-test = "0.4"
```

### 2. 主服务模板

```handlebars
use axum::{
    extract::State,
    http::StatusCode,
    response::Json,
    routing::{get, post},
    Router,
};
use std::sync::Arc;
use tracing::info;

mod config;
mod handlers;
mod models;
mod repositories;
mod services;
mod middleware;

use config::AppConfig;
use handlers::*;
use services::*;

#[derive(Clone)]
pub struct AppState {
    pub config: AppConfig,
    // 添加服务依赖
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // 初始化日志
    tracing_subscriber::fmt::init();
    
    // 加载配置
    let config = AppConfig::load()?;
    
    // 初始化应用状态
    let app_state = AppState {
        config: config.clone(),
    };
    
    // 构建路由
    let app = Router::new()
        .route("/health", get(health_check))
        .route("/ready", get(readiness_check))
        .with_state(app_state);
    
    // 启动服务器
    let listener = tokio::net::TcpListener::bind(&config.server.address).await?;
    info!("Server running on {}", config.server.address);
    
    axum::serve(listener, app).await?;
    
    Ok(())
}

async fn health_check() -> Json<serde_json::Value> {
    Json(serde_json::json!({
        "status": "healthy",
        "timestamp": chrono::Utc::now()
    }))
}

async fn readiness_check(State(state): State<AppState>) -> Result<Json<serde_json::Value>, StatusCode> {
    // 检查数据库连接等
    // 这里可以添加实际的健康检查逻辑
    
    Ok(Json(serde_json::json!({
        "status": "ready",
        "timestamp": chrono::Utc::now()
    })))
}
```

### 3. API处理器模板

```handlebars
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::Json,
    routing::{get, post, put, delete},
    Router,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use uuid::Uuid;

use crate::models::{{entity_name}};
use crate::services::{{entity_name}}Service;
use crate::AppState;

pub fn routes() -> Router<AppState> {
    Router::new()
        .route("/{{entity_name_lower}}", post(create_{{entity_name_lower}}))
        .route("/{{entity_name_lower}}/:id", get(get_{{entity_name_lower}}))
        .route("/{{entity_name_lower}}/:id", put(update_{{entity_name_lower}}))
        .route("/{{entity_name_lower}}/:id", delete(delete_{{entity_name_lower}}))
        .route("/{{entity_name_lower}}", get(list_{{entity_name_lower}}))
}

#[derive(Debug, Deserialize)]
pub struct Create{{entity_name}}Request {
    {{#each fields}}
    pub {{name}}: {{type}},
    {{/each}}
}

#[derive(Debug, Deserialize)]
pub struct Update{{entity_name}}Request {
    {{#each fields}}
    {{#unless is_primary_key}}
    pub {{name}}: Option<{{type}}>,
    {{/unless}}
    {{/each}}
}

#[derive(Debug, Serialize)]
pub struct {{entity_name}}Response {
    pub id: Uuid,
    {{#each fields}}
    {{#unless is_primary_key}}
    pub {{name}}: {{type}},
    {{/unless}}
    {{/each}}
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

async fn create_{{entity_name_lower}}(
    State(state): State<AppState>,
    Json(payload): Json<Create{{entity_name}}Request>,
) -> Result<Json<{{entity_name}}Response>, StatusCode> {
    let {{entity_name_lower}} = {{entity_name}}::new(
        {{#each fields}}
        {{#unless is_primary_key}}
        payload.{{name}},
        {{/unless}}
        {{/each}}
    );
    
    match state.{{entity_name_lower}}_service.create({{entity_name_lower}}).await {
        Ok(created_{{entity_name_lower}}) => Ok(Json({{entity_name}}Response::from(created_{{entity_name_lower}}))),
        Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
    }
}

async fn get_{{entity_name_lower}}(
    State(state): State<AppState>,
    Path(id): Path<Uuid>,
) -> Result<Json<{{entity_name}}Response>, StatusCode> {
    match state.{{entity_name_lower}}_service.get_by_id(id).await {
        Ok(Some({{entity_name_lower}})) => Ok(Json({{entity_name}}Response::from({{entity_name_lower}}))),
        Ok(None) => Err(StatusCode::NOT_FOUND),
        Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
    }
}

async fn update_{{entity_name_lower}}(
    State(state): State<AppState>,
    Path(id): Path<Uuid>,
    Json(payload): Json<Update{{entity_name}}Request>,
) -> Result<Json<{{entity_name}}Response>, StatusCode> {
    match state.{{entity_name_lower}}_service.update(id, payload).await {
        Ok(updated_{{entity_name_lower}}) => Ok(Json({{entity_name}}Response::from(updated_{{entity_name_lower}}))),
        Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
    }
}

async fn delete_{{entity_name_lower}}(
    State(state): State<AppState>,
    Path(id): Path<Uuid>,
) -> Result<StatusCode, StatusCode> {
    match state.{{entity_name_lower}}_service.delete(id).await {
        Ok(_) => Ok(StatusCode::NO_CONTENT),
        Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
    }
}

async fn list_{{entity_name_lower}}(
    State(state): State<AppState>,
    Query(params): Query<ListParams>,
) -> Result<Json<Vec<{{entity_name}}Response>>, StatusCode> {
    match state.{{entity_name_lower}}_service.list(params).await {
        Ok({{entity_name_lower}}s) => {
            let responses: Vec<{{entity_name}}Response> = {{entity_name_lower}}s
                .into_iter()
                .map({{entity_name}}Response::from)
                .collect();
            Ok(Json(responses))
        }
        Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
    }
}

#[derive(Debug, Deserialize)]
pub struct ListParams {
    pub page: Option<u32>,
    pub limit: Option<u32>,
    pub sort_by: Option<String>,
    pub sort_order: Option<String>,
}
```

## 使用示例

### 1. 生成完整的用户服务

```bash
# 创建新的用户服务项目
microservice-generator new user-service \
    --template CRUD \
    --framework Axum \
    --database PostgreSQL \
    --features auth,validation,caching

# 生成用户API
microservice-generator generate api User \
    --fields name:String,email:String,age:u32 \
    --methods create,read,update,delete,list

# 生成数据库模型
microservice-generator generate model User \
    --database PostgreSQL \
    --orm SQLx

# 生成测试
microservice-generator generate tests User \
    --types unit,integration,api
```

### 2. 生成配置文件

```bash
# 生成Docker配置
microservice-generator generate docker \
    --runtime alpine \
    --multi-stage

# 生成Kubernetes配置
microservice-generator generate k8s \
    --replicas 3 \
    --resources requests:cpu=250m,memory=256Mi

# 生成监控配置
microservice-generator generate monitoring \
    --metrics prometheus \
    --tracing jaeger \
    --logging structured
```

### 3. 批量生成多个服务

```bash
# 从配置文件批量生成
microservice-generator batch-generate services.yaml

# services.yaml 内容示例:
# services:
#   - name: user-service
#     template: CRUD
#     database: PostgreSQL
#   - name: product-service
#     template: EventDriven
#     database: MongoDB
#   - name: order-service
#     template: Saga
#     database: PostgreSQL
```

## 最佳实践

### 1. 模板设计

- **模块化**: 将模板拆分为小的、可重用的组件
- **参数化**: 使用参数和条件逻辑使模板更灵活
- **文档化**: 为每个模板提供清晰的文档和示例

### 2. 代码生成

- **一致性**: 确保生成的代码遵循项目的编码规范
- **可读性**: 生成清晰、易读的代码
- **可维护性**: 生成的代码应该易于修改和扩展

### 3. 测试策略

- **模板测试**: 为每个模板编写测试用例
- **生成测试**: 测试生成的代码是否能正常编译和运行
- **集成测试**: 测试生成的服务是否能正确集成

### 4. 版本管理

- **模板版本**: 为模板定义版本号
- **向后兼容**: 保持模板的向后兼容性
- **升级策略**: 提供模板升级和迁移工具

---

**文档版本**: v1.0  
**最后更新**: 2025-01-XX  
**维护者**: 工具团队
