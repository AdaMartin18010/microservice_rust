# å®‰å…¨æœ€ä½³å®è·µæŒ‡å—

> åŸºäºRust 1.90å’Œæœ€æ–°ä¾èµ–ç‰ˆæœ¬çš„å¾®æœåŠ¡å®‰å…¨å®Œæ•´è§£å†³æ–¹æ¡ˆ

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›äº†å®Œæ•´çš„å¾®æœåŠ¡å®‰å…¨æŒ‡å—ï¼ŒåŒ…æ‹¬èº«ä»½è®¤è¯ã€æˆæƒã€æ•°æ®åŠ å¯†ã€å®‰å…¨é€šä¿¡ã€æ¼æ´é˜²æŠ¤ç­‰å…¨æ–¹ä½å®‰å…¨è§£å†³æ–¹æ¡ˆã€‚

## ğŸ¯ å®‰å…¨ç›®æ ‡

### 1. å®‰å…¨åŸåˆ™

- **é›¶ä¿¡ä»»æ¶æ„**: æ°¸ä¸ä¿¡ä»»ï¼Œå§‹ç»ˆéªŒè¯
- **æœ€å°æƒé™åŸåˆ™**: åªæˆäºˆå¿…è¦çš„æƒé™
- **æ·±åº¦é˜²å¾¡**: å¤šå±‚å®‰å…¨é˜²æŠ¤
- **å®‰å…¨å·¦ç§»**: åœ¨å¼€å‘é˜¶æ®µé›†æˆå®‰å…¨

### 2. å®‰å…¨å±‚æ¬¡

```mermaid
graph TB
    A[åº”ç”¨å®‰å…¨] --> B[ç½‘ç»œå®‰å…¨]
    B --> C[æ•°æ®å®‰å…¨]
    C --> D[åŸºç¡€è®¾æ–½å®‰å…¨]
    
    A --> A1[èº«ä»½è®¤è¯]
    A --> A2[æˆæƒæ§åˆ¶]
    A --> A3[è¾“å…¥éªŒè¯]
    A --> A4[è¾“å‡ºç¼–ç ]
    
    B --> B1[TLSåŠ å¯†]
    B --> B2[é˜²ç«å¢™]
    B --> B3[å…¥ä¾µæ£€æµ‹]
    
    C --> C1[æ•°æ®åŠ å¯†]
    C --> C2[å¯†é’¥ç®¡ç†]
    C --> C3[æ•°æ®è„±æ•]
    
    D --> D1[å®¹å™¨å®‰å…¨]
    D --> D2[æ“ä½œç³»ç»Ÿå®‰å…¨]
    D --> D3[ç¡¬ä»¶å®‰å…¨]
```

## ğŸ” èº«ä»½è®¤è¯ä¸æˆæƒ

### 1. JWTè®¤è¯å®ç°

```rust
use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};

// JWT Claimsç»“æ„
#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: String,        // ç”¨æˆ·ID
    pub exp: usize,         // è¿‡æœŸæ—¶é—´
    pub iat: usize,         // ç­¾å‘æ—¶é—´
    pub iss: String,        // ç­¾å‘è€…
    pub aud: String,        // å—ä¼—
    pub roles: Vec<String>, // ç”¨æˆ·è§’è‰²
    pub permissions: Vec<String>, // ç”¨æˆ·æƒé™
}

// JWTè®¤è¯æœåŠ¡
pub struct JwtAuthService {
    encoding_key: EncodingKey,
    decoding_key: DecodingKey,
    validation: Validation,
}

impl JwtAuthService {
    pub fn new(secret: &str) -> Self {
        let encoding_key = EncodingKey::from_secret(secret.as_ref());
        let decoding_key = DecodingKey::from_secret(secret.as_ref());
        
        let mut validation = Validation::new(Algorithm::HS256);
        validation.set_issuer(&["microservice"]);
        validation.set_audience(&["api"]);
        validation.set_required_spec_claims(&["exp", "iat", "sub"]);
        
        Self {
            encoding_key,
            decoding_key,
            validation,
        }
    }
    
    pub fn generate_token(&self, user_id: &str, roles: Vec<String>, permissions: Vec<String>) -> Result<String, Box<dyn std::error::Error>> {
        let now = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs() as usize;
        
        let claims = Claims {
            sub: user_id.to_string(),
            exp: now + 3600, // 1å°æ—¶è¿‡æœŸ
            iat: now,
            iss: "microservice".to_string(),
            aud: "api".to_string(),
            roles,
            permissions,
        };
        
        let token = encode(&Header::default(), &claims, &self.encoding_key)?;
        Ok(token)
    }
    
    pub fn validate_token(&self, token: &str) -> Result<Claims, Box<dyn std::error::Error>> {
        let token_data = decode::<Claims>(token, &self.decoding_key, &self.validation)?;
        Ok(token_data.claims)
    }
    
    pub fn refresh_token(&self, token: &str) -> Result<String, Box<dyn std::error::Error>> {
        let claims = self.validate_token(token)?;
        
        // ç”Ÿæˆæ–°çš„token
        self.generate_token(&claims.sub, claims.roles, claims.permissions)
    }
}

// ç”¨æˆ·è®¤è¯ä¸­é—´ä»¶
pub struct AuthMiddleware {
    auth_service: JwtAuthService,
    user_service: Arc<dyn UserService>,
}

impl AuthMiddleware {
    pub fn new(auth_service: JwtAuthService, user_service: Arc<dyn UserService>) -> Self {
        Self {
            auth_service,
            user_service,
        }
    }
    
    pub async fn authenticate(&self, token: &str) -> Result<AuthenticatedUser, AuthError> {
        // éªŒè¯JWT token
        let claims = self.auth_service.validate_token(token)
            .map_err(|_| AuthError::InvalidToken)?;
        
        // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨ä¸”æ´»è·ƒ
        let user = self.user_service.get_user(&claims.sub).await
            .map_err(|_| AuthError::UserNotFound)?;
        
        if !user.is_active {
            return Err(AuthError::UserInactive);
        }
        
        Ok(AuthenticatedUser {
            id: user.id,
            username: user.username,
            roles: claims.roles,
            permissions: claims.permissions,
        })
    }
}

#[derive(Debug)]
pub struct AuthenticatedUser {
    pub id: String,
    pub username: String,
    pub roles: Vec<String>,
    pub permissions: Vec<String>,
}

#[derive(Debug)]
pub enum AuthError {
    InvalidToken,
    UserNotFound,
    UserInactive,
    InsufficientPermissions,
}
```

### 2. RBACæƒé™æ§åˆ¶

```rust
use std::collections::HashMap;
use std::sync::Arc;

// è§’è‰²å®šä¹‰
#[derive(Debug, Clone, PartialEq)]
pub enum Role {
    Admin,
    User,
    Guest,
    Moderator,
}

// æƒé™å®šä¹‰
#[derive(Debug, Clone, PartialEq)]
pub enum Permission {
    ReadUsers,
    WriteUsers,
    DeleteUsers,
    ReadOrders,
    WriteOrders,
    DeleteOrders,
    AdminAccess,
}

// è§’è‰²æƒé™æ˜ å°„
pub struct RoleBasedAccessControl {
    role_permissions: HashMap<Role, Vec<Permission>>,
}

impl RoleBasedAccessControl {
    pub fn new() -> Self {
        let mut role_permissions = HashMap::new();
        
        // ç®¡ç†å‘˜æƒé™
        role_permissions.insert(Role::Admin, vec![
            Permission::ReadUsers,
            Permission::WriteUsers,
            Permission::DeleteUsers,
            Permission::ReadOrders,
            Permission::WriteOrders,
            Permission::DeleteOrders,
            Permission::AdminAccess,
        ]);
        
        // ç”¨æˆ·æƒé™
        role_permissions.insert(Role::User, vec![
            Permission::ReadUsers,
            Permission::ReadOrders,
            Permission::WriteOrders,
        ]);
        
        // è®¿å®¢æƒé™
        role_permissions.insert(Role::Guest, vec![
            Permission::ReadUsers,
        ]);
        
        // ç‰ˆä¸»æƒé™
        role_permissions.insert(Role::Moderator, vec![
            Permission::ReadUsers,
            Permission::WriteUsers,
            Permission::ReadOrders,
            Permission::WriteOrders,
        ]);
        
        Self { role_permissions }
    }
    
    pub fn has_permission(&self, role: &Role, permission: &Permission) -> bool {
        self.role_permissions
            .get(role)
            .map(|permissions| permissions.contains(permission))
            .unwrap_or(false)
    }
    
    pub fn get_permissions(&self, role: &Role) -> Vec<Permission> {
        self.role_permissions
            .get(role)
            .cloned()
            .unwrap_or_default()
    }
}

// æƒé™æ£€æŸ¥ä¸­é—´ä»¶
pub struct PermissionMiddleware {
    rbac: RoleBasedAccessControl,
}

impl PermissionMiddleware {
    pub fn new() -> Self {
        Self {
            rbac: RoleBasedAccessControl::new(),
        }
    }
    
    pub fn check_permission(&self, user: &AuthenticatedUser, required_permission: &Permission) -> Result<(), AuthError> {
        for role_str in &user.roles {
            let role = self.parse_role(role_str)?;
            if self.rbac.has_permission(&role, required_permission) {
                return Ok(());
            }
        }
        
        Err(AuthError::InsufficientPermissions)
    }
    
    fn parse_role(&self, role_str: &str) -> Result<Role, AuthError> {
        match role_str {
            "admin" => Ok(Role::Admin),
            "user" => Ok(Role::User),
            "guest" => Ok(Role::Guest),
            "moderator" => Ok(Role::Moderator),
            _ => Err(AuthError::InvalidToken),
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
pub async fn protected_endpoint(
    user: AuthenticatedUser,
    permission_middleware: PermissionMiddleware,
) -> Result<String, AuthError> {
    // æ£€æŸ¥æƒé™
    permission_middleware.check_permission(&user, &Permission::WriteUsers)?;
    
    // æ‰§è¡Œä¸šåŠ¡é€»è¾‘
    Ok("Access granted".to_string())
}
```

### 3. OAuth2é›†æˆ

```rust
use oauth2::{
    AuthorizationCode, AuthUrl, ClientId, ClientSecret, CsrfToken, RedirectUrl, Scope,
    TokenResponse, TokenUrl,
};
use oauth2::basic::BasicClient;
use oauth2::reqwest::async_http_client;

// OAuth2å®¢æˆ·ç«¯é…ç½®
pub struct OAuth2Service {
    client: BasicClient,
    redirect_url: String,
}

impl OAuth2Service {
    pub fn new(
        client_id: String,
        client_secret: String,
        auth_url: String,
        token_url: String,
        redirect_url: String,
    ) -> Self {
        let client = BasicClient::new(
            ClientId::new(client_id),
            Some(ClientSecret::new(client_secret)),
            AuthUrl::new(auth_url).unwrap(),
            Some(TokenUrl::new(token_url).unwrap()),
        )
        .set_redirect_uri(RedirectUrl::new(redirect_url.clone()).unwrap());
        
        Self {
            client,
            redirect_url,
        }
    }
    
    pub fn get_authorization_url(&self) -> (String, CsrfToken) {
        self.client
            .authorize_url(CsrfToken::new_random)
            .add_scope(Scope::new("read".to_string()))
            .add_scope(Scope::new("write".to_string()))
            .url()
    }
    
    pub async fn exchange_code(&self, code: String) -> Result<String, Box<dyn std::error::Error>> {
        let token = self.client
            .exchange_code(AuthorizationCode::new(code))
            .request_async(async_http_client)
            .await?;
        
        Ok(token.access_token().secret().clone())
    }
    
    pub async fn get_user_info(&self, access_token: &str) -> Result<UserInfo, Box<dyn std::error::Error>> {
        let client = reqwest::Client::new();
        let response = client
            .get("https://api.github.com/user")
            .bearer_auth(access_token)
            .send()
            .await?;
        
        let user_info: UserInfo = response.json().await?;
        Ok(user_info)
    }
}

#[derive(Debug, Deserialize)]
pub struct UserInfo {
    pub id: u64,
    pub login: String,
    pub email: Option<String>,
    pub name: Option<String>,
    pub avatar_url: Option<String>,
}
```

## ğŸ”’ æ•°æ®åŠ å¯†ä¸ä¿æŠ¤

### 1. æ•°æ®åŠ å¯†æœåŠ¡

```rust
use aes_gcm::{Aes256Gcm, Key, Nonce};
use aes_gcm::aead::{Aead, NewAead};
use argon2::{Argon2, PasswordHash, PasswordHasher, PasswordVerifier};
use argon2::password_hash::{rand_core::OsRng, SaltString};
use rand::Rng;

// åŠ å¯†æœåŠ¡
pub struct EncryptionService {
    cipher: Aes256Gcm,
}

impl EncryptionService {
    pub fn new(key: &[u8; 32]) -> Self {
        let key = Key::from_slice(key);
        let cipher = Aes256Gcm::new(key);
        
        Self { cipher }
    }
    
    pub fn encrypt(&self, plaintext: &[u8]) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        let nonce = self.generate_nonce();
        let ciphertext = self.cipher.encrypt(&nonce, plaintext)
            .map_err(|e| format!("Encryption failed: {}", e))?;
        
        // å°†nonceå’Œå¯†æ–‡ç»„åˆ
        let mut result = nonce.to_vec();
        result.extend_from_slice(&ciphertext);
        Ok(result)
    }
    
    pub fn decrypt(&self, ciphertext: &[u8]) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        if ciphertext.len() < 12 {
            return Err("Invalid ciphertext length".into());
        }
        
        let (nonce_bytes, encrypted_data) = ciphertext.split_at(12);
        let nonce = Nonce::from_slice(nonce_bytes);
        
        let plaintext = self.cipher.decrypt(nonce, encrypted_data)
            .map_err(|e| format!("Decryption failed: {}", e))?;
        
        Ok(plaintext)
    }
    
    fn generate_nonce(&self) -> Nonce {
        let mut nonce_bytes = [0u8; 12];
        OsRng.fill(&mut nonce_bytes);
        Nonce::from_slice(&nonce_bytes)
    }
}

// å¯†ç å“ˆå¸ŒæœåŠ¡
pub struct PasswordService;

impl PasswordService {
    pub fn hash_password(password: &str) -> Result<String, Box<dyn std::error::Error>> {
        let salt = SaltString::generate(&mut OsRng);
        let argon2 = Argon2::default();
        
        let password_hash = argon2
            .hash_password(password.as_bytes(), &salt)
            .map_err(|e| format!("Password hashing failed: {}", e))?;
        
        Ok(password_hash.to_string())
    }
    
    pub fn verify_password(password: &str, hash: &str) -> Result<bool, Box<dyn std::error::Error>> {
        let parsed_hash = PasswordHash::new(hash)
            .map_err(|e| format!("Invalid password hash: {}", e))?;
        
        let argon2 = Argon2::default();
        let result = argon2.verify_password(password.as_bytes(), &parsed_hash);
        
        Ok(result.is_ok())
    }
}

// æ•æ„Ÿæ•°æ®ä¿æŠ¤
pub struct SensitiveDataProtection {
    encryption_service: EncryptionService,
}

impl SensitiveDataProtection {
    pub fn new(encryption_key: &[u8; 32]) -> Self {
        Self {
            encryption_service: EncryptionService::new(encryption_key),
        }
    }
    
    pub fn protect_pii(&self, data: &str) -> Result<String, Box<dyn std::error::Error>> {
        let encrypted = self.encryption_service.encrypt(data.as_bytes())?;
        Ok(base64::encode(encrypted))
    }
    
    pub fn unprotect_pii(&self, protected_data: &str) -> Result<String, Box<dyn std::error::Error>> {
        let encrypted = base64::decode(protected_data)?;
        let decrypted = self.encryption_service.decrypt(&encrypted)?;
        Ok(String::from_utf8(decrypted)?)
    }
    
    pub fn mask_email(&self, email: &str) -> String {
        if let Some(at_pos) = email.find('@') {
            let (username, domain) = email.split_at(at_pos);
            let masked_username = if username.len() > 2 {
                format!("{}***{}", &username[..1], &username[username.len()-1..])
            } else {
                "***".to_string()
            };
            format!("{}@{}", masked_username, domain)
        } else {
            "***".to_string()
        }
    }
    
    pub fn mask_phone(&self, phone: &str) -> String {
        if phone.len() > 4 {
            format!("***-***-{}", &phone[phone.len()-4..])
        } else {
            "***".to_string()
        }
    }
}
```

### 2. å¯†é’¥ç®¡ç†

```rust
use std::sync::Arc;
use tokio::sync::RwLock;
use std::time::{Duration, Instant};

// å¯†é’¥ç®¡ç†å™¨
pub struct KeyManager {
    keys: Arc<RwLock<HashMap<String, KeyInfo>>>,
    rotation_interval: Duration,
}

#[derive(Debug, Clone)]
pub struct KeyInfo {
    pub key: Vec<u8>,
    pub created_at: Instant,
    pub expires_at: Instant,
    pub version: u32,
}

impl KeyManager {
    pub fn new(rotation_interval: Duration) -> Self {
        Self {
            keys: Arc::new(RwLock::new(HashMap::new())),
            rotation_interval,
        }
    }
    
    pub async fn generate_key(&self, key_id: String) -> Result<(), Box<dyn std::error::Error>> {
        let mut key_bytes = [0u8; 32];
        OsRng.fill(&mut key_bytes);
        
        let key_info = KeyInfo {
            key: key_bytes.to_vec(),
            created_at: Instant::now(),
            expires_at: Instant::now() + self.rotation_interval,
            version: 1,
        };
        
        let mut keys = self.keys.write().await;
        keys.insert(key_id, key_info);
        
        Ok(())
    }
    
    pub async fn get_key(&self, key_id: &str) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        let keys = self.keys.read().await;
        let key_info = keys.get(key_id)
            .ok_or("Key not found")?;
        
        if key_info.expires_at < Instant::now() {
            return Err("Key expired".into());
        }
        
        Ok(key_info.key.clone())
    }
    
    pub async fn rotate_key(&self, key_id: &str) -> Result<(), Box<dyn std::error::Error>> {
        let mut keys = self.keys.write().await;
        
        if let Some(key_info) = keys.get_mut(key_id) {
            let mut new_key_bytes = [0u8; 32];
            OsRng.fill(&mut new_key_bytes);
            
            key_info.key = new_key_bytes.to_vec();
            key_info.created_at = Instant::now();
            key_info.expires_at = Instant::now() + self.rotation_interval;
            key_info.version += 1;
        }
        
        Ok(())
    }
    
    pub async fn cleanup_expired_keys(&self) {
        let mut keys = self.keys.write().await;
        keys.retain(|_, key_info| key_info.expires_at > Instant::now());
    }
}

// å¯†é’¥è½®æ¢ä»»åŠ¡
pub struct KeyRotationTask {
    key_manager: Arc<KeyManager>,
    interval: Duration,
}

impl KeyRotationTask {
    pub fn new(key_manager: Arc<KeyManager>, interval: Duration) -> Self {
        Self {
            key_manager,
            interval,
        }
    }
    
    pub async fn start(&self) {
        let mut interval = tokio::time::interval(self.interval);
        
        loop {
            interval.tick().await;
            
            // æ¸…ç†è¿‡æœŸå¯†é’¥
            self.key_manager.cleanup_expired_keys().await;
            
            // è½®æ¢å³å°†è¿‡æœŸçš„å¯†é’¥
            // è¿™é‡Œå¯ä»¥æ·»åŠ å…·ä½“çš„è½®æ¢é€»è¾‘
        }
    }
}
```

## ğŸ›¡ï¸ è¾“å…¥éªŒè¯ä¸é˜²æŠ¤

### 1. è¾“å…¥éªŒè¯æ¡†æ¶

```rust
use serde::{Deserialize, Serialize};
use validator::{Validate, ValidationError};
use regex::Regex;

// è‡ªå®šä¹‰éªŒè¯å™¨
pub fn validate_strong_password(password: &str) -> Result<(), ValidationError> {
    if password.len() < 8 {
        return Err(ValidationError::new("password_too_short"));
    }
    
    if !password.chars().any(|c| c.is_uppercase()) {
        return Err(ValidationError::new("password_no_uppercase"));
    }
    
    if !password.chars().any(|c| c.is_lowercase()) {
        return Err(ValidationError::new("password_no_lowercase"));
    }
    
    if !password.chars().any(|c| c.is_numeric()) {
        return Err(ValidationError::new("password_no_number"));
    }
    
    if !password.chars().any(|c| "!@#$%^&*()_+-=[]{}|;:,.<>?".contains(c)) {
        return Err(ValidationError::new("password_no_special_char"));
    }
    
    Ok(())
}

pub fn validate_email(email: &str) -> Result<(), ValidationError> {
    let email_regex = Regex::new(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$")
        .map_err(|_| ValidationError::new("invalid_regex"))?;
    
    if !email_regex.is_match(email) {
        return Err(ValidationError::new("invalid_email"));
    }
    
    Ok(())
}

// ç”¨æˆ·æ³¨å†Œè¯·æ±‚éªŒè¯
#[derive(Debug, Deserialize, Validate)]
pub struct UserRegistrationRequest {
    #[validate(length(min = 3, max = 50, message = "ç”¨æˆ·åé•¿åº¦å¿…é¡»åœ¨3-50ä¸ªå­—ç¬¦ä¹‹é—´"))]
    pub username: String,
    
    #[validate(custom = "validate_email")]
    pub email: String,
    
    #[validate(custom = "validate_strong_password")]
    pub password: String,
    
    #[validate(length(min = 2, max = 100, message = "å§“åé•¿åº¦å¿…é¡»åœ¨2-100ä¸ªå­—ç¬¦ä¹‹é—´"))]
    pub full_name: String,
    
    #[validate(range(min = 13, max = 120, message = "å¹´é¾„å¿…é¡»åœ¨13-120å²ä¹‹é—´"))]
    pub age: u8,
}

// è¾“å…¥æ¸…ç†å™¨
pub struct InputSanitizer;

impl InputSanitizer {
    pub fn sanitize_string(input: &str) -> String {
        input
            .trim()
            .chars()
            .filter(|c| !c.is_control())
            .collect()
    }
    
    pub fn sanitize_html(input: &str) -> String {
        // ç§»é™¤HTMLæ ‡ç­¾
        let html_regex = Regex::new(r"<[^>]*>").unwrap();
        html_regex.replace_all(input, "").to_string()
    }
    
    pub fn sanitize_sql(input: &str) -> String {
        // åŸºæœ¬çš„SQLæ³¨å…¥é˜²æŠ¤
        input
            .replace("'", "''")
            .replace(";", "")
            .replace("--", "")
            .replace("/*", "")
            .replace("*/", "")
    }
    
    pub fn sanitize_path(input: &str) -> String {
        // è·¯å¾„éå†æ”»å‡»é˜²æŠ¤
        input
            .replace("../", "")
            .replace("..\\", "")
            .replace("/", "_")
            .replace("\\", "_")
    }
}

// è¯·æ±‚éªŒè¯ä¸­é—´ä»¶
pub struct ValidationMiddleware;

impl ValidationMiddleware {
    pub async fn validate_request<T>(request: &T) -> Result<(), ValidationError>
    where
        T: Validate,
    {
        request.validate()
    }
    
    pub fn sanitize_input(input: &str, input_type: InputType) -> String {
        match input_type {
            InputType::String => InputSanitizer::sanitize_string(input),
            InputType::Html => InputSanitizer::sanitize_html(input),
            InputType::Sql => InputSanitizer::sanitize_sql(input),
            InputType::Path => InputSanitizer::sanitize_path(input),
        }
    }
}

#[derive(Debug)]
pub enum InputType {
    String,
    Html,
    Sql,
    Path,
}
```

### 2. é€Ÿç‡é™åˆ¶

```rust
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::RwLock;
use std::collections::HashMap;

// ä»¤ç‰Œæ¡¶ç®—æ³•
pub struct TokenBucket {
    capacity: u32,
    tokens: u32,
    last_refill: Instant,
    refill_rate: u32, // tokens per second
}

impl TokenBucket {
    pub fn new(capacity: u32, refill_rate: u32) -> Self {
        Self {
            capacity,
            tokens: capacity,
            last_refill: Instant::now(),
            refill_rate,
        }
    }
    
    pub fn try_consume(&mut self, tokens: u32) -> bool {
        self.refill();
        
        if self.tokens >= tokens {
            self.tokens -= tokens;
            true
        } else {
            false
        }
    }
    
    fn refill(&mut self) {
        let now = Instant::now();
        let elapsed = now.duration_since(self.last_refill);
        let tokens_to_add = (elapsed.as_secs() as u32 * self.refill_rate)
            + (elapsed.subsec_millis() as u32 * self.refill_rate / 1000);
        
        self.tokens = (self.tokens + tokens_to_add).min(self.capacity);
        self.last_refill = now;
    }
}

// é€Ÿç‡é™åˆ¶å™¨
pub struct RateLimiter {
    buckets: Arc<RwLock<HashMap<String, TokenBucket>>>,
    default_capacity: u32,
    default_refill_rate: u32,
}

impl RateLimiter {
    pub fn new(default_capacity: u32, default_refill_rate: u32) -> Self {
        Self {
            buckets: Arc::new(RwLock::new(HashMap::new())),
            default_capacity,
            default_refill_rate,
        }
    }
    
    pub async fn is_allowed(&self, key: &str, tokens: u32) -> bool {
        let mut buckets = self.buckets.write().await;
        
        let bucket = buckets.entry(key.to_string()).or_insert_with(|| {
            TokenBucket::new(self.default_capacity, self.default_refill_rate)
        });
        
        bucket.try_consume(tokens)
    }
    
    pub async fn is_allowed_with_custom_limit(
        &self,
        key: &str,
        tokens: u32,
        capacity: u32,
        refill_rate: u32,
    ) -> bool {
        let mut buckets = self.buckets.write().await;
        
        let bucket = buckets.entry(key.to_string()).or_insert_with(|| {
            TokenBucket::new(capacity, refill_rate)
        });
        
        bucket.try_consume(tokens)
    }
}

// é€Ÿç‡é™åˆ¶ä¸­é—´ä»¶
pub struct RateLimitMiddleware {
    rate_limiter: Arc<RateLimiter>,
}

impl RateLimitMiddleware {
    pub fn new(rate_limiter: Arc<RateLimiter>) -> Self {
        Self { rate_limiter }
    }
    
    pub async fn check_rate_limit(&self, client_ip: &str, endpoint: &str) -> Result<(), RateLimitError> {
        let key = format!("{}:{}", client_ip, endpoint);
        
        if self.rate_limiter.is_allowed(&key, 1).await {
            Ok(())
        } else {
            Err(RateLimitError::TooManyRequests)
        }
    }
}

#[derive(Debug)]
pub enum RateLimitError {
    TooManyRequests,
}
```

## ğŸ” å®‰å…¨ç›‘æ§ä¸å®¡è®¡

### 1. å®‰å…¨äº‹ä»¶ç›‘æ§

```rust
use serde::{Deserialize, Serialize};
use std::time::SystemTime;
use tokio::sync::mpsc;

// å®‰å…¨äº‹ä»¶ç±»å‹
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SecurityEvent {
    LoginAttempt {
        user_id: Option<String>,
        ip_address: String,
        success: bool,
        timestamp: SystemTime,
    },
    PermissionDenied {
        user_id: String,
        resource: String,
        action: String,
        timestamp: SystemTime,
    },
    SuspiciousActivity {
        user_id: String,
        activity_type: String,
        details: String,
        timestamp: SystemTime,
    },
    DataAccess {
        user_id: String,
        data_type: String,
        access_type: String,
        timestamp: SystemTime,
    },
}

// å®‰å…¨ç›‘æ§å™¨
pub struct SecurityMonitor {
    event_sender: mpsc::UnboundedSender<SecurityEvent>,
    alert_thresholds: AlertThresholds,
}

#[derive(Debug, Clone)]
pub struct AlertThresholds {
    pub max_failed_logins: u32,
    pub max_permission_denials: u32,
    pub max_suspicious_activities: u32,
    pub time_window: Duration,
}

impl SecurityMonitor {
    pub fn new() -> (Self, mpsc::UnboundedReceiver<SecurityEvent>) {
        let (sender, receiver) = mpsc::unbounded_channel();
        
        let monitor = Self {
            event_sender: sender,
            alert_thresholds: AlertThresholds {
                max_failed_logins: 5,
                max_permission_denials: 10,
                max_suspicious_activities: 3,
                time_window: Duration::from_secs(300), // 5åˆ†é’Ÿ
            },
        };
        
        (monitor, receiver)
    }
    
    pub fn record_event(&self, event: SecurityEvent) -> Result<(), Box<dyn std::error::Error>> {
        self.event_sender.send(event)?;
        Ok(())
    }
    
    pub async fn start_monitoring(&self, mut receiver: mpsc::UnboundedReceiver<SecurityEvent>) {
        let mut event_counts: HashMap<String, Vec<SystemTime>> = HashMap::new();
        
        while let Some(event) = receiver.recv().await {
            self.process_event(&event, &mut event_counts).await;
        }
    }
    
    async fn process_event(
        &self,
        event: &SecurityEvent,
        event_counts: &mut HashMap<String, Vec<SystemTime>>,
    ) {
        let key = self.get_event_key(event);
        let now = SystemTime::now();
        
        // æ¸…ç†è¿‡æœŸäº‹ä»¶
        if let Some(times) = event_counts.get_mut(&key) {
            times.retain(|&time| now.duration_since(time).unwrap_or_default() < self.alert_thresholds.time_window);
        }
        
        // æ·»åŠ å½“å‰äº‹ä»¶
        event_counts.entry(key).or_insert_with(Vec::new).push(now);
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦å‘Šè­¦
        if self.should_alert(event, event_counts) {
            self.send_alert(event).await;
        }
    }
    
    fn get_event_key(&self, event: &SecurityEvent) -> String {
        match event {
            SecurityEvent::LoginAttempt { user_id, ip_address, .. } => {
                format!("login:{}:{}", user_id.as_deref().unwrap_or("unknown"), ip_address)
            }
            SecurityEvent::PermissionDenied { user_id, .. } => {
                format!("permission:{}", user_id)
            }
            SecurityEvent::SuspiciousActivity { user_id, .. } => {
                format!("suspicious:{}", user_id)
            }
            SecurityEvent::DataAccess { user_id, .. } => {
                format!("data_access:{}", user_id)
            }
        }
    }
    
    fn should_alert(&self, event: &SecurityEvent, event_counts: &HashMap<String, Vec<SystemTime>>) -> bool {
        let key = self.get_event_key(event);
        let count = event_counts.get(&key).map(|v| v.len()).unwrap_or(0);
        
        match event {
            SecurityEvent::LoginAttempt { success: false, .. } => {
                count >= self.alert_thresholds.max_failed_logins as usize
            }
            SecurityEvent::PermissionDenied { .. } => {
                count >= self.alert_thresholds.max_permission_denials as usize
            }
            SecurityEvent::SuspiciousActivity { .. } => {
                count >= self.alert_thresholds.max_suspicious_activities as usize
            }
            _ => false,
        }
    }
    
    async fn send_alert(&self, event: &SecurityEvent) {
        // å‘é€å®‰å…¨å‘Šè­¦
        tracing::warn!("Security alert: {:?}", event);
        
        // è¿™é‡Œå¯ä»¥é›†æˆé‚®ä»¶ã€çŸ­ä¿¡ã€Slackç­‰å‘Šè­¦æ–¹å¼
    }
}
```

### 2. å®¡è®¡æ—¥å¿—

```rust
use serde::{Deserialize, Serialize};
use std::time::SystemTime;

// å®¡è®¡æ—¥å¿—æ¡ç›®
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuditLogEntry {
    pub id: String,
    pub timestamp: SystemTime,
    pub user_id: Option<String>,
    pub action: String,
    pub resource: String,
    pub result: AuditResult,
    pub ip_address: Option<String>,
    pub user_agent: Option<String>,
    pub details: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AuditResult {
    Success,
    Failure,
    Denied,
}

// å®¡è®¡æ—¥å¿—æœåŠ¡
pub struct AuditLogger {
    log_sender: mpsc::UnboundedSender<AuditLogEntry>,
}

impl AuditLogger {
    pub fn new() -> (Self, mpsc::UnboundedReceiver<AuditLogEntry>) {
        let (sender, receiver) = mpsc::unbounded_channel();
        
        let logger = Self {
            log_sender: sender,
        };
        
        (logger, receiver)
    }
    
    pub fn log_action(
        &self,
        user_id: Option<String>,
        action: String,
        resource: String,
        result: AuditResult,
        ip_address: Option<String>,
        user_agent: Option<String>,
        details: serde_json::Value,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let entry = AuditLogEntry {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: SystemTime::now(),
            user_id,
            action,
            resource,
            result,
            ip_address,
            user_agent,
            details,
        };
        
        self.log_sender.send(entry)?;
        Ok(())
    }
    
    pub async fn start_logging(&self, mut receiver: mpsc::UnboundedReceiver<AuditLogEntry>) {
        while let Some(entry) = receiver.recv().await {
            self.write_log_entry(entry).await;
        }
    }
    
    async fn write_log_entry(&self, entry: AuditLogEntry) {
        // å†™å…¥å®¡è®¡æ—¥å¿—
        let log_line = serde_json::to_string(&entry).unwrap_or_default();
        tracing::info!("AUDIT: {}", log_line);
        
        // è¿™é‡Œå¯ä»¥å†™å…¥æ•°æ®åº“ã€æ–‡ä»¶æˆ–å…¶ä»–å­˜å‚¨ç³»ç»Ÿ
    }
}

// å®¡è®¡ä¸­é—´ä»¶
pub struct AuditMiddleware {
    audit_logger: Arc<AuditLogger>,
}

impl AuditMiddleware {
    pub fn new(audit_logger: Arc<AuditLogger>) -> Self {
        Self { audit_logger }
    }
    
    pub async fn log_request(
        &self,
        user_id: Option<String>,
        method: &str,
        path: &str,
        status_code: u16,
        ip_address: Option<String>,
        user_agent: Option<String>,
    ) {
        let action = format!("{} {}", method, path);
        let result = if status_code < 400 {
            AuditResult::Success
        } else if status_code == 403 {
            AuditResult::Denied
        } else {
            AuditResult::Failure
        };
        
        let details = serde_json::json!({
            "status_code": status_code,
            "method": method,
            "path": path
        });
        
        let _ = self.audit_logger.log_action(
            user_id,
            action,
            path.to_string(),
            result,
            ip_address,
            user_agent,
            details,
        );
    }
}
```

## ğŸš€ éƒ¨ç½²å®‰å…¨

### 1. å®¹å™¨å®‰å…¨

```dockerfile
# å®‰å…¨ä¼˜åŒ–çš„Dockerfile
FROM rust:1.90-slim as builder

# åˆ›å»ºérootç”¨æˆ·
RUN groupadd -r builder && useradd -r -g builder builder
USER builder

# è®¾ç½®å®‰å…¨çš„ç¯å¢ƒå˜é‡
ENV RUSTFLAGS="-C target-cpu=native -C opt-level=3"
ENV CARGO_INCREMENTAL=0
ENV CARGO_PROFILE_RELEASE_LTO=true
ENV CARGO_PROFILE_RELEASE_CODEGEN_UNITS=1

# æ„å»ºé…ç½®
WORKDIR /home/builder/app
COPY --chown=builder:builder Cargo.toml Cargo.lock ./
RUN cargo build --release --locked

COPY --chown=builder:builder src ./src
RUN touch src/main.rs && cargo build --release --locked

# è¿è¡Œé˜¶æ®µ
FROM gcr.io/distroless/cc-debian12

# å¤åˆ¶äºŒè¿›åˆ¶æ–‡ä»¶
COPY --from=builder /home/builder/app/target/release/microservice-server /app/

# ä½¿ç”¨éç‰¹æƒç”¨æˆ·
USER 65534:65534

# æš´éœ²ç«¯å£
EXPOSE 8080

# å¯åŠ¨å‘½ä»¤
ENTRYPOINT ["/app/microservice-server"]
```

### 2. å®‰å…¨é…ç½®

```yaml
# Kuberneteså®‰å…¨é…ç½®
apiVersion: v1
kind: Pod
metadata:
  name: microservice
spec:
  securityContext:
    runAsNonRoot: true
    runAsUser: 65534
    runAsGroup: 65534
    fsGroup: 65534
    seccompProfile:
      type: RuntimeDefault
  containers:
  - name: microservice
    image: microservice:latest
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      capabilities:
        drop:
        - ALL
    resources:
      requests:
        memory: "256Mi"
        cpu: "250m"
      limits:
        memory: "512Mi"
        cpu: "500m"
    volumeMounts:
    - name: tmp
      mountPath: /tmp
    - name: var-tmp
      mountPath: /var/tmp
  volumes:
  - name: tmp
    emptyDir: {}
  - name: var-tmp
    emptyDir: {}
```

## ğŸ“š æœ€ä½³å®è·µæ€»ç»“

### 1. å®‰å…¨è®¾è®¡åŸåˆ™

- **é›¶ä¿¡ä»»æ¶æ„**: æ°¸ä¸ä¿¡ä»»ï¼Œå§‹ç»ˆéªŒè¯
- **æœ€å°æƒé™åŸåˆ™**: åªæˆäºˆå¿…è¦çš„æƒé™
- **æ·±åº¦é˜²å¾¡**: å¤šå±‚å®‰å…¨é˜²æŠ¤
- **å®‰å…¨å·¦ç§»**: åœ¨å¼€å‘é˜¶æ®µé›†æˆå®‰å…¨

### 2. å…³é”®å®‰å…¨æªæ–½

- **èº«ä»½è®¤è¯**: ä½¿ç”¨JWTå’ŒOAuth2
- **æˆæƒæ§åˆ¶**: å®ç°RBACæƒé™æ¨¡å‹
- **æ•°æ®ä¿æŠ¤**: åŠ å¯†æ•æ„Ÿæ•°æ®
- **è¾“å…¥éªŒè¯**: ä¸¥æ ¼éªŒè¯æ‰€æœ‰è¾“å…¥
- **å®‰å…¨ç›‘æ§**: å®æ—¶ç›‘æ§å®‰å…¨äº‹ä»¶

### 3. å®‰å…¨æ£€æŸ¥æ¸…å•

- âœ… ä½¿ç”¨HTTPS/TLSåŠ å¯†é€šä¿¡
- âœ… å®ç°å¼ºå¯†ç ç­–ç•¥
- âœ… å¯ç”¨å¤šå› ç´ è®¤è¯
- âœ… å®šæœŸè½®æ¢å¯†é’¥
- âœ… å®æ–½é€Ÿç‡é™åˆ¶
- âœ… è®°å½•å®¡è®¡æ—¥å¿—
- âœ… ç›‘æ§å®‰å…¨äº‹ä»¶
- âœ… å®šæœŸå®‰å…¨æ‰«æ

### 4. åº”æ€¥å“åº”

- **äº‹ä»¶æ£€æµ‹**: å®æ—¶ç›‘æ§å¼‚å¸¸æ´»åŠ¨
- **äº‹ä»¶å“åº”**: å¿«é€Ÿéš”ç¦»å’Œä¿®å¤
- **äº‹ä»¶åˆ†æ**: æ·±å…¥åˆ†ææ”»å‡»æ¨¡å¼
- **äº‹ä»¶æ¢å¤**: å¿«é€Ÿæ¢å¤æœåŠ¡
- **äº‹ä»¶æ€»ç»“**: æ€»ç»“ç»éªŒæ•™è®­

## ğŸ”— ç›¸å…³èµ„æº

- [OWASPå®‰å…¨æŒ‡å—](https://owasp.org/)
- [Rustå®‰å…¨æœ€ä½³å®è·µ](https://doc.rust-lang.org/book/ch00-00-introduction.html)
- [JWTå®˜æ–¹æ–‡æ¡£](https://jwt.io/)
- [OAuth2è§„èŒƒ](https://oauth.net/2/)

---

**æ³¨æ„**: æœ¬æ–‡æ¡£åŸºäº2025å¹´9æœˆçš„æœ€æ–°æŠ€æœ¯æ ˆï¼Œå»ºè®®å®šæœŸæ›´æ–°ä»¥ä¿æŒæ—¶æ•ˆæ€§ã€‚
