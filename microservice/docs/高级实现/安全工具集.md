# 安全工具集

## 概述

本文档提供了完整的微服务安全工具集，包括安全扫描、漏洞检测、威胁防护、安全监控等工具。这些工具帮助开发者构建安全可靠的微服务系统，保护系统免受各种安全威胁。

## 学习目标

- 掌握微服务安全的基本原理和最佳实践
- 学习使用各种安全扫描和检测工具
- 了解威胁防护和入侵检测技术
- 掌握安全监控和事件响应方法

## 1. 安全扫描工具

### 1.1 代码安全扫描器

```rust
// 代码安全扫描器
use std::collections::HashMap;
use std::path::Path;
use regex::Regex;

pub struct CodeSecurityScanner {
    rules: Vec<SecurityRule>,
    results: Arc<RwLock<Vec<SecurityIssue>>>,
}

#[derive(Debug, Clone)]
pub struct SecurityRule {
    pub id: String,
    pub name: String,
    pub description: String,
    pub severity: Severity,
    pub pattern: Regex,
    pub category: SecurityCategory,
}

#[derive(Debug, Clone)]
pub enum Severity {
    Low,
    Medium,
    High,
    Critical,
}

#[derive(Debug, Clone)]
pub enum SecurityCategory {
    Injection,
    Authentication,
    Authorization,
    DataExposure,
    Cryptography,
    InputValidation,
    ErrorHandling,
}

#[derive(Debug, Clone)]
pub struct SecurityIssue {
    pub rule_id: String,
    pub file_path: String,
    pub line_number: usize,
    pub column: usize,
    pub severity: Severity,
    pub description: String,
    pub recommendation: String,
}

impl CodeSecurityScanner {
    pub fn new() -> Self {
        let mut scanner = Self {
            rules: Vec::new(),
            results: Arc::new(RwLock::new(Vec::new())),
        };
        
        // 加载默认安全规则
        scanner.load_default_rules();
        scanner
    }
    
    fn load_default_rules(&mut self) {
        // SQL注入检测规则
        self.rules.push(SecurityRule {
            id: "SQL_INJECTION_001".to_string(),
            name: "SQL Injection Vulnerability".to_string(),
            description: "Potential SQL injection vulnerability detected".to_string(),
            severity: Severity::High,
            pattern: Regex::new(r"format!\s*\(\s*[\"']\s*SELECT.*\{\}").unwrap(),
            category: SecurityCategory::Injection,
        });
        
        // 硬编码密码检测规则
        self.rules.push(SecurityRule {
            id: "HARDCODED_PASSWORD_001".to_string(),
            name: "Hardcoded Password".to_string(),
            description: "Hardcoded password detected in source code".to_string(),
            severity: Severity::Critical,
            pattern: Regex::new(r"password\s*=\s*[\"'][^\"']+[\"']").unwrap(),
            category: SecurityCategory::Authentication,
        });
        
        // 不安全的随机数生成
        self.rules.push(SecurityRule {
            id: "INSECURE_RANDOM_001".to_string(),
            name: "Insecure Random Number Generation".to_string(),
            description: "Insecure random number generation detected".to_string(),
            severity: Severity::Medium,
            pattern: Regex::new(r"rand::random\(\)").unwrap(),
            category: SecurityCategory::Cryptography,
        });
        
        // 敏感数据暴露
        self.rules.push(SecurityRule {
            id: "DATA_EXPOSURE_001".to_string(),
            name: "Sensitive Data Exposure".to_string(),
            description: "Potential sensitive data exposure".to_string(),
            severity: Severity::High,
            pattern: Regex::new(r"println!\s*\(\s*[\"']\s*.*password.*[\"']").unwrap(),
            category: SecurityCategory::DataExposure,
        });
        
        // 不安全的HTTP连接
        self.rules.push(SecurityRule {
            id: "INSECURE_HTTP_001".to_string(),
            name: "Insecure HTTP Connection".to_string(),
            description: "Insecure HTTP connection detected".to_string(),
            severity: Severity::Medium,
            pattern: Regex::new(r"http://").unwrap(),
            category: SecurityCategory::DataExposure,
        });
    }
    
    pub async fn scan_directory(&self, path: &Path) -> Result<Vec<SecurityIssue>, ScanError> {
        let mut issues = Vec::new();
        
        // 遍历目录中的所有Rust文件
        for entry in walkdir::WalkDir::new(path)
            .into_iter()
            .filter_map(|e| e.ok())
            .filter(|e| e.file_type().is_file())
            .filter(|e| e.path().extension().map_or(false, |ext| ext == "rs"))
        {
            let file_issues = self.scan_file(entry.path()).await?;
            issues.extend(file_issues);
        }
        
        // 保存结果
        {
            let mut results = self.results.write().unwrap();
            results.extend(issues.clone());
        }
        
        Ok(issues)
    }
    
    async fn scan_file(&self, file_path: &Path) -> Result<Vec<SecurityIssue>, ScanError> {
        let content = tokio::fs::read_to_string(file_path).await?;
        let mut issues = Vec::new();
        
        for (line_number, line) in content.lines().enumerate() {
            for rule in &self.rules {
                if let Some(mat) = rule.pattern.find(line) {
                    let issue = SecurityIssue {
                        rule_id: rule.id.clone(),
                        file_path: file_path.to_string_lossy().to_string(),
                        line_number: line_number + 1,
                        column: mat.start(),
                        severity: rule.severity.clone(),
                        description: rule.description.clone(),
                        recommendation: self.get_recommendation(&rule.category),
                    };
                    issues.push(issue);
                }
            }
        }
        
        Ok(issues)
    }
    
    fn get_recommendation(&self, category: &SecurityCategory) -> String {
        match category {
            SecurityCategory::Injection => {
                "Use parameterized queries or prepared statements to prevent SQL injection".to_string()
            }
            SecurityCategory::Authentication => {
                "Use environment variables or secure configuration management for sensitive data".to_string()
            }
            SecurityCategory::Authorization => {
                "Implement proper access control and authorization checks".to_string()
            }
            SecurityCategory::DataExposure => {
                "Avoid logging or exposing sensitive information in plain text".to_string()
            }
            SecurityCategory::Cryptography => {
                "Use cryptographically secure random number generators".to_string()
            }
            SecurityCategory::InputValidation => {
                "Implement proper input validation and sanitization".to_string()
            }
            SecurityCategory::ErrorHandling => {
                "Implement secure error handling without exposing sensitive information".to_string()
            }
        }
    }
    
    pub fn get_results(&self) -> Vec<SecurityIssue> {
        self.results.read().unwrap().clone()
    }
    
    pub fn generate_report(&self) -> String {
        let issues = self.get_results();
        let mut report = String::new();
        
        report.push_str("# 安全扫描报告\n\n");
        
        // 统计信息
        let critical_count = issues.iter().filter(|i| matches!(i.severity, Severity::Critical)).count();
        let high_count = issues.iter().filter(|i| matches!(i.severity, Severity::High)).count();
        let medium_count = issues.iter().filter(|i| matches!(i.severity, Severity::Medium)).count();
        let low_count = issues.iter().filter(|i| matches!(i.severity, Severity::Low)).count();
        
        report.push_str(&format!("## 扫描统计\n"));
        report.push_str(&format!("- 严重问题: {}\n", critical_count));
        report.push_str(&format!("- 高危问题: {}\n", high_count));
        report.push_str(&format!("- 中危问题: {}\n", medium_count));
        report.push_str(&format!("- 低危问题: {}\n", low_count));
        report.push_str(&format!("- 总计: {}\n\n", issues.len()));
        
        // 按严重程度分组
        for severity in [Severity::Critical, Severity::High, Severity::Medium, Severity::Low] {
            let severity_issues: Vec<_> = issues.iter()
                .filter(|i| std::mem::discriminant(&i.severity) == std::mem::discriminant(&severity))
                .collect();
            
            if !severity_issues.is_empty() {
                report.push_str(&format!("## {:?} 问题\n", severity));
                
                for issue in severity_issues {
                    report.push_str(&format!("### {}\n", issue.description));
                    report.push_str(&format!("- 文件: {}\n", issue.file_path));
                    report.push_str(&format!("- 行号: {}\n", issue.line_number));
                    report.push_str(&format!("- 建议: {}\n\n", issue.recommendation));
                }
            }
        }
        
        report
    }
}
```

### 1.2 依赖安全扫描器

```rust
// 依赖安全扫描器
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

pub struct DependencySecurityScanner {
    vulnerability_db: Arc<RwLock<HashMap<String, Vulnerability>>>,
    http_client: reqwest::Client,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    pub id: String,
    pub package: String,
    pub version: String,
    pub severity: String,
    pub description: String,
    pub cve_id: Option<String>,
    pub published_date: String,
    pub fixed_version: Option<String>,
}

#[derive(Debug, Clone)]
pub struct DependencyInfo {
    pub name: String,
    pub version: String,
    pub source: String,
    pub vulnerabilities: Vec<Vulnerability>,
}

impl DependencySecurityScanner {
    pub fn new() -> Self {
        Self {
            vulnerability_db: Arc::new(RwLock::new(HashMap::new())),
            http_client: reqwest::Client::new(),
        }
    }
    
    pub async fn scan_cargo_toml(&self, cargo_toml_path: &Path) -> Result<Vec<DependencyInfo>, ScanError> {
        let content = tokio::fs::read_to_string(cargo_toml_path).await?;
        let dependencies = self.parse_cargo_toml(&content)?;
        
        let mut results = Vec::new();
        
        for dep in dependencies {
            let vulnerabilities = self.check_vulnerabilities(&dep.name, &dep.version).await?;
            
            results.push(DependencyInfo {
                name: dep.name,
                version: dep.version,
                source: dep.source,
                vulnerabilities,
            });
        }
        
        Ok(results)
    }
    
    fn parse_cargo_toml(&self, content: &str) -> Result<Vec<Dependency>, ParseError> {
        let mut dependencies = Vec::new();
        
        // 简单的TOML解析（实际项目中应使用toml crate）
        let lines: Vec<&str> = content.lines().collect();
        let mut in_dependencies = false;
        
        for line in lines {
            let line = line.trim();
            
            if line == "[dependencies]" {
                in_dependencies = true;
                continue;
            }
            
            if line.starts_with('[') && line != "[dependencies]" {
                in_dependencies = false;
                continue;
            }
            
            if in_dependencies && !line.is_empty() && !line.starts_with('#') {
                if let Some((name, version)) = self.parse_dependency_line(line) {
                    dependencies.push(Dependency {
                        name,
                        version,
                        source: "crates.io".to_string(),
                    });
                }
            }
        }
        
        Ok(dependencies)
    }
    
    fn parse_dependency_line(&self, line: &str) -> Option<(String, String)> {
        let parts: Vec<&str> = line.split('=').collect();
        if parts.len() >= 2 {
            let name = parts[0].trim().to_string();
            let version_part = parts[1].trim();
            
            // 提取版本号
            if let Some(version) = version_part.strip_prefix('"').and_then(|s| s.strip_suffix('"')) {
                return Some((name, version.to_string()));
            }
        }
        None
    }
    
    async fn check_vulnerabilities(&self, package: &str, version: &str) -> Result<Vec<Vulnerability>, ScanError> {
        // 检查本地漏洞数据库
        let local_vulns = self.check_local_database(package, version).await;
        
        // 检查在线漏洞数据库
        let online_vulns = self.check_online_database(package, version).await?;
        
        let mut all_vulns = local_vulns;
        all_vulns.extend(online_vulns);
        
        Ok(all_vulns)
    }
    
    async fn check_local_database(&self, package: &str, version: &str) -> Vec<Vulnerability> {
        let db = self.vulnerability_db.read().unwrap();
        let mut vulnerabilities = Vec::new();
        
        for (key, vuln) in db.iter() {
            if vuln.package == package && self.is_vulnerable_version(version, &vuln.version) {
                vulnerabilities.push(vuln.clone());
            }
        }
        
        vulnerabilities
    }
    
    async fn check_online_database(&self, package: &str, version: &str) -> Result<Vec<Vulnerability>, ScanError> {
        // 这里应该调用实际的漏洞数据库API
        // 例如：RustSec Advisory Database, CVE数据库等
        
        let url = format!("https://api.rustsec.org/advisories?package={}&version={}", package, version);
        
        match self.http_client.get(&url).send().await {
            Ok(response) => {
                if response.status().is_success() {
                    let vulns: Vec<Vulnerability> = response.json().await?;
                    Ok(vulns)
                } else {
                    Ok(Vec::new())
                }
            }
            Err(_) => {
                // 网络错误，返回空结果
                Ok(Vec::new())
            }
        }
    }
    
    fn is_vulnerable_version(&self, current_version: &str, vulnerable_version: &str) -> bool {
        // 简单的版本比较逻辑
        // 实际项目中应使用semver crate进行精确的版本比较
        current_version == vulnerable_version
    }
    
    pub async fn update_vulnerability_database(&self) -> Result<(), ScanError> {
        // 从在线源更新漏洞数据库
        let url = "https://api.rustsec.org/advisories";
        
        match self.http_client.get(url).send().await {
            Ok(response) => {
                if response.status().is_success() {
                    let vulnerabilities: Vec<Vulnerability> = response.json().await?;
                    
                    let mut db = self.vulnerability_db.write().unwrap();
                    for vuln in vulnerabilities {
                        let key = format!("{}:{}", vuln.package, vuln.version);
                        db.insert(key, vuln);
                    }
                }
            }
            Err(e) => {
                return Err(ScanError::NetworkError(e.to_string()));
            }
        }
        
        Ok(())
    }
    
    pub fn generate_dependency_report(&self, dependencies: &[DependencyInfo]) -> String {
        let mut report = String::new();
        
        report.push_str("# 依赖安全扫描报告\n\n");
        
        let total_deps = dependencies.len();
        let vulnerable_deps: Vec<_> = dependencies.iter()
            .filter(|dep| !dep.vulnerabilities.is_empty())
            .collect();
        
        report.push_str(&format!("## 扫描统计\n"));
        report.push_str(&format!("- 总依赖数: {}\n", total_deps));
        report.push_str(&format!("- 存在漏洞的依赖: {}\n", vulnerable_deps.len()));
        report.push_str(&format!("- 安全依赖: {}\n\n", total_deps - vulnerable_deps.len()));
        
        if !vulnerable_deps.is_empty() {
            report.push_str("## 存在漏洞的依赖\n\n");
            
            for dep in vulnerable_deps {
                report.push_str(&format!("### {}\n", dep.name));
                report.push_str(&format!("- 版本: {}\n", dep.version));
                report.push_str(&format!("- 漏洞数量: {}\n", dep.vulnerabilities.len()));
                
                for vuln in &dep.vulnerabilities {
                    report.push_str(&format!("  - {}: {}\n", vuln.severity, vuln.description));
                    if let Some(cve) = &vuln.cve_id {
                        report.push_str(&format!("    CVE: {}\n", cve));
                    }
                    if let Some(fixed_version) = &vuln.fixed_version {
                        report.push_str(&format!("    修复版本: {}\n", fixed_version));
                    }
                }
                report.push_str("\n");
            }
        }
        
        report
    }
}

#[derive(Debug, Clone)]
struct Dependency {
    name: String,
    version: String,
    source: String,
}
```

## 2. 威胁防护工具

### 2.1 入侵检测系统

```rust
// 入侵检测系统
use std::collections::HashMap;
use std::time::{Duration, Instant};
use std::sync::Arc;

pub struct IntrusionDetectionSystem {
    rules: Vec<DetectionRule>,
    alerts: Arc<RwLock<Vec<SecurityAlert>>>,
    statistics: Arc<RwLock<DetectionStatistics>>,
}

#[derive(Debug, Clone)]
pub struct DetectionRule {
    pub id: String,
    pub name: String,
    pub pattern: String,
    pub threshold: u32,
    pub time_window: Duration,
    pub severity: AlertSeverity,
    pub action: AlertAction,
}

#[derive(Debug, Clone)]
pub enum AlertSeverity {
    Low,
    Medium,
    High,
    Critical,
}

#[derive(Debug, Clone)]
pub enum AlertAction {
    Log,
    Block,
    Notify,
    Escalate,
}

#[derive(Debug, Clone)]
pub struct SecurityAlert {
    pub id: String,
    pub rule_id: String,
    pub timestamp: Instant,
    pub severity: AlertSeverity,
    pub source_ip: String,
    pub description: String,
    pub action_taken: AlertAction,
}

#[derive(Debug, Default)]
pub struct DetectionStatistics {
    pub total_alerts: u64,
    pub alerts_by_severity: HashMap<AlertSeverity, u64>,
    pub alerts_by_rule: HashMap<String, u64>,
    pub blocked_requests: u64,
    pub false_positives: u64,
}

impl IntrusionDetectionSystem {
    pub fn new() -> Self {
        let mut ids = Self {
            rules: Vec::new(),
            alerts: Arc::new(RwLock::new(Vec::new())),
            statistics: Arc::new(RwLock::new(DetectionStatistics::default())),
        };
        
        // 加载默认检测规则
        ids.load_default_rules();
        ids
    }
    
    fn load_default_rules(&mut self) {
        // SQL注入检测规则
        self.rules.push(DetectionRule {
            id: "SQL_INJECTION_DETECTION".to_string(),
            name: "SQL Injection Detection".to_string(),
            pattern: r"(union|select|insert|update|delete|drop|create|alter)\s+.*(from|into|where)".to_string(),
            threshold: 3,
            time_window: Duration::from_secs(60),
            severity: AlertSeverity::High,
            action: AlertAction::Block,
        });
        
        // 暴力破解检测规则
        self.rules.push(DetectionRule {
            id: "BRUTE_FORCE_DETECTION".to_string(),
            name: "Brute Force Attack Detection".to_string(),
            pattern: "login_failed".to_string(),
            threshold: 5,
            time_window: Duration::from_secs(300),
            severity: AlertSeverity::Medium,
            action: AlertAction::Block,
        });
        
        // 路径遍历检测规则
        self.rules.push(DetectionRule {
            id: "PATH_TRAVERSAL_DETECTION".to_string(),
            name: "Path Traversal Detection".to_string(),
            pattern: r"\.\./|\.\.\\|%2e%2e%2f|%2e%2e%5c".to_string(),
            threshold: 1,
            time_window: Duration::from_secs(60),
            severity: AlertSeverity::High,
            action: AlertAction::Block,
        });
        
        // XSS检测规则
        self.rules.push(DetectionRule {
            id: "XSS_DETECTION".to_string(),
            name: "Cross-Site Scripting Detection".to_string(),
            pattern: r"<script|javascript:|on\w+\s*=".to_string(),
            threshold: 2,
            time_window: Duration::from_secs(60),
            severity: AlertSeverity::Medium,
            action: AlertAction::Log,
        });
    }
    
    pub async fn analyze_request(&self, request: &HttpRequest) -> Result<Vec<SecurityAlert>, DetectionError> {
        let mut alerts = Vec::new();
        
        for rule in &self.rules {
            if let Some(alert) = self.check_rule(rule, request).await? {
                alerts.push(alert);
            }
        }
        
        // 保存告警
        {
            let mut all_alerts = self.alerts.write().unwrap();
            all_alerts.extend(alerts.clone());
        }
        
        // 更新统计信息
        self.update_statistics(&alerts).await;
        
        Ok(alerts)
    }
    
    async fn check_rule(&self, rule: &DetectionRule, request: &HttpRequest) -> Result<Option<SecurityAlert>, DetectionError> {
        // 检查请求是否匹配规则模式
        if self.matches_pattern(&rule.pattern, request) {
            // 检查是否超过阈值
            if self.exceeds_threshold(rule, request).await? {
                let alert = SecurityAlert {
                    id: uuid::Uuid::new_v4().to_string(),
                    rule_id: rule.id.clone(),
                    timestamp: Instant::now(),
                    severity: rule.severity.clone(),
                    source_ip: request.source_ip.clone(),
                    description: format!("{} detected from {}", rule.name, request.source_ip),
                    action_taken: rule.action.clone(),
                };
                
                // 执行相应的动作
                self.execute_action(&alert).await?;
                
                return Ok(Some(alert));
            }
        }
        
        Ok(None)
    }
    
    fn matches_pattern(&self, pattern: &str, request: &HttpRequest) -> bool {
        // 检查URL
        if regex::Regex::new(pattern).unwrap().is_match(&request.url) {
            return true;
        }
        
        // 检查请求头
        for (_, value) in &request.headers {
            if regex::Regex::new(pattern).unwrap().is_match(value) {
                return true;
            }
        }
        
        // 检查请求体
        if let Some(body) = &request.body {
            if regex::Regex::new(pattern).unwrap().is_match(body) {
                return true;
            }
        }
        
        false
    }
    
    async fn exceeds_threshold(&self, rule: &DetectionRule, request: &HttpRequest) -> Result<bool, DetectionError> {
        // 这里应该实现基于时间窗口的阈值检查
        // 例如：在指定时间窗口内，来自同一IP的匹配请求数量是否超过阈值
        
        // 简化实现：直接返回true
        Ok(true)
    }
    
    async fn execute_action(&self, alert: &SecurityAlert) -> Result<(), DetectionError> {
        match alert.action_taken {
            AlertAction::Log => {
                println!("Security Alert: {}", alert.description);
            }
            AlertAction::Block => {
                // 实现IP封禁逻辑
                println!("Blocking IP: {}", alert.source_ip);
            }
            AlertAction::Notify => {
                // 发送通知
                self.send_notification(alert).await?;
            }
            AlertAction::Escalate => {
                // 升级处理
                self.escalate_alert(alert).await?;
            }
        }
        
        Ok(())
    }
    
    async fn send_notification(&self, alert: &SecurityAlert) -> Result<(), DetectionError> {
        // 实现通知发送逻辑
        // 例如：发送邮件、Slack消息等
        println!("Sending notification for alert: {}", alert.id);
        Ok(())
    }
    
    async fn escalate_alert(&self, alert: &SecurityAlert) -> Result<(), DetectionError> {
        // 实现告警升级逻辑
        // 例如：通知安全团队、创建工单等
        println!("Escalating alert: {}", alert.id);
        Ok(())
    }
    
    async fn update_statistics(&self, alerts: &[SecurityAlert]) {
        let mut stats = self.statistics.write().unwrap();
        
        for alert in alerts {
            stats.total_alerts += 1;
            
            // 按严重程度统计
            *stats.alerts_by_severity.entry(alert.severity.clone()).or_insert(0) += 1;
            
            // 按规则统计
            *stats.alerts_by_rule.entry(alert.rule_id.clone()).or_insert(0) += 1;
            
            // 统计被阻止的请求
            if matches!(alert.action_taken, AlertAction::Block) {
                stats.blocked_requests += 1;
            }
        }
    }
    
    pub fn get_statistics(&self) -> DetectionStatistics {
        self.statistics.read().unwrap().clone()
    }
    
    pub fn get_recent_alerts(&self, limit: usize) -> Vec<SecurityAlert> {
        let alerts = self.alerts.read().unwrap();
        let mut recent_alerts: Vec<_> = alerts.iter().cloned().collect();
        recent_alerts.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));
        recent_alerts.truncate(limit);
        recent_alerts
    }
}

#[derive(Debug, Clone)]
pub struct HttpRequest {
    pub url: String,
    pub method: String,
    pub headers: HashMap<String, String>,
    pub body: Option<String>,
    pub source_ip: String,
    pub timestamp: Instant,
}
```

## 3. 安全监控工具

### 3.1 安全事件监控器

```rust
// 安全事件监控器
use std::collections::HashMap;
use std::time::{Duration, Instant};
use tokio::time::interval;

pub struct SecurityEventMonitor {
    events: Arc<RwLock<Vec<SecurityEvent>>>,
    metrics: Arc<RwLock<SecurityMetrics>>,
    alert_thresholds: HashMap<EventType, u32>,
    monitoring_interval: Duration,
}

#[derive(Debug, Clone, Hash, Eq, PartialEq)]
pub enum EventType {
    Authentication,
    Authorization,
    DataAccess,
    ConfigurationChange,
    NetworkAccess,
    SystemAccess,
}

#[derive(Debug, Clone)]
pub struct SecurityEvent {
    pub id: String,
    pub event_type: EventType,
    pub timestamp: Instant,
    pub source: String,
    pub user_id: Option<String>,
    pub resource: Option<String>,
    pub action: String,
    pub result: EventResult,
    pub details: HashMap<String, String>,
}

#[derive(Debug, Clone)]
pub enum EventResult {
    Success,
    Failure,
    Denied,
    Error,
}

#[derive(Debug, Default)]
pub struct SecurityMetrics {
    pub total_events: u64,
    pub events_by_type: HashMap<EventType, u64>,
    pub events_by_result: HashMap<EventResult, u64>,
    pub failed_authentications: u64,
    pub denied_authorizations: u64,
    pub suspicious_activities: u64,
    pub last_updated: Instant,
}

impl SecurityEventMonitor {
    pub fn new() -> Self {
        let mut monitor = Self {
            events: Arc::new(RwLock::new(Vec::new())),
            metrics: Arc::new(RwLock::new(SecurityMetrics::default())),
            alert_thresholds: HashMap::new(),
            monitoring_interval: Duration::from_secs(60),
        };
        
        // 设置告警阈值
        monitor.alert_thresholds.insert(EventType::Authentication, 10);
        monitor.alert_thresholds.insert(EventType::Authorization, 5);
        monitor.alert_thresholds.insert(EventType::DataAccess, 20);
        
        monitor
    }
    
    pub fn start_monitoring(&self) {
        let monitor = self.clone();
        tokio::spawn(async move {
            let mut interval = interval(monitor.monitoring_interval);
            
            loop {
                interval.tick().await;
                monitor.analyze_events().await;
            }
        });
    }
    
    pub async fn record_event(&self, event: SecurityEvent) {
        // 记录事件
        {
            let mut events = self.events.write().unwrap();
            events.push(event.clone());
            
            // 保持事件数量在合理范围内
            if events.len() > 10000 {
                events.drain(0..1000);
            }
        }
        
        // 更新指标
        self.update_metrics(&event).await;
        
        // 检查是否需要告警
        self.check_alerts(&event).await;
    }
    
    async fn update_metrics(&self, event: &SecurityEvent) {
        let mut metrics = self.metrics.write().unwrap();
        
        metrics.total_events += 1;
        metrics.last_updated = Instant::now();
        
        // 按类型统计
        *metrics.events_by_type.entry(event.event_type.clone()).or_insert(0) += 1;
        
        // 按结果统计
        *metrics.events_by_result.entry(event.result.clone()).or_insert(0) += 1;
        
        // 特殊统计
        match (&event.event_type, &event.result) {
            (EventType::Authentication, EventResult::Failure) => {
                metrics.failed_authentications += 1;
            }
            (EventType::Authorization, EventResult::Denied) => {
                metrics.denied_authorizations += 1;
            }
            _ => {}
        }
        
        // 检测可疑活动
        if self.is_suspicious_activity(event) {
            metrics.suspicious_activities += 1;
        }
    }
    
    fn is_suspicious_activity(&self, event: &SecurityEvent) -> bool {
        // 检测可疑活动的逻辑
        match (&event.event_type, &event.result) {
            (EventType::Authentication, EventResult::Failure) => {
                // 多次认证失败
                true
            }
            (EventType::DataAccess, EventResult::Success) => {
                // 大量数据访问
                true
            }
            _ => false,
        }
    }
    
    async fn check_alerts(&self, event: &SecurityEvent) {
        if let Some(threshold) = self.alert_thresholds.get(&event.event_type) {
            let recent_events = self.get_recent_events_by_type(&event.event_type, Duration::from_secs(300)).await;
            
            if recent_events.len() >= *threshold as usize {
                self.send_alert(&event.event_type, recent_events.len()).await;
            }
        }
    }
    
    async fn get_recent_events_by_type(&self, event_type: &EventType, window: Duration) -> Vec<SecurityEvent> {
        let events = self.events.read().unwrap();
        let cutoff = Instant::now() - window;
        
        events.iter()
            .filter(|e| e.event_type == *event_type && e.timestamp > cutoff)
            .cloned()
            .collect()
    }
    
    async fn send_alert(&self, event_type: &EventType, count: usize) {
        println!("Security Alert: {} events of type {:?} detected in the last 5 minutes", count, event_type);
        // 这里应该实现实际的告警发送逻辑
    }
    
    async fn analyze_events(&self) {
        // 分析事件模式，检测异常行为
        let events = self.events.read().unwrap();
        
        // 检测异常登录模式
        self.detect_anomalous_login_patterns(&events).await;
        
        // 检测异常数据访问模式
        self.detect_anomalous_data_access(&events).await;
        
        // 检测权限提升尝试
        self.detect_privilege_escalation(&events).await;
    }
    
    async fn detect_anomalous_login_patterns(&self, events: &[SecurityEvent]) {
        // 检测异常登录模式
        let auth_events: Vec<_> = events.iter()
            .filter(|e| e.event_type == EventType::Authentication)
            .collect();
        
        // 按用户分组
        let mut user_attempts: HashMap<String, Vec<&SecurityEvent>> = HashMap::new();
        for event in auth_events {
            if let Some(user_id) = &event.user_id {
                user_attempts.entry(user_id.clone()).or_insert_with(Vec::new).push(event);
            }
        }
        
        // 检测异常模式
        for (user_id, attempts) in user_attempts {
            if attempts.len() > 10 {
                println!("Anomalous login pattern detected for user: {}", user_id);
            }
        }
    }
    
    async fn detect_anomalous_data_access(&self, events: &[SecurityEvent]) {
        // 检测异常数据访问模式
        let data_events: Vec<_> = events.iter()
            .filter(|e| e.event_type == EventType::DataAccess)
            .collect();
        
        // 按资源分组
        let mut resource_access: HashMap<String, Vec<&SecurityEvent>> = HashMap::new();
        for event in data_events {
            if let Some(resource) = &event.resource {
                resource_access.entry(resource.clone()).or_insert_with(Vec::new).push(event);
            }
        }
        
        // 检测异常访问
        for (resource, accesses) in resource_access {
            if accesses.len() > 50 {
                println!("Anomalous data access detected for resource: {}", resource);
            }
        }
    }
    
    async fn detect_privilege_escalation(&self, events: &[SecurityEvent]) {
        // 检测权限提升尝试
        let auth_events: Vec<_> = events.iter()
            .filter(|e| e.event_type == EventType::Authorization && e.result == EventResult::Denied)
            .collect();
        
        if auth_events.len() > 5 {
            println!("Potential privilege escalation attempt detected");
        }
    }
    
    pub fn get_metrics(&self) -> SecurityMetrics {
        self.metrics.read().unwrap().clone()
    }
    
    pub fn get_recent_events(&self, limit: usize) -> Vec<SecurityEvent> {
        let events = self.events.read().unwrap();
        let mut recent_events: Vec<_> = events.iter().cloned().collect();
        recent_events.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));
        recent_events.truncate(limit);
        recent_events
    }
    
    pub fn generate_security_report(&self) -> String {
        let metrics = self.get_metrics();
        let recent_events = self.get_recent_events(100);
        
        let mut report = String::new();
        
        report.push_str("# 安全监控报告\n\n");
        
        report.push_str("## 安全指标\n");
        report.push_str(&format!("- 总事件数: {}\n", metrics.total_events));
        report.push_str(&format!("- 认证失败: {}\n", metrics.failed_authentications));
        report.push_str(&format!("- 授权拒绝: {}\n", metrics.denied_authorizations));
        report.push_str(&format!("- 可疑活动: {}\n", metrics.suspicious_activities));
        
        report.push_str("\n## 事件类型分布\n");
        for (event_type, count) in &metrics.events_by_type {
            report.push_str(&format!("- {:?}: {}\n", event_type, count));
        }
        
        report.push_str("\n## 最近安全事件\n");
        for event in recent_events.iter().take(10) {
            report.push_str(&format!("- {}: {} ({:?})\n", 
                event.timestamp, event.action, event.result));
        }
        
        report
    }
}
```

## 4. 使用示例

### 4.1 安全扫描示例

```rust
// 安全扫描示例
async fn example_security_scan() {
    let scanner = CodeSecurityScanner::new();
    
    // 扫描代码目录
    let issues = scanner.scan_directory(Path::new("./src")).await.unwrap();
    
    // 生成报告
    let report = scanner.generate_report();
    println!("{}", report);
    
    // 扫描依赖
    let dep_scanner = DependencySecurityScanner::new();
    let dependencies = dep_scanner.scan_cargo_toml(Path::new("./Cargo.toml")).await.unwrap();
    
    let dep_report = dep_scanner.generate_dependency_report(&dependencies);
    println!("{}", dep_report);
}
```

### 4.2 威胁防护示例

```rust
// 威胁防护示例
async fn example_threat_protection() {
    let ids = IntrusionDetectionSystem::new();
    
    // 模拟HTTP请求
    let request = HttpRequest {
        url: "/api/users?name=' OR '1'='1".to_string(),
        method: "GET".to_string(),
        headers: HashMap::new(),
        body: None,
        source_ip: "192.168.1.100".to_string(),
        timestamp: Instant::now(),
    };
    
    // 分析请求
    let alerts = ids.analyze_request(&request).await.unwrap();
    
    for alert in alerts {
        println!("Security Alert: {}", alert.description);
    }
    
    // 获取统计信息
    let stats = ids.get_statistics();
    println!("Total alerts: {}", stats.total_alerts);
}
```

## 5. 最佳实践

### 5.1 安全扫描策略

- **定期扫描**: 定期进行代码和依赖安全扫描
- **自动化集成**: 将安全扫描集成到CI/CD流程
- **漏洞管理**: 建立漏洞管理和修复流程
- **安全培训**: 定期进行安全培训

### 5.2 威胁防护策略

- **多层防护**: 实现多层安全防护
- **实时监控**: 实时监控安全事件
- **快速响应**: 建立快速响应机制
- **持续改进**: 持续改进安全策略

### 5.3 安全监控策略

- **全面监控**: 监控所有安全相关事件
- **智能分析**: 使用机器学习分析异常行为
- **告警机制**: 建立有效的告警机制
- **事件响应**: 建立完善的事件响应流程

---

**文档版本**: v1.0  
**最后更新**: 2025-01-XX  
**维护者**: 安全团队
