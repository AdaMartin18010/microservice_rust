# 8.5 OTel 语义约定覆盖清单

> OpenTelemetry 语义约定标准化指南，确保微服务可观测性的一致性和完整性

## 8.5.1 概述

OpenTelemetry 语义约定定义了跨语言、跨框架的统一属性命名和值格式，确保：

- **一致性**：所有服务使用相同的属性名称和值格式
- **互操作性**：不同语言和框架的遥测数据可以无缝集成
- **标准化**：遵循行业最佳实践和规范

## 8.5.2 HTTP 语义约定

### 请求属性

```rust
// HTTP 请求语义约定
use opentelemetry::KeyValue;

// 必需属性
const HTTP_METHOD: &str = "http.method";
const HTTP_URL: &str = "http.url";
const HTTP_SCHEME: &str = "http.scheme";
const HTTP_HOST: &str = "http.host";
const HTTP_TARGET: &str = "http.target";
const HTTP_STATUS_CODE: &str = "http.status_code";

// 可选属性
const HTTP_REQUEST_BODY_SIZE: &str = "http.request.body.size";
const HTTP_RESPONSE_BODY_SIZE: &str = "http.response.body.size";
const HTTP_USER_AGENT: &str = "http.user_agent";
const HTTP_ROUTE: &str = "http.route";
const HTTP_CLIENT_IP: &str = "http.client_ip";

// 实现示例
pub fn create_http_span(
    method: &str,
    url: &str,
    status_code: u16,
    route: Option<&str>,
) -> Vec<KeyValue> {
    let mut attributes = vec![
        KeyValue::new(HTTP_METHOD, method.to_string()),
        KeyValue::new(HTTP_URL, url.to_string()),
        KeyValue::new(HTTP_STATUS_CODE, status_code as i64),
    ];
    
    if let Some(route) = route {
        attributes.push(KeyValue::new(HTTP_ROUTE, route.to_string()));
    }
    
    attributes
}
```

### 服务器端实现

```rust
use axum::{
    extract::Request,
    middleware::Next,
    response::Response,
};
use opentelemetry::{
    global,
    trace::{Span, Status, Tracer},
    KeyValue,
};

pub async fn otel_middleware(
    request: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    let tracer = global::tracer("microservice");
    let span = tracer.start("http_request");
    
    // 设置请求属性
    let method = request.method().as_str();
    let uri = request.uri();
    let url = format!("{}://{}{}", 
        uri.scheme().unwrap_or(&Scheme::HTTP),
        uri.host().unwrap_or("unknown"),
        uri.path()
    );
    
    span.set_attributes(&[
        KeyValue::new("http.method", method.to_string()),
        KeyValue::new("http.url", url),
        KeyValue::new("http.scheme", uri.scheme().unwrap_or(&Scheme::HTTP).as_str().to_string()),
        KeyValue::new("http.host", uri.host().unwrap_or("unknown").to_string()),
        KeyValue::new("http.target", uri.path().to_string()),
    ]);
    
    // 处理请求
    let response = next.run(request).await;
    
    // 设置响应属性
    let status_code = response.status().as_u16();
    span.set_attribute(KeyValue::new("http.status_code", status_code as i64));
    
    if status_code >= 400 {
        span.set_status(Status::error("HTTP error"));
    }
    
    span.end();
    Ok(response)
}
```

## 8.5.3 gRPC 语义约定

### 服务端属性

```rust
// gRPC 语义约定
const RPC_SYSTEM: &str = "rpc.system";
const RPC_SERVICE: &str = "rpc.service";
const RPC_METHOD: &str = "rpc.method";
const RPC_GRPC_STATUS_CODE: &str = "rpc.grpc.status_code";

// gRPC 服务端实现
use tonic::{Request, Response, Status};
use opentelemetry::{
    trace::{Span, Status as OtelStatus, Tracer},
    KeyValue,
};

pub async fn grpc_interceptor<T>(
    request: Request<T>,
    next: tonic::service::interceptor::Next,
) -> Result<Response<T>, Status> {
    let tracer = global::tracer("grpc-service");
    let span = tracer.start("rpc_request");
    
    // 设置 gRPC 属性
    let method = request.uri().path();
    let service_method: Vec<&str> = method.trim_start_matches('/').split('/').collect();
    
    if service_method.len() >= 2 {
        span.set_attributes(&[
            KeyValue::new(RPC_SYSTEM, "grpc"),
            KeyValue::new(RPC_SERVICE, service_method[0].to_string()),
            KeyValue::new(RPC_METHOD, service_method[1].to_string()),
        ]);
    }
    
    // 处理请求
    let response = next.call(request).await;
    
    // 设置状态码
    match &response {
        Ok(_) => {
            span.set_attribute(KeyValue::new(RPC_GRPC_STATUS_CODE, 0i64));
        }
        Err(status) => {
            let code = status.code() as i32;
            span.set_attribute(KeyValue::new(RPC_GRPC_STATUS_CODE, code as i64));
            span.set_status(OtelStatus::error(status.message()));
        }
    }
    
    span.end();
    response
}
```

## 8.5.4 数据库语义约定

### SQL 数据库

```rust
// 数据库语义约定
const DB_SYSTEM: &str = "db.system";
const DB_CONNECTION_STRING: &str = "db.connection_string";
const DB_USER: &str = "db.user";
const DB_NAME: &str = "db.name";
const DB_OPERATION: &str = "db.operation";
const DB_SQL_TABLE: &str = "db.sql.table";
const DB_STATEMENT: &str = "db.statement";

// SQLx 集成示例
use sqlx::{Pool, Postgres};
use opentelemetry::{
    trace::{Span, Tracer},
    KeyValue,
};

pub async fn execute_query(
    pool: &Pool<Postgres>,
    query: &str,
    table: Option<&str>,
) -> Result<Vec<serde_json::Value>, sqlx::Error> {
    let tracer = global::tracer("database");
    let span = tracer.start("db_query");
    
    // 设置数据库属性
    let mut attributes = vec![
        KeyValue::new(DB_SYSTEM, "postgresql"),
        KeyValue::new(DB_OPERATION, "SELECT"),
        KeyValue::new(DB_STATEMENT, query.to_string()),
    ];
    
    if let Some(table) = table {
        attributes.push(KeyValue::new(DB_SQL_TABLE, table.to_string()));
    }
    
    span.set_attributes(&attributes);
    
    // 执行查询
    let result = sqlx::query(query)
        .fetch_all(pool)
        .await;
    
    match &result {
        Ok(rows) => {
            span.set_attribute(KeyValue::new("db.rows_affected", rows.len() as i64));
        }
        Err(e) => {
            span.set_status(opentelemetry::trace::Status::error(e.to_string()));
        }
    }
    
    span.end();
    result.map(|rows| {
        rows.into_iter()
            .map(|row| serde_json::from_row(&row).unwrap_or_default())
            .collect()
    })
}
```

## 8.5.5 消息队列语义约定

### Kafka 语义约定

```rust
// 消息队列语义约定
const MESSAGING_SYSTEM: &str = "messaging.system";
const MESSAGING_DESTINATION: &str = "messaging.destination";
const MESSAGING_DESTINATION_KIND: &str = "messaging.destination.kind";
const MESSAGING_OPERATION: &str = "messaging.operation";
const MESSAGING_MESSAGE_ID: &str = "messaging.message.id";
const MESSAGING_MESSAGE_PAYLOAD_SIZE: &str = "messaging.message.payload_size";

// Kafka 生产者实现
use rdkafka::producer::{FutureProducer, FutureRecord};
use opentelemetry::{
    trace::{Span, Tracer},
    KeyValue,
};

pub async fn produce_message(
    producer: &FutureProducer,
    topic: &str,
    key: Option<&str>,
    payload: &[u8],
) -> Result<(), Box<dyn std::error::Error>> {
    let tracer = global::tracer("kafka-producer");
    let span = tracer.start("messaging_publish");
    
    // 设置消息队列属性
    span.set_attributes(&[
        KeyValue::new(MESSAGING_SYSTEM, "kafka"),
        KeyValue::new(MESSAGING_DESTINATION, topic.to_string()),
        KeyValue::new(MESSAGING_DESTINATION_KIND, "topic"),
        KeyValue::new(MESSAGING_OPERATION, "publish"),
        KeyValue::new(MESSAGING_MESSAGE_PAYLOAD_SIZE, payload.len() as i64),
    ]);
    
    // 发送消息
    let record = FutureRecord::to(topic)
        .payload(payload);
    
    let record = if let Some(key) = key {
        record.key(key)
    } else {
        record
    };
    
    match producer.send(record, Duration::from_secs(0)).await {
        Ok(_) => {
            span.set_attribute(KeyValue::new("messaging.message.sent", true));
        }
        Err((e, _)) => {
            span.set_status(opentelemetry::trace::Status::error(e.to_string()));
            return Err(e.into());
        }
    }
    
    span.end();
    Ok(())
}
```

## 8.5.6 服务发现语义约定

### 服务标识

```rust
// 服务发现语义约定
const SERVICE_NAME: &str = "service.name";
const SERVICE_VERSION: &str = "service.version";
const SERVICE_INSTANCE_ID: &str = "service.instance.id";
const DEPLOYMENT_ENVIRONMENT: &str = "deployment.environment";

// 服务注册实现
use consul::Client as ConsulClient;
use opentelemetry::{
    trace::{Span, Tracer},
    KeyValue,
};

pub async fn register_service(
    consul: &ConsulClient,
    service_name: &str,
    service_version: &str,
    instance_id: &str,
    environment: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let tracer = global::tracer("service-discovery");
    let span = tracer.start("service_register");
    
    // 设置服务属性
    span.set_attributes(&[
        KeyValue::new(SERVICE_NAME, service_name.to_string()),
        KeyValue::new(SERVICE_VERSION, service_version.to_string()),
        KeyValue::new(SERVICE_INSTANCE_ID, instance_id.to_string()),
        KeyValue::new(DEPLOYMENT_ENVIRONMENT, environment.to_string()),
    ]);
    
    // 注册到 Consul
    let service = consul::Service {
        id: instance_id.to_string(),
        name: service_name.to_string(),
        tags: vec![
            format!("version:{}", service_version),
            format!("environment:{}", environment),
        ],
        address: Some("127.0.0.1".to_string()),
        port: Some(8080),
        ..Default::default()
    };
    
    match consul.agent().service_register(&service).await {
        Ok(_) => {
            span.set_attribute(KeyValue::new("service.registered", true));
        }
        Err(e) => {
            span.set_status(opentelemetry::trace::Status::error(e.to_string()));
            return Err(e.into());
        }
    }
    
    span.end();
    Ok(())
}
```

## 8.5.7 错误处理语义约定

### 错误属性

```rust
// 错误语义约定
const ERROR_TYPE: &str = "error.type";
const ERROR_MESSAGE: &str = "error.message";
const ERROR_STACK: &str = "error.stack";

// 错误处理实现
use opentelemetry::{
    trace::{Span, Status},
    KeyValue,
};

pub fn record_error(span: &Span, error: &dyn std::error::Error) {
    let error_type = std::any::type_name_of_val(error);
    let error_message = error.to_string();
    
    span.set_attributes(&[
        KeyValue::new(ERROR_TYPE, error_type.to_string()),
        KeyValue::new(ERROR_MESSAGE, error_message),
    ]);
    
    // 设置 span 状态
    span.set_status(Status::error(error_message));
    
    // 记录堆栈跟踪（如果可用）
    if let Some(backtrace) = error.backtrace() {
        span.set_attribute(KeyValue::new(ERROR_STACK, backtrace.to_string()));
    }
}
```

## 8.5.8 自定义属性规范

### 业务属性

```rust
// 自定义业务属性
const USER_ID: &str = "user.id";
const SESSION_ID: &str = "session.id";
const REQUEST_ID: &str = "request.id";
const BUSINESS_OPERATION: &str = "business.operation";

// 业务属性设置
pub fn set_business_attributes(
    span: &Span,
    user_id: Option<&str>,
    session_id: Option<&str>,
    request_id: &str,
    operation: &str,
) {
    let mut attributes = vec![
        KeyValue::new(REQUEST_ID, request_id.to_string()),
        KeyValue::new(BUSINESS_OPERATION, operation.to_string()),
    ];
    
    if let Some(user_id) = user_id {
        attributes.push(KeyValue::new(USER_ID, user_id.to_string()));
    }
    
    if let Some(session_id) = session_id {
        attributes.push(KeyValue::new(SESSION_ID, session_id.to_string()));
    }
    
    span.set_attributes(&attributes);
}
```

## 8.5.9 指标语义约定

### 计数器指标

```rust
// 指标语义约定
use opentelemetry::{
    metrics::{Counter, Histogram, Meter},
    KeyValue,
};

pub struct MetricsCollector {
    request_counter: Counter<u64>,
    request_duration: Histogram<f64>,
    error_counter: Counter<u64>,
}

impl MetricsCollector {
    pub fn new(meter: Meter) -> Self {
        Self {
            request_counter: meter
                .u64_counter("http_requests_total")
                .with_description("Total number of HTTP requests")
                .init(),
            request_duration: meter
                .f64_histogram("http_request_duration_seconds")
                .with_description("HTTP request duration in seconds")
                .init(),
            error_counter: meter
                .u64_counter("http_errors_total")
                .with_description("Total number of HTTP errors")
                .init(),
        }
    }
    
    pub fn record_request(&self, method: &str, status_code: u16, duration: f64) {
        let labels = &[
            KeyValue::new("http.method", method.to_string()),
            KeyValue::new("http.status_code", status_code as i64),
        ];
        
        self.request_counter.add(1, labels);
        self.request_duration.record(duration, labels);
        
        if status_code >= 400 {
            self.error_counter.add(1, labels);
        }
    }
}
```

## 8.5.10 配置最佳实践

### 环境变量配置

```rust
// 环境变量配置
use std::env;

pub struct OtelConfig {
    pub service_name: String,
    pub service_version: String,
    pub environment: String,
    pub otlp_endpoint: String,
    pub sampling_ratio: f64,
}

impl OtelConfig {
    pub fn from_env() -> Self {
        Self {
            service_name: env::var("OTEL_SERVICE_NAME")
                .unwrap_or_else(|_| "microservice".to_string()),
            service_version: env::var("OTEL_SERVICE_VERSION")
                .unwrap_or_else(|_| "1.0.0".to_string()),
            environment: env::var("OTEL_DEPLOYMENT_ENVIRONMENT")
                .unwrap_or_else(|_| "development".to_string()),
            otlp_endpoint: env::var("OTEL_EXPORTER_OTLP_ENDPOINT")
                .unwrap_or_else(|_| "http://localhost:4317".to_string()),
            sampling_ratio: env::var("OTEL_TRACES_SAMPLER_ARG")
                .unwrap_or_else(|_| "1.0".to_string())
                .parse()
                .unwrap_or(1.0),
        }
    }
}
```

## 8.5.11 验证清单

### 必需属性检查

```rust
// 属性验证工具
use opentelemetry::trace::Span;

pub fn validate_http_span(span: &Span) -> Vec<String> {
    let mut missing_attributes = Vec::new();
    
    // 检查必需属性
    let required_attrs = [
        "http.method",
        "http.url", 
        "http.status_code",
    ];
    
    for attr in &required_attrs {
        if !span.has_attribute(attr) {
            missing_attributes.push(format!("Missing required attribute: {}", attr));
        }
    }
    
    missing_attributes
}

pub fn validate_grpc_span(span: &Span) -> Vec<String> {
    let mut missing_attributes = Vec::new();
    
    let required_attrs = [
        "rpc.system",
        "rpc.service",
        "rpc.method",
        "rpc.grpc.status_code",
    ];
    
    for attr in &required_attrs {
        if !span.has_attribute(attr) {
            missing_attributes.push(format!("Missing required attribute: {}", attr));
        }
    }
    
    missing_attributes
}
```

## 8.5.12 总结

本清单提供了 OpenTelemetry 语义约定的完整覆盖指南，确保：

1. **HTTP/gRPC 服务**：正确设置请求/响应属性
2. **数据库操作**：记录查询和连接信息
3. **消息队列**：跟踪消息发送和接收
4. **服务发现**：标识服务实例和环境
5. **错误处理**：记录错误类型和堆栈信息
6. **业务指标**：添加自定义业务属性
7. **配置管理**：标准化环境变量配置

遵循这些约定可以确保微服务系统的可观测性数据具有一致性和可互操作性，便于监控、调试和性能分析。
