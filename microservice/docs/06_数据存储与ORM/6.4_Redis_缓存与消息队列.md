# 6.4 Redis 缓存与消息队列

Redis 在微服务中常用于缓存、速率限制、分布式锁、Pub/Sub 与队列。

## 6.4.1 集成

- 使用 `redis`/`bb8-redis` 实现异步连接池；
- Key 规范：前缀/版本/TTL；
- 热点数据采用二级缓存（本地 LRU + Redis）。

## 6.4.2 队列与流

- 简单队列：List + BRPOP；
- 流：Redis Streams（消费组、断点续传）。

## 6.4.3 限流与分布式锁

- 令牌桶/Lua 脚本原子性；
- Redlock 谨慎使用，优先单实例强一致方案或 etcd 锁。

## 6.4.4 Rust 1.90 实践与生态组合

- 异步 trait/TAIT：为缓存/流消费者接口隐藏实现细节，暴露统一能力。
- 连接池：`bb8-redis` 或 `deadpool-redis`；序列化：`serde_json`/`rmp-serde`。
- 可观测性：`tracing` + `opentelemetry` 记录命中率、延迟、失败率与队列滞留。
- 失效策略：写穿/回写/旁路缓存，增加保护阈值与降级兜底值。

### 示例：连接池与二级缓存（伪代码）

```rust
use bb8_redis::redis::{AsyncCommands, RedisError};
use bb8_redis::RedisConnectionManager;
use bb8::Pool;

pub type CacheGet<'a> = impl core::future::Future<Output = Result<Option<String>, RedisError>> + Send + 'a;

pub struct Cache { pool: Pool<RedisConnectionManager> }

impl Cache {
    pub async fn new(url: &str) -> anyhow::Result<Self> {
        let manager = RedisConnectionManager::new(url)?;
        let pool = Pool::builder().max_size(32).build(manager).await?;
        Ok(Self { pool })
    }

    pub fn get<'a>(&'a self, key: &'a str) -> CacheGet<'a> {
        async move {
            // 先查本地 LRU（省略），未命中再访问 Redis
            let mut conn = self.pool.get().await.map_err(|e| RedisError::from(("pool", e.to_string())))?;
            conn.get(key).await
        }
    }
}
```

### 示例：基于 Streams 的消费组（关键片段）

```rust
use bb8_redis::redis::streams::{StreamReadOptions, StreamReadReply};
use bb8_redis::redis::AsyncCommands;

async fn read_stream(conn: &mut bb8_redis::redis::aio::Connection) -> redis::RedisResult<StreamReadReply> {
    let opts = StreamReadOptions::default().count(100).block(1000).group("g1", "c1");
    conn.xread_options(&["orders"], &[">"], &opts).await
}
```

### 最佳实践

- Key 版本化与命名统一：`{app}:{domain}:{entity}:{version}:{id}`；
- 热点隔离：为极热点 key 设置单独的短 TTL 与降级逻辑；
- 防击穿/穿透：空值缓存 + 布隆过滤器（可选）；
- 幂等性：为消息消费引入去重表或消费位点持久化（Streams 消费组自带位点）；
- 灰度与回退：配置化开关控制缓存生效范围，异常时自动旁路；
- 观测：命中率、平均/TP99 延迟、连接池等待、错误率、队列滞留、重试次数。
