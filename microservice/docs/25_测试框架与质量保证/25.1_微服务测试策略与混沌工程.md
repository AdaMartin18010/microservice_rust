# 25.1 微服务测试策略与混沌工程

## 概述

本指南详细介绍如何在Rust微服务中实现全面的测试策略，包括单元测试、集成测试、端到端测试和混沌工程。我们将使用现代测试框架和工具构建完整的测试体系，确保微服务系统的可靠性和稳定性。

## 学习目标

- 掌握微服务测试策略的设计和实现
- 了解混沌工程在微服务中的应用
- 学习测试自动化和持续集成
- 实现全面的质量保证体系

## 测试策略架构

```mermaid
graph TB
    A[单元测试] --> B[集成测试]
    B --> C[端到端测试]
    C --> D[性能测试]
    D --> E[混沌工程]
    
    F[测试数据管理] --> A
    F --> B
    F --> C
    
    G[测试环境] --> A
    G --> B
    G --> C
    G --> D
    G --> E
    
    H[CI/CD流水线] --> A
    H --> B
    H --> C
    H --> D
    H --> E
    
    I[质量门禁] --> H
    
    style A fill:#e1f5fe
    style B fill:#e8f5e8
    style C fill:#fff3e0
    style D fill:#f3e5f5
    style E fill:#ffebee
    style F fill:#f1f8e9
    style G fill:#fce4ec
    style H fill:#e0f2f1
    style I fill:#fff8e1
```

## 核心组件

### 1. 测试金字塔

- **单元测试**: 快速、隔离、可重复
- **集成测试**: 服务间交互验证
- **端到端测试**: 完整业务流程验证

### 2. 混沌工程

- **故障注入**: 模拟各种故障场景
- **弹性测试**: 验证系统恢复能力
- **压力测试**: 验证系统极限性能

### 3. 测试自动化

- **CI/CD集成**: 自动化测试执行
- **质量门禁**: 基于测试结果的部署控制
- **测试报告**: 详细的测试结果分析

## 技术实现

### 环境准备

```bash
# 创建测试目录
mkdir -p tests/{unit,integration,e2e,chaos}

# 安装测试依赖
cargo add --dev tokio-test
cargo add --dev mockall
cargo add --dev testcontainers
cargo add --dev k6
```

### 依赖配置

```toml
[dev-dependencies]
tokio-test = "0.4"
mockall = "0.12"
testcontainers = "0.15"
k6 = "0.1"
criterion = "0.5"
proptest = "1.0"
quickcheck = "1.0"
```

### 单元测试实现

```rust
// tests/unit/user_service_test.rs
use microservice::services::user_service::{UserService, UserRepository};
use microservice::models::user::{User, CreateUserRequest};
use mockall::predicate::*;
use mockall::mock;
use tokio_test;

mock! {
    UserRepository {}
    
    #[async_trait::async_trait]
    impl UserRepository for UserRepository {
        async fn create_user(&self, user: CreateUserRequest) -> Result<User, Box<dyn std::error::Error>>;
        async fn get_user(&self, id: u64) -> Result<Option<User>, Box<dyn std::error::Error>>;
        async fn update_user(&self, id: u64, user: User) -> Result<User, Box<dyn std::error::Error>>;
        async fn delete_user(&self, id: u64) -> Result<(), Box<dyn std::error::Error>>;
        async fn list_users(&self, limit: u32, offset: u32) -> Result<Vec<User>, Box<dyn std::error::Error>>;
    }
}

#[tokio::test]
async fn test_create_user_success() {
    let mut mock_repo = MockUserRepository::new();
    let user_request = CreateUserRequest {
        name: "John Doe".to_string(),
        email: "john@example.com".to_string(),
    };
    
    let expected_user = User {
        id: 1,
        name: "John Doe".to_string(),
        email: "john@example.com".to_string(),
        created_at: chrono::Utc::now(),
        updated_at: chrono::Utc::now(),
    };
    
    mock_repo
        .expect_create_user()
        .with(eq(user_request.clone()))
        .times(1)
        .returning(move |_| Ok(expected_user.clone()));
    
    let user_service = UserService::new(Box::new(mock_repo));
    let result = user_service.create_user(user_request).await;
    
    assert!(result.is_ok());
    let user = result.unwrap();
    assert_eq!(user.name, "John Doe");
    assert_eq!(user.email, "john@example.com");
}

#[tokio::test]
async fn test_create_user_duplicate_email() {
    let mut mock_repo = MockUserRepository::new();
    let user_request = CreateUserRequest {
        name: "John Doe".to_string(),
        email: "john@example.com".to_string(),
    };
    
    mock_repo
        .expect_create_user()
        .times(1)
        .returning(|_| Err("Email already exists".into()));
    
    let user_service = UserService::new(Box::new(mock_repo));
    let result = user_service.create_user(user_request).await;
    
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Email already exists"));
}

#[tokio::test]
async fn test_get_user_not_found() {
    let mut mock_repo = MockUserRepository::new();
    
    mock_repo
        .expect_get_user()
        .with(eq(999))
        .times(1)
        .returning(|_| Ok(None));
    
    let user_service = UserService::new(Box::new(mock_repo));
    let result = user_service.get_user(999).await;
    
    assert!(result.is_ok());
    assert!(result.unwrap().is_none());
}

// 属性测试
use proptest::prelude::*;

proptest! {
    #[test]
    fn test_user_validation(
        name in "[a-zA-Z ]{1,100}",
        email in "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}"
    ) {
        let user_request = CreateUserRequest {
            name: name.clone(),
            email: email.clone(),
        };
        
        // 验证用户创建请求的有效性
        assert!(user_request.name.len() > 0);
        assert!(user_request.name.len() <= 100);
        assert!(user_request.email.contains("@"));
    }
}
```

### 集成测试实现

```rust
// tests/integration/user_service_integration_test.rs
use testcontainers::{Container, Docker, GenericImage};
use testcontainers::core::WaitFor;
use testcontainers::runners::AsyncRunner;
use microservice::services::user_service::UserService;
use microservice::repositories::user_repository::PostgresUserRepository;
use microservice::models::user::{User, CreateUserRequest};
use tokio_test;

#[tokio::test]
async fn test_user_service_integration() {
    // 启动PostgreSQL容器
    let postgres_image = GenericImage::new("postgres", "15")
        .with_env_var("POSTGRES_PASSWORD", "password")
        .with_env_var("POSTGRES_DB", "testdb")
        .with_exposed_port(5432)
        .with_wait_for(WaitFor::message_on_stderr("database system is ready to accept connections"));
    
    let postgres_container = postgres_image.start().await;
    let postgres_port = postgres_container.get_host_port_ipv4(5432).await;
    
    // 创建数据库连接
    let database_url = format!("postgresql://postgres:password@localhost:{}/testdb", postgres_port);
    let pool = sqlx::PgPool::connect(&database_url).await.unwrap();
    
    // 运行数据库迁移
    sqlx::migrate!("./migrations").run(&pool).await.unwrap();
    
    // 创建用户仓库和服务
    let user_repo = PostgresUserRepository::new(pool);
    let user_service = UserService::new(Box::new(user_repo));
    
    // 测试用户创建
    let user_request = CreateUserRequest {
        name: "John Doe".to_string(),
        email: "john@example.com".to_string(),
    };
    
    let created_user = user_service.create_user(user_request).await.unwrap();
    assert_eq!(created_user.name, "John Doe");
    assert_eq!(created_user.email, "john@example.com");
    
    // 测试用户查询
    let retrieved_user = user_service.get_user(created_user.id).await.unwrap();
    assert!(retrieved_user.is_some());
    assert_eq!(retrieved_user.unwrap().name, "John Doe");
    
    // 测试用户列表
    let users = user_service.list_users(10, 0).await.unwrap();
    assert_eq!(users.len(), 1);
    assert_eq!(users[0].name, "John Doe");
}

#[tokio::test]
async fn test_user_service_transaction_rollback() {
    // 启动PostgreSQL容器
    let postgres_image = GenericImage::new("postgres", "15")
        .with_env_var("POSTGRES_PASSWORD", "password")
        .with_env_var("POSTGRES_DB", "testdb")
        .with_exposed_port(5432)
        .with_wait_for(WaitFor::message_on_stderr("database system is ready to accept connections"));
    
    let postgres_container = postgres_image.start().await;
    let postgres_port = postgres_container.get_host_port_ipv4(5432).await;
    
    // 创建数据库连接
    let database_url = format!("postgresql://postgres:password@localhost:{}/testdb", postgres_port);
    let pool = sqlx::PgPool::connect(&database_url).await.unwrap();
    
    // 运行数据库迁移
    sqlx::migrate!("./migrations").run(&pool).await.unwrap();
    
    // 创建用户仓库和服务
    let user_repo = PostgresUserRepository::new(pool);
    let user_service = UserService::new(Box::new(user_repo));
    
    // 测试事务回滚
    let user_request = CreateUserRequest {
        name: "John Doe".to_string(),
        email: "john@example.com".to_string(),
    };
    
    // 第一次创建应该成功
    let result1 = user_service.create_user(user_request.clone()).await;
    assert!(result1.is_ok());
    
    // 第二次创建相同邮箱应该失败
    let result2 = user_service.create_user(user_request).await;
    assert!(result2.is_err());
    
    // 验证只有一个用户被创建
    let users = user_service.list_users(10, 0).await.unwrap();
    assert_eq!(users.len(), 1);
}
```

### 端到端测试实现

```rust
// tests/e2e/user_api_e2e_test.rs
use testcontainers::{Container, Docker, GenericImage};
use testcontainers::core::WaitFor;
use testcontainers::runners::AsyncRunner;
use microservice::app::create_app;
use axum::http::StatusCode;
use serde_json::json;
use tokio_test;

#[tokio::test]
async fn test_user_api_e2e() {
    // 启动PostgreSQL容器
    let postgres_image = GenericImage::new("postgres", "15")
        .with_env_var("POSTGRES_PASSWORD", "password")
        .with_env_var("POSTGRES_DB", "testdb")
        .with_exposed_port(5432)
        .with_wait_for(WaitFor::message_on_stderr("database system is ready to accept connections"));
    
    let postgres_container = postgres_image.start().await;
    let postgres_port = postgres_container.get_host_port_ipv4(5432).await;
    
    // 创建数据库连接
    let database_url = format!("postgresql://postgres:password@localhost:{}/testdb", postgres_port);
    let pool = sqlx::PgPool::connect(&database_url).await.unwrap();
    
    // 运行数据库迁移
    sqlx::migrate!("./migrations").run(&pool).await.unwrap();
    
    // 创建应用
    let app = create_app(pool).await;
    
    // 测试用户创建API
    let user_data = json!({
        "name": "John Doe",
        "email": "john@example.com"
    });
    
    let response = app
        .post("/api/users")
        .json(&user_data)
        .send()
        .await
        .unwrap();
    
    assert_eq!(response.status(), StatusCode::CREATED);
    
    let user: serde_json::Value = response.json().await.unwrap();
    assert_eq!(user["name"], "John Doe");
    assert_eq!(user["email"], "john@example.com");
    
    let user_id = user["id"].as_u64().unwrap();
    
    // 测试用户查询API
    let response = app
        .get(&format!("/api/users/{}", user_id))
        .send()
        .await
        .unwrap();
    
    assert_eq!(response.status(), StatusCode::OK);
    
    let user: serde_json::Value = response.json().await.unwrap();
    assert_eq!(user["name"], "John Doe");
    assert_eq!(user["email"], "john@example.com");
    
    // 测试用户列表API
    let response = app
        .get("/api/users?limit=10&offset=0")
        .send()
        .await
        .unwrap();
    
    assert_eq!(response.status(), StatusCode::OK);
    
    let users: serde_json::Value = response.json().await.unwrap();
    assert!(users["users"].is_array());
    assert_eq!(users["users"].as_array().unwrap().len(), 1);
    
    // 测试用户更新API
    let update_data = json!({
        "name": "Jane Doe",
        "email": "jane@example.com"
    });
    
    let response = app
        .put(&format!("/api/users/{}", user_id))
        .json(&update_data)
        .send()
        .await
        .unwrap();
    
    assert_eq!(response.status(), StatusCode::OK);
    
    let user: serde_json::Value = response.json().await.unwrap();
    assert_eq!(user["name"], "Jane Doe");
    assert_eq!(user["email"], "jane@example.com");
    
    // 测试用户删除API
    let response = app
        .delete(&format!("/api/users/{}", user_id))
        .send()
        .await
        .unwrap();
    
    assert_eq!(response.status(), StatusCode::NO_CONTENT);
    
    // 验证用户已被删除
    let response = app
        .get(&format!("/api/users/{}", user_id))
        .send()
        .await
        .unwrap();
    
    assert_eq!(response.status(), StatusCode::NOT_FOUND);
}
```

### 混沌工程实现

```rust
// tests/chaos/chaos_engineering_test.rs
use microservice::chaos::chaos_engine::{ChaosEngine, ChaosExperiment, FailureType};
use microservice::services::user_service::UserService;
use microservice::repositories::user_repository::PostgresUserRepository;
use microservice::models::user::{User, CreateUserRequest};
use tokio::time::{Duration, sleep};
use tokio_test;

#[tokio::test]
async fn test_network_partition_chaos() {
    let chaos_engine = ChaosEngine::new();
    
    // 创建网络分区实验
    let experiment = ChaosExperiment {
        name: "network_partition".to_string(),
        failure_type: FailureType::NetworkPartition,
        duration: Duration::from_secs(30),
        target_services: vec!["user-service".to_string()],
        parameters: std::collections::HashMap::new(),
    };
    
    // 启动混沌实验
    chaos_engine.start_experiment(experiment).await.unwrap();
    
    // 等待网络分区生效
    sleep(Duration::from_secs(5)).await;
    
    // 测试服务在网络分区下的行为
    let user_service = create_user_service().await;
    let user_request = CreateUserRequest {
        name: "John Doe".to_string(),
        email: "john@example.com".to_string(),
    };
    
    // 服务应该能够处理网络分区
    let result = user_service.create_user(user_request).await;
    
    // 验证服务能够优雅地处理网络分区
    match result {
        Ok(_) => {
            // 如果成功，说明服务有重试机制
            println!("Service handled network partition gracefully");
        }
        Err(e) => {
            // 如果失败，错误应该是可预期的
            assert!(e.to_string().contains("network") || e.to_string().contains("timeout"));
        }
    }
    
    // 停止混沌实验
    chaos_engine.stop_experiment("network_partition").await.unwrap();
    
    // 等待网络恢复
    sleep(Duration::from_secs(5)).await;
    
    // 验证服务恢复正常
    let user_request = CreateUserRequest {
        name: "Jane Doe".to_string(),
        email: "jane@example.com".to_string(),
    };
    
    let result = user_service.create_user(user_request).await;
    assert!(result.is_ok());
}

#[tokio::test]
async fn test_database_failure_chaos() {
    let chaos_engine = ChaosEngine::new();
    
    // 创建数据库故障实验
    let experiment = ChaosExperiment {
        name: "database_failure".to_string(),
        failure_type: FailureType::DatabaseFailure,
        duration: Duration::from_secs(20),
        target_services: vec!["user-service".to_string()],
        parameters: std::collections::HashMap::new(),
    };
    
    // 启动混沌实验
    chaos_engine.start_experiment(experiment).await.unwrap();
    
    // 等待数据库故障生效
    sleep(Duration::from_secs(3)).await;
    
    // 测试服务在数据库故障下的行为
    let user_service = create_user_service().await;
    let user_request = CreateUserRequest {
        name: "John Doe".to_string(),
        email: "john@example.com".to_string(),
    };
    
    // 服务应该能够处理数据库故障
    let result = user_service.create_user(user_request).await;
    
    // 验证服务能够优雅地处理数据库故障
    match result {
        Ok(_) => {
            // 如果成功，说明服务有故障转移机制
            println!("Service handled database failure gracefully");
        }
        Err(e) => {
            // 如果失败，错误应该是可预期的
            assert!(e.to_string().contains("database") || e.to_string().contains("connection"));
        }
    }
    
    // 停止混沌实验
    chaos_engine.stop_experiment("database_failure").await.unwrap();
    
    // 等待数据库恢复
    sleep(Duration::from_secs(5)).await;
    
    // 验证服务恢复正常
    let user_request = CreateUserRequest {
        name: "Jane Doe".to_string(),
        email: "jane@example.com".to_string(),
    };
    
    let result = user_service.create_user(user_request).await;
    assert!(result.is_ok());
}

#[tokio::test]
async fn test_memory_pressure_chaos() {
    let chaos_engine = ChaosEngine::new();
    
    // 创建内存压力实验
    let experiment = ChaosExperiment {
        name: "memory_pressure".to_string(),
        failure_type: FailureType::MemoryPressure,
        duration: Duration::from_secs(15),
        target_services: vec!["user-service".to_string()],
        parameters: std::collections::HashMap::new(),
    };
    
    // 启动混沌实验
    chaos_engine.start_experiment(experiment).await.unwrap();
    
    // 等待内存压力生效
    sleep(Duration::from_secs(3)).await;
    
    // 测试服务在内存压力下的行为
    let user_service = create_user_service().await;
    
    // 创建大量用户来测试内存压力
    let mut tasks = Vec::new();
    for i in 0..100 {
        let user_request = CreateUserRequest {
            name: format!("User {}", i),
            email: format!("user{}@example.com", i),
        };
        
        let task = tokio::spawn(async move {
            user_service.create_user(user_request).await
        });
        
        tasks.push(task);
    }
    
    // 等待所有任务完成
    let mut success_count = 0;
    let mut failure_count = 0;
    
    for task in tasks {
        match task.await.unwrap() {
            Ok(_) => success_count += 1,
            Err(_) => failure_count += 1,
        }
    }
    
    // 验证服务在内存压力下仍能处理大部分请求
    assert!(success_count > failure_count);
    println!("Memory pressure test: {} successes, {} failures", success_count, failure_count);
    
    // 停止混沌实验
    chaos_engine.stop_experiment("memory_pressure").await.unwrap();
}

async fn create_user_service() -> UserService {
    // 创建用户服务的实现
    // 这里应该根据实际的依赖注入方式来实现
    todo!()
}
```

### 混沌引擎实现

```rust
// src/chaos/chaos_engine.rs
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use tokio::time::{Duration, sleep};
use tracing::{info, warn, error};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FailureType {
    NetworkPartition,
    DatabaseFailure,
    MemoryPressure,
    CPUPressure,
    DiskFailure,
    ServiceFailure,
    LatencyInjection,
    ErrorInjection,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChaosExperiment {
    pub name: String,
    pub failure_type: FailureType,
    pub duration: Duration,
    pub target_services: Vec<String>,
    pub parameters: HashMap<String, String>,
}

#[derive(Debug, Clone)]
pub struct ChaosResult {
    pub experiment_name: String,
    pub success: bool,
    pub error_message: Option<String>,
    pub duration: Duration,
    pub metrics: HashMap<String, f64>,
}

pub struct ChaosEngine {
    active_experiments: HashMap<String, ChaosExperiment>,
    experiment_results: Vec<ChaosResult>,
}

impl ChaosEngine {
    pub fn new() -> Self {
        Self {
            active_experiments: HashMap::new(),
            experiment_results: Vec::new(),
        }
    }
    
    pub async fn start_experiment(&mut self, experiment: ChaosExperiment) -> Result<(), Box<dyn std::error::Error>> {
        let experiment_name = experiment.name.clone();
        
        info!("Starting chaos experiment: {}", experiment_name);
        
        // 检查是否已有同名实验在运行
        if self.active_experiments.contains_key(&experiment_name) {
            return Err(format!("Experiment {} is already running", experiment_name).into());
        }
        
        // 启动实验
        match experiment.failure_type {
            FailureType::NetworkPartition => {
                self.start_network_partition(&experiment).await?;
            }
            FailureType::DatabaseFailure => {
                self.start_database_failure(&experiment).await?;
            }
            FailureType::MemoryPressure => {
                self.start_memory_pressure(&experiment).await?;
            }
            FailureType::CPUPressure => {
                self.start_cpu_pressure(&experiment).await?;
            }
            FailureType::DiskFailure => {
                self.start_disk_failure(&experiment).await?;
            }
            FailureType::ServiceFailure => {
                self.start_service_failure(&experiment).await?;
            }
            FailureType::LatencyInjection => {
                self.start_latency_injection(&experiment).await?;
            }
            FailureType::ErrorInjection => {
                self.start_error_injection(&experiment).await?;
            }
        }
        
        // 记录活跃实验
        self.active_experiments.insert(experiment_name.clone(), experiment);
        
        // 设置实验超时
        let experiment_duration = self.active_experiments[&experiment_name].duration;
        tokio::spawn(async move {
            sleep(experiment_duration).await;
            // 实验超时后自动停止
        });
        
        Ok(())
    }
    
    pub async fn stop_experiment(&mut self, experiment_name: &str) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(experiment) = self.active_experiments.remove(experiment_name) {
            info!("Stopping chaos experiment: {}", experiment_name);
            
            // 停止实验
            match experiment.failure_type {
                FailureType::NetworkPartition => {
                    self.stop_network_partition(&experiment).await?;
                }
                FailureType::DatabaseFailure => {
                    self.stop_database_failure(&experiment).await?;
                }
                FailureType::MemoryPressure => {
                    self.stop_memory_pressure(&experiment).await?;
                }
                FailureType::CPUPressure => {
                    self.stop_cpu_pressure(&experiment).await?;
                }
                FailureType::DiskFailure => {
                    self.stop_disk_failure(&experiment).await?;
                }
                FailureType::ServiceFailure => {
                    self.stop_service_failure(&experiment).await?;
                }
                FailureType::LatencyInjection => {
                    self.stop_latency_injection(&experiment).await?;
                }
                FailureType::ErrorInjection => {
                    self.stop_error_injection(&experiment).await?;
                }
            }
            
            Ok(())
        } else {
            Err(format!("Experiment {} is not running", experiment_name).into())
        }
    }
    
    pub fn get_active_experiments(&self) -> Vec<String> {
        self.active_experiments.keys().cloned().collect()
    }
    
    pub fn get_experiment_results(&self) -> &Vec<ChaosResult> {
        &self.experiment_results
    }
    
    // 网络分区实现
    async fn start_network_partition(&self, experiment: &ChaosExperiment) -> Result<(), Box<dyn std::error::Error>> {
        info!("Starting network partition for services: {:?}", experiment.target_services);
        
        // 这里应该实现实际的网络分区逻辑
        // 例如使用iptables规则或网络命名空间
        
        Ok(())
    }
    
    async fn stop_network_partition(&self, experiment: &ChaosExperiment) -> Result<(), Box<dyn std::error::Error>> {
        info!("Stopping network partition for services: {:?}", experiment.target_services);
        
        // 恢复网络连接
        
        Ok(())
    }
    
    // 数据库故障实现
    async fn start_database_failure(&self, experiment: &ChaosExperiment) -> Result<(), Box<dyn std::error::Error>> {
        info!("Starting database failure for services: {:?}", experiment.target_services);
        
        // 这里应该实现实际的数据库故障逻辑
        // 例如停止数据库服务或模拟连接超时
        
        Ok(())
    }
    
    async fn stop_database_failure(&self, experiment: &ChaosExperiment) -> Result<(), Box<dyn std::error::Error>> {
        info!("Stopping database failure for services: {:?}", experiment.target_services);
        
        // 恢复数据库服务
        
        Ok(())
    }
    
    // 内存压力实现
    async fn start_memory_pressure(&self, experiment: &ChaosExperiment) -> Result<(), Box<dyn std::error::Error>> {
        info!("Starting memory pressure for services: {:?}", experiment.target_services);
        
        // 这里应该实现实际的内存压力逻辑
        // 例如分配大量内存或限制可用内存
        
        Ok(())
    }
    
    async fn stop_memory_pressure(&self, experiment: &ChaosExperiment) -> Result<(), Box<dyn std::error::Error>> {
        info!("Stopping memory pressure for services: {:?}", experiment.target_services);
        
        // 释放内存压力
        
        Ok(())
    }
    
    // 其他故障类型的实现...
    async fn start_cpu_pressure(&self, _experiment: &ChaosExperiment) -> Result<(), Box<dyn std::error::Error>> {
        Ok(())
    }
    
    async fn stop_cpu_pressure(&self, _experiment: &ChaosExperiment) -> Result<(), Box<dyn std::error::Error>> {
        Ok(())
    }
    
    async fn start_disk_failure(&self, _experiment: &ChaosExperiment) -> Result<(), Box<dyn std::error::Error>> {
        Ok(())
    }
    
    async fn stop_disk_failure(&self, _experiment: &ChaosExperiment) -> Result<(), Box<dyn std::error::Error>> {
        Ok(())
    }
    
    async fn start_service_failure(&self, _experiment: &ChaosExperiment) -> Result<(), Box<dyn std::error::Error>> {
        Ok(())
    }
    
    async fn stop_service_failure(&self, _experiment: &ChaosExperiment) -> Result<(), Box<dyn std::error::Error>> {
        Ok(())
    }
    
    async fn start_latency_injection(&self, _experiment: &ChaosExperiment) -> Result<(), Box<dyn std::error::Error>> {
        Ok(())
    }
    
    async fn stop_latency_injection(&self, _experiment: &ChaosExperiment) -> Result<(), Box<dyn std::error::Error>> {
        Ok(())
    }
    
    async fn start_error_injection(&self, _experiment: &ChaosExperiment) -> Result<(), Box<dyn std::error::Error>> {
        Ok(())
    }
    
    async fn stop_error_injection(&self, _experiment: &ChaosExperiment) -> Result<(), Box<dyn std::error::Error>> {
        Ok(())
    }
}
```

## 最佳实践

### 1. 测试策略

- **测试金字塔**: 单元测试 > 集成测试 > 端到端测试
- **测试隔离**: 每个测试应该独立运行
- **测试数据**: 使用测试专用的数据源

### 2. 混沌工程1

- **渐进式实验**: 从低风险实验开始
- **监控指标**: 实时监控系统状态
- **快速恢复**: 确保能够快速停止实验

### 3. 测试自动化1

- **CI/CD集成**: 自动化测试执行
- **质量门禁**: 基于测试结果的部署控制
- **测试报告**: 详细的测试结果分析

### 4. 性能测试

- **负载测试**: 验证系统在正常负载下的性能
- **压力测试**: 验证系统的极限性能
- **稳定性测试**: 验证系统在长时间运行下的稳定性

## 部署配置

### CI/CD配置

```yaml
# .github/workflows/test.yml
name: Test Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          components: rustfmt, clippy
      
      - name: Run unit tests
        run: cargo test --lib
      
      - name: Run clippy
        run: cargo clippy -- -D warnings
      
      - name: Run fmt check
        run: cargo fmt -- --check

  integration-tests:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: password
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
      - uses: actions/checkout@v3
      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      
      - name: Run integration tests
        run: cargo test --test integration
        env:
          DATABASE_URL: postgresql://postgres:password@localhost:5432/testdb

  e2e-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      
      - name: Run E2E tests
        run: cargo test --test e2e

  chaos-tests:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v3
      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      
      - name: Run chaos tests
        run: cargo test --test chaos
```

### 测试配置

```toml
# Cargo.toml
[profile.test]
opt-level = 0
debug = true
overflow-checks = true

[profile.bench]
opt-level = 3
debug = false
lto = true
codegen-units = 1

[[bench]]
name = "user_service_bench"
harness = false
```

## 性能测试

### 基准测试

```rust
// benches/user_service_bench.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use microservice::services::user_service::UserService;
use microservice::repositories::user_repository::PostgresUserRepository;
use microservice::models::user::CreateUserRequest;

fn benchmark_user_creation(c: &mut Criterion) {
    let rt = tokio::runtime::Runtime::new().unwrap();
    let user_service = rt.block_on(create_user_service());
    
    c.bench_function("user_creation", |b| {
        b.iter(|| {
            let user_request = CreateUserRequest {
                name: black_box("John Doe".to_string()),
                email: black_box("john@example.com".to_string()),
            };
            
            rt.block_on(user_service.create_user(user_request)).unwrap();
        })
    });
}

fn benchmark_user_query(c: &mut Criterion) {
    let rt = tokio::runtime::Runtime::new().unwrap();
    let user_service = rt.block_on(create_user_service());
    
    // 创建测试用户
    let user_request = CreateUserRequest {
        name: "John Doe".to_string(),
        email: "john@example.com".to_string(),
    };
    let user = rt.block_on(user_service.create_user(user_request)).unwrap();
    
    c.bench_function("user_query", |b| {
        b.iter(|| {
            rt.block_on(user_service.get_user(black_box(user.id))).unwrap();
        })
    });
}

criterion_group!(benches, benchmark_user_creation, benchmark_user_query);
criterion_main!(benches);

async fn create_user_service() -> UserService {
    // 创建用户服务的实现
    todo!()
}
```

## 总结

本指南详细介绍了如何在Rust微服务中实现全面的测试策略，包括：

1. **单元测试**: 使用mock和属性测试验证业务逻辑
2. **集成测试**: 使用testcontainers验证服务间交互
3. **端到端测试**: 验证完整的API流程
4. **混沌工程**: 使用故障注入验证系统弹性
5. **测试自动化**: CI/CD集成和质量门禁
6. **性能测试**: 基准测试和负载测试

通过这套完整的测试体系，可以确保微服务系统的可靠性、稳定性和性能，为生产环境提供高质量的服务。
