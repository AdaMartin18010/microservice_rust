# 11.5 形式化验证 TLA+ 入门

> 使用 TLA+ 和 Apalache 对微服务系统进行形式化验证，确保关键属性的正确性

## 11.5.1 概述

形式化验证通过数学方法证明系统满足特定属性，在微服务架构中特别重要：

- **一致性保证**：验证分布式事务的一致性
- **安全性验证**：确保认证和授权策略的正确性
- **活性验证**：证明系统不会出现死锁或活锁
- **容错性验证**：验证故障恢复机制的有效性

## 11.5.2 TLA+ 基础语法

### 基本结构

```tla
---- MODULE MicroserviceVerification ----
EXTENDS Naturals, Sequences, FiniteSets, TLC

CONSTANTS
    MaxRetries,     \* 最大重试次数
    Timeout,        \* 超时时间
    Services        \* 服务集合

VARIABLES
    serviceStates,  \* 服务状态
    messages,       \* 消息队列
    retryCounts     \* 重试计数

TypeOK ==
    /\ serviceStates \in [Services -> {"idle", "processing", "failed"}]
    /\ messages \in Seq(Message)
    /\ retryCounts \in [Services -> 0..MaxRetries]

Init ==
    /\ serviceStates = [s \in Services |-> "idle"]
    /\ messages = <<>>
    /\ retryCounts = [s \in Services |-> 0]

Next ==
    \/ ProcessMessage
    \/ RetryFailedMessage
    \/ TimeoutMessage

Spec == Init /\ [][Next]_<<serviceStates, messages, retryCounts>>

====
```

### 消息处理模型

```tla
Message == [type: {"request", "response"}, 
            id: Nat, 
            service: Services, 
            data: STRING,
            timestamp: Nat]

ProcessMessage ==
    /\ messages /= <<>>
    /\ LET msg == Head(messages)
       IN /\ serviceStates[msg.service] = "idle"
          /\ serviceStates' = [serviceStates EXCEPT ![msg.service] = "processing"]
          /\ messages' = Tail(messages)
          /\ retryCounts' = retryCounts
          /\ UNCHANGED <<>>

RetryFailedMessage ==
    /\ \E s \in Services :
        /\ serviceStates[s] = "failed"
        /\ retryCounts[s] < MaxRetries
        /\ serviceStates' = [serviceStates EXCEPT ![s] = "idle"]
        /\ retryCounts' = [retryCounts EXCEPT ![s] = @ + 1]
        /\ messages' = messages
```

## 11.5.3 微服务一致性验证

### Saga 模式验证

```tla
---- MODULE SagaVerification ----
EXTENDS Naturals, Sequences, FiniteSets, TLC

CONSTANTS
    Steps,          \* Saga 步骤集合
    MaxSteps        \* 最大步骤数

VARIABLES
    sagaState,      \* Saga 状态
    stepStates,     \* 步骤状态
    compensationLog \* 补偿日志

SagaState == {"not_started", "in_progress", "completed", "compensating", "compensated"}

StepState == {"pending", "executing", "completed", "failed", "compensating", "compensated"}

TypeOK ==
    /\ sagaState \in SagaState
    /\ stepStates \in [Steps -> StepState]
    /\ compensationLog \in Seq(Steps)

Init ==
    /\ sagaState = "not_started"
    /\ stepStates = [s \in Steps |-> "pending"]
    /\ compensationLog = <<>>

ExecuteStep(step) ==
    /\ stepStates[step] = "pending"
    /\ stepStates' = [stepStates EXCEPT ![step] = "executing"]
    /\ sagaState' = IF sagaState = "not_started" THEN "in_progress" ELSE sagaState
    /\ compensationLog' = compensationLog

CompleteStep(step) ==
    /\ stepStates[step] = "executing"
    /\ stepStates' = [stepStates EXCEPT ![step] = "completed"]
    /\ sagaState' = IF \A s \in Steps : stepStates[s] = "completed" 
                   THEN "completed" 
                   ELSE sagaState
    /\ compensationLog' = compensationLog

FailStep(step) ==
    /\ stepStates[step] = "executing"
    /\ stepStates' = [stepStates EXCEPT ![step] = "failed"]
    /\ sagaState' = "compensating"
    /\ compensationLog' = compensationLog

CompensateStep(step) ==
    /\ stepStates[step] = "completed"
    /\ stepStates' = [stepStates EXCEPT ![step] = "compensating"]
    /\ compensationLog' = Append(compensationLog, step)

CompleteCompensation(step) ==
    /\ stepStates[step] = "compensating"
    /\ stepStates' = [stepStates EXCEPT ![step] = "compensated"]
    /\ sagaState' = IF \A s \in Steps : stepStates[s] \in {"compensated", "pending"}
                   THEN "compensated"
                   ELSE sagaState
    /\ compensationLog' = compensationLog

Next ==
    \/ \E step \in Steps : ExecuteStep(step)
    \/ \E step \in Steps : CompleteStep(step)
    \/ \E step \in Steps : FailStep(step)
    \/ \E step \in Steps : CompensateStep(step)
    \/ \E step \in Steps : CompleteCompensation(step)

Spec == Init /\ [][Next]_<<sagaState, stepStates, compensationLog>>

====
```

### 一致性属性

```tla
---- MODULE ConsistencyProperties ----
EXTENDS SagaVerification

\* 属性1：Saga 要么完全成功，要么完全补偿
SagaCompletion ==
    \/ (sagaState = "completed" /\ \A s \in Steps : stepStates[s] = "completed")
    \/ (sagaState = "compensated" /\ \A s \in Steps : stepStates[s] \in {"compensated", "pending"})

\* 属性2：不会出现部分完成状态
NoPartialCompletion ==
    ~(sagaState = "in_progress" /\ \E s1, s2 \in Steps : 
      stepStates[s1] = "completed" /\ stepStates[s2] = "compensated")

\* 属性3：补偿顺序与执行顺序相反
CompensationOrder ==
    \A i, j \in DOMAIN compensationLog :
        i < j => compensationLog[i] /= compensationLog[j]

\* 属性4：每个步骤最多执行一次
StepExecutedOnce ==
    \A step \in Steps :
        Cardinality({i \in DOMAIN compensationLog : compensationLog[i] = step}) <= 1

====
```

## 11.5.4 熔断器模式验证

### 熔断器状态机

```tla
---- MODULE CircuitBreakerVerification ----
EXTENDS Naturals, FiniteSets, TLC

CONSTANTS
    FailureThreshold,   \* 失败阈值
    SuccessThreshold,   \* 成功阈值
    Timeout            \* 超时时间

VARIABLES
    cbState,           \* 熔断器状态
    failureCount,      \* 失败计数
    successCount,      \* 成功计数
    lastFailureTime    \* 最后失败时间

CBState == {"closed", "open", "half_open"}

TypeOK ==
    /\ cbState \in CBState
    /\ failureCount \in 0..FailureThreshold
    /\ successCount \in 0..SuccessThreshold
    /\ lastFailureTime \in Nat

Init ==
    /\ cbState = "closed"
    /\ failureCount = 0
    /\ successCount = 0
    /\ lastFailureTime = 0

RequestSuccess ==
    /\ cbState \in {"closed", "half_open"}
    /\ failureCount' = 0
    /\ successCount' = IF cbState = "half_open" THEN successCount + 1 ELSE 0
    /\ lastFailureTime' = lastFailureTime
    /\ cbState' = IF cbState = "half_open" /\ successCount' >= SuccessThreshold
                  THEN "closed"
                  ELSE cbState

RequestFailure ==
    /\ cbState \in {"closed", "half_open"}
    /\ failureCount' = failureCount + 1
    /\ successCount' = 0
    /\ lastFailureTime' = 0  \* 简化：假设当前时间
    /\ cbState' = IF failureCount' >= FailureThreshold
                  THEN "open"
                  ELSE cbState

TimeoutExpired ==
    /\ cbState = "open"
    /\ failureCount' = failureCount
    /\ successCount' = 0
    /\ lastFailureTime' = lastFailureTime
    /\ cbState' = "half_open"

Next ==
    \/ RequestSuccess
    \/ RequestFailure
    \/ TimeoutExpired

Spec == Init /\ [][Next]_<<cbState, failureCount, successCount, lastFailureTime>>

====
```

### 熔断器属性

```tla
---- MODULE CircuitBreakerProperties ----
EXTENDS CircuitBreakerVerification

\* 属性1：熔断器不会在开放状态下处理请求
NoRequestsWhenOpen ==
    cbState /= "open" \/ failureCount < FailureThreshold

\* 属性2：熔断器最终会从开放状态转换
EventuallyRecovers ==
    cbState = "open" ~> cbState = "half_open"

\* 属性3：成功请求会重置失败计数
SuccessResetsFailures ==
    RequestSuccess => failureCount' = 0

====
```

## 11.5.5 消息队列一致性验证

### 消息处理模型1

```tla
---- MODULE MessageQueueVerification ----
EXTENDS Naturals, Sequences, FiniteSets, TLC

CONSTANTS
    MaxMessages,     \* 最大消息数
    MaxRetries       \* 最大重试次数

VARIABLES
    queue,           \* 消息队列
    processing,      \* 正在处理的消息
    processed,       \* 已处理的消息
    failed,          \* 失败的消息
    retryCount       \* 重试计数

Message == [id: Nat, data: STRING, timestamp: Nat]

TypeOK ==
    /\ queue \in Seq(Message)
    /\ processing \in Seq(Message)
    /\ processed \in Seq(Message)
    /\ failed \in Seq(Message)
    /\ retryCount \in [Message -> 0..MaxRetries]

Init ==
    /\ queue = <<>>
    /\ processing = <<>>
    /\ processed = <<>>
    /\ failed = <<>>
    /\ retryCount = [m \in Message |-> 0]

DequeueMessage ==
    /\ queue /= <<>>
    /\ LET msg == Head(queue)
       IN /\ queue' = Tail(queue)
          /\ processing' = Append(processing, msg)
          /\ UNCHANGED <<processed, failed, retryCount>>

ProcessMessage ==
    /\ processing /= <<>>
    /\ LET msg == Head(processing)
       IN /\ processing' = Tail(processing)
          /\ processed' = Append(processed, msg)
          /\ UNCHANGED <<queue, failed, retryCount>>

FailMessage ==
    /\ processing /= <<>>
    /\ LET msg == Head(processing)
       IN /\ processing' = Tail(processing)
          /\ retryCount' = [retryCount EXCEPT ![msg] = @ + 1]
          /\ failed' = IF retryCount[msg] < MaxRetries
                       THEN Append(failed, msg)
                       ELSE failed
          /\ UNCHANGED <<queue, processed>>

RetryMessage ==
    /\ failed /= <<>>
    /\ LET msg == Head(failed)
       IN /\ failed' = Tail(failed)
          /\ queue' = Append(queue, msg)
          /\ UNCHANGED <<processing, processed, retryCount>>

Next ==
    \/ DequeueMessage
    \/ ProcessMessage
    \/ FailMessage
    \/ RetryMessage

Spec == Init /\ [][Next]_<<queue, processing, processed, failed, retryCount>>

====
```

### 消息队列属性

```tla
---- MODULE MessageQueueProperties ----
EXTENDS MessageQueueVerification

\* 属性1：消息不会丢失
NoMessageLoss ==
    \A msg \in Message :
        msg \in queue \/ msg \in processing \/ msg \in processed \/ msg \in failed

\* 属性2：消息不会重复处理
NoDuplicateProcessing ==
    \A msg \in Message :
        Cardinality({i \in DOMAIN processed : processed[i] = msg}) <= 1

\* 属性3：失败消息最终会重试
FailedMessagesEventuallyRetry ==
    \A msg \in Message :
        msg \in failed ~> msg \in queue

\* 属性4：重试次数有上限
RetryCountBounded ==
    \A msg \in Message :
        retryCount[msg] <= MaxRetries

====
```

## 11.5.6 Apalache 模型检查

### 配置文件

```json
{
  "spec": "MicroserviceVerification",
  "constants": {
    "MaxRetries": 3,
    "Timeout": 30,
    "Services": {"user", "order", "payment"}
  },
  "invariants": [
    "TypeOK",
    "SagaCompletion",
    "NoPartialCompletion"
  ],
  "temporal": [
    "EventuallyRecovers",
    "FailedMessagesEventuallyRetry"
  ],
  "length": 100
}
```

### 运行模型检查

```bash
# 安装 Apalache
docker pull apalache/mc:latest

# 运行模型检查
docker run -v $(pwd):/var/apalache apalache/mc:latest check \
  --config=config.json \
  MicroserviceVerification.tla
```

## 11.5.7 Rust 代码集成

### 类型安全的状态机

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum SagaState {
    NotStarted,
    InProgress,
    Completed,
    Compensating,
    Compensated,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum StepState {
    Pending,
    Executing,
    Completed,
    Failed,
    Compensating,
    Compensated,
}

#[derive(Debug, Clone)]
pub struct Saga {
    pub state: SagaState,
    pub step_states: HashMap<String, StepState>,
    pub compensation_log: Vec<String>,
}

impl Saga {
    pub fn new(steps: Vec<String>) -> Self {
        Self {
            state: SagaState::NotStarted,
            step_states: steps.into_iter()
                .map(|step| (step, StepState::Pending))
                .collect(),
            compensation_log: Vec::new(),
        }
    }
    
    pub fn execute_step(&mut self, step: &str) -> Result<(), String> {
        if let Some(StepState::Pending) = self.step_states.get(step) {
            self.step_states.insert(step.to_string(), StepState::Executing);
            if self.state == SagaState::NotStarted {
                self.state = SagaState::InProgress;
            }
            Ok(())
        } else {
            Err(format!("Step {} is not in pending state", step))
        }
    }
    
    pub fn complete_step(&mut self, step: &str) -> Result<(), String> {
        if let Some(StepState::Executing) = self.step_states.get(step) {
            self.step_states.insert(step.to_string(), StepState::Completed);
            if self.all_steps_completed() {
                self.state = SagaState::Completed;
            }
            Ok(())
        } else {
            Err(format!("Step {} is not in executing state", step))
        }
    }
    
    pub fn fail_step(&mut self, step: &str) -> Result<(), String> {
        if let Some(StepState::Executing) = self.step_states.get(step) {
            self.step_states.insert(step.to_string(), StepState::Failed);
            self.state = SagaState::Compensating;
            Ok(())
        } else {
            Err(format!("Step {} is not in executing state", step))
        }
    }
    
    fn all_steps_completed(&self) -> bool {
        self.step_states.values()
            .all(|state| *state == StepState::Completed)
    }
    
    // 验证 Saga 完成性属性
    pub fn verify_completion(&self) -> bool {
        match self.state {
            SagaState::Completed => {
                self.step_states.values()
                    .all(|state| *state == StepState::Completed)
            }
            SagaState::Compensated => {
                self.step_states.values()
                    .all(|state| matches!(state, StepState::Compensated | StepState::Pending))
            }
            _ => false,
        }
    }
}
```

### 熔断器实现

```rust
#[derive(Debug, Clone, PartialEq)]
pub enum CircuitBreakerState {
    Closed,
    Open,
    HalfOpen,
}

pub struct CircuitBreaker {
    state: CircuitBreakerState,
    failure_count: u32,
    success_count: u32,
    failure_threshold: u32,
    success_threshold: u32,
    timeout: std::time::Duration,
    last_failure_time: Option<std::time::Instant>,
}

impl CircuitBreaker {
    pub fn new(
        failure_threshold: u32,
        success_threshold: u32,
        timeout: std::time::Duration,
    ) -> Self {
        Self {
            state: CircuitBreakerState::Closed,
            failure_count: 0,
            success_count: 0,
            failure_threshold,
            success_threshold,
            timeout,
            last_failure_time: None,
        }
    }
    
    pub fn call<F, T, E>(&mut self, f: F) -> Result<T, E>
    where
        F: FnOnce() -> Result<T, E>,
    {
        if self.state == CircuitBreakerState::Open {
            if let Some(last_failure) = self.last_failure_time {
                if last_failure.elapsed() >= self.timeout {
                    self.state = CircuitBreakerState::HalfOpen;
                    self.success_count = 0;
                } else {
                    return Err("Circuit breaker is open".into());
                }
            }
        }
        
        match f() {
            Ok(result) => {
                self.on_success();
                Ok(result)
            }
            Err(error) => {
                self.on_failure();
                Err(error)
            }
        }
    }
    
    fn on_success(&mut self) {
        self.failure_count = 0;
        if self.state == CircuitBreakerState::HalfOpen {
            self.success_count += 1;
            if self.success_count >= self.success_threshold {
                self.state = CircuitBreakerState::Closed;
            }
        }
    }
    
    fn on_failure(&mut self) {
        self.failure_count += 1;
        self.success_count = 0;
        self.last_failure_time = Some(std::time::Instant::now());
        
        if self.failure_count >= self.failure_threshold {
            self.state = CircuitBreakerState::Open;
        }
    }
    
    // 验证熔断器属性
    pub fn verify_no_requests_when_open(&self) -> bool {
        self.state != CircuitBreakerState::Open || self.failure_count < self.failure_threshold
    }
}
```

## 11.5.8 测试与验证

### 单元测试

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_saga_completion() {
        let mut saga = Saga::new(vec!["step1".to_string(), "step2".to_string()]);
        
        // 执行所有步骤
        saga.execute_step("step1").unwrap();
        saga.complete_step("step1").unwrap();
        saga.execute_step("step2").unwrap();
        saga.complete_step("step2").unwrap();
        
        assert!(saga.verify_completion());
        assert_eq!(saga.state, SagaState::Completed);
    }
    
    #[test]
    fn test_saga_compensation() {
        let mut saga = Saga::new(vec!["step1".to_string(), "step2".to_string()]);
        
        // 执行第一个步骤
        saga.execute_step("step1").unwrap();
        saga.complete_step("step1").unwrap();
        
        // 第二个步骤失败
        saga.execute_step("step2").unwrap();
        saga.fail_step("step2").unwrap();
        
        assert_eq!(saga.state, SagaState::Compensating);
    }
    
    #[test]
    fn test_circuit_breaker() {
        let mut cb = CircuitBreaker::new(3, 2, std::time::Duration::from_secs(1));
        
        // 模拟失败
        for _ in 0..3 {
            let _ = cb.call(|| Err::<(), &str>("error"));
        }
        
        assert_eq!(cb.state, CircuitBreakerState::Open);
        assert!(cb.verify_no_requests_when_open());
    }
}
```

## 11.5.9 总结

TLA+ 形式化验证为微服务系统提供了数学级别的正确性保证：

1. **Saga 模式**：确保分布式事务的原子性和一致性
2. **熔断器**：验证故障隔离和恢复机制
3. **消息队列**：保证消息处理的可靠性和一致性
4. **类型安全**：Rust 类型系统与 TLA+ 模型的对应关系

通过结合 TLA+ 规范和 Rust 的类型安全特性，可以构建既具有数学正确性保证又具有运行时安全性的微服务系统。
