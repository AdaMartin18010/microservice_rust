# 24.1 åˆ†å¸ƒå¼è¿½è¸ªä¸å‘Šè­¦ç³»ç»Ÿ

## æ¦‚è¿°

æœ¬æŒ‡å—è¯¦ç»†ä»‹ç»å¦‚ä½•åœ¨Rustå¾®æœåŠ¡ä¸­å®ç°é«˜çº§ç›‘æ§ä½“ç³»ï¼ŒåŒ…æ‹¬åˆ†å¸ƒå¼è¿½è¸ªã€å‘Šè­¦ç³»ç»Ÿå’Œå¯è§‚æµ‹æ€§æœ€ä½³å®è·µã€‚æˆ‘ä»¬å°†ä½¿ç”¨OpenTelemetryã€Jaegerã€Prometheuså’ŒGrafanaæ„å»ºå®Œæ•´çš„ç›‘æ§è§£å†³æ–¹æ¡ˆã€‚

## å­¦ä¹ ç›®æ ‡

- æŒæ¡åˆ†å¸ƒå¼è¿½è¸ªç³»ç»Ÿçš„è®¾è®¡å’Œå®ç°
- äº†è§£å‘Šè­¦ç³»ç»Ÿçš„æ¶æ„å’Œé…ç½®
- å­¦ä¹ å¯è§‚æµ‹æ€§æœ€ä½³å®è·µ
- å®ç°è‡ªåŠ¨åŒ–ç›‘æ§å’Œå‘Šè­¦

## åˆ†å¸ƒå¼è¿½è¸ªæ¶æ„

```mermaid
graph TB
    A[å¾®æœåŠ¡A] --> B[OpenTelemetry SDK]
    C[å¾®æœåŠ¡B] --> D[OpenTelemetry SDK]
    E[å¾®æœåŠ¡C] --> F[OpenTelemetry SDK]
    
    B --> G[OTel Collector]
    D --> G
    F --> G
    
    G --> H[Jaeger]
    G --> I[Prometheus]
    
    H --> J[Grafana Dashboard]
    I --> J
    
    J --> K[AlertManager]
    K --> L[Slack/Email/PagerDuty]
    
    style A fill:#e1f5fe
    style C fill:#e1f5fe
    style E fill:#e1f5fe
    style G fill:#f3e5f5
    style H fill:#e8f5e8
    style I fill:#e8f5e8
    style J fill:#fff3e0
    style K fill:#ffebee
```

## æ ¸å¿ƒç»„ä»¶

### 1. OpenTelemetry SDK

- åˆ†å¸ƒå¼è¿½è¸ªæ•°æ®æ”¶é›†
- æŒ‡æ ‡å’Œæ—¥å¿—é›†æˆ
- è‡ªåŠ¨å’Œæ‰‹åŠ¨åŸ‹ç‚¹

### 2. Jaeger

- åˆ†å¸ƒå¼è¿½è¸ªå­˜å‚¨å’ŒæŸ¥è¯¢
- æœåŠ¡ä¾èµ–åˆ†æ
- æ€§èƒ½ç“¶é¢ˆè¯†åˆ«

### 3. Prometheus

- æŒ‡æ ‡æ”¶é›†å’Œå­˜å‚¨
- å‘Šè­¦è§„åˆ™å®šä¹‰
- æ—¶é—´åºåˆ—æ•°æ®æŸ¥è¯¢

### 4. Grafana

- å¯è§†åŒ–ä»ªè¡¨æ¿
- å‘Šè­¦é€šçŸ¥ç®¡ç†
- å¤šæ•°æ®æºé›†æˆ

## æŠ€æœ¯å®ç°

### ç¯å¢ƒå‡†å¤‡

```bash
# åˆ›å»ºç›‘æ§ç›®å½•
mkdir -p monitoring/{jaeger,prometheus,grafana,otel-collector}

# å¯åŠ¨ç›‘æ§æœåŠ¡
docker-compose -f docker-compose.monitoring.yml up -d
```

### ä¾èµ–é…ç½®

```toml
[dependencies]
opentelemetry = "0.21"
opentelemetry-jaeger = "0.20"
opentelemetry-prometheus = "0.12"
opentelemetry-semantic-conventions = "0.13"
tracing = "0.1"
tracing-opentelemetry = "0.21"
tracing-subscriber = "0.3"
prometheus = "0.13"
tokio = { version = "1.0", features = ["full"] }
axum = "0.7"
```

### åˆ†å¸ƒå¼è¿½è¸ªå®ç°

```rust
// src/monitoring/tracing.rs
use opentelemetry::{
    global,
    trace::{TraceContextExt, Tracer},
    KeyValue,
};
use opentelemetry_jaeger::new_agent_pipeline;
use opentelemetry_semantic_conventions::resource;
use tracing::{info, instrument, warn};
use tracing_opentelemetry::OpenTelemetrySpanExt;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

pub struct TracingConfig {
    pub service_name: String,
    pub jaeger_endpoint: String,
    pub environment: String,
}

impl TracingConfig {
    pub fn new(service_name: String, jaeger_endpoint: String, environment: String) -> Self {
        Self {
            service_name,
            jaeger_endpoint,
            environment,
        }
    }
}

pub async fn init_tracing(config: TracingConfig) -> Result<(), Box<dyn std::error::Error>> {
    // åˆ›å»ºJaeger tracer
    let tracer = new_agent_pipeline()
        .with_service_name(&config.service_name)
        .with_endpoint(&config.jaeger_endpoint)
        .with_trace_config(
            opentelemetry::trace::config()
                .with_resource(opentelemetry::sdk::Resource::new(vec![
                    KeyValue::new(resource::SERVICE_NAME, config.service_name.clone()),
                    KeyValue::new(resource::SERVICE_VERSION, env!("CARGO_PKG_VERSION")),
                    KeyValue::new(resource::DEPLOYMENT_ENVIRONMENT, config.environment),
                ]))
        )
        .install_simple()?;

    // è®¾ç½®å…¨å±€tracer
    global::set_tracer_provider(tracer.provider().unwrap());

    // åˆå§‹åŒ–tracing subscriber
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "info".into()),
        )
        .with(tracing_opentelemetry::layer().with_tracer(tracer))
        .init();

    info!("Tracing initialized for service: {}", config.service_name);
    Ok(())
}

#[instrument(skip_all)]
pub async fn trace_http_request<F, Fut, T>(
    method: &str,
    path: &str,
    handler: F,
) -> Result<T, Box<dyn std::error::Error>>
where
    F: FnOnce() -> Fut,
    Fut: std::future::Future<Output = Result<T, Box<dyn std::error::Error>>>,
{
    let span = tracing::info_span!(
        "http_request",
        http.method = method,
        http.url = path,
        http.status_code = tracing::field::Empty
    );
    
    let _enter = span.enter();
    
    match handler().await {
        Ok(result) => {
            span.record("http.status_code", 200);
            Ok(result)
        }
        Err(e) => {
            span.record("http.status_code", 500);
            warn!("Request failed: {}", e);
            Err(e)
        }
    }
}

#[instrument(skip_all)]
pub async fn trace_database_query<F, Fut, T>(
    query: &str,
    handler: F,
) -> Result<T, Box<dyn std::error::Error>>
where
    F: FnOnce() -> Fut,
    Fut: std::future::Future<Output = Result<T, Box<dyn std::error::Error>>>,
{
    let span = tracing::info_span!(
        "database_query",
        db.statement = query,
        db.operation = tracing::field::Empty
    );
    
    let _enter = span.enter();
    
    match handler().await {
        Ok(result) => {
            span.record("db.operation", "SELECT");
            Ok(result)
        }
        Err(e) => {
            span.record("db.operation", "ERROR");
            warn!("Database query failed: {}", e);
            Err(e)
        }
    }
}
```

### æŒ‡æ ‡æ”¶é›†å®ç°

```rust
// src/monitoring/metrics.rs
use prometheus::{
    Counter, CounterVec, Gauge, GaugeVec, Histogram, HistogramVec, 
    Opts, Registry, TextEncoder,
};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;

pub struct MetricsCollector {
    registry: Registry,
    http_requests_total: CounterVec,
    http_request_duration: HistogramVec,
    active_connections: Gauge,
    database_connections: GaugeVec,
    cache_hits: CounterVec,
    cache_misses: CounterVec,
    business_metrics: Arc<RwLock<HashMap<String, Gauge>>>,
}

impl MetricsCollector {
    pub fn new() -> Result<Self, Box<dyn std::error::Error>> {
        let registry = Registry::new();
        
        // HTTPè¯·æ±‚æŒ‡æ ‡
        let http_requests_total = CounterVec::new(
            Opts::new("http_requests_total", "Total HTTP requests"),
            &["method", "endpoint", "status"]
        )?;
        
        let http_request_duration = HistogramVec::new(
            Histogram::with_opts(Opts::new("http_request_duration_seconds", "HTTP request duration"))
                .buckets(vec![0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1.0, 5.0]),
            &["method", "endpoint"]
        )?;
        
        // è¿æ¥æŒ‡æ ‡
        let active_connections = Gauge::new("active_connections", "Active connections")?;
        
        let database_connections = GaugeVec::new(
            Opts::new("database_connections", "Database connections"),
            &["database", "status"]
        )?;
        
        // ç¼“å­˜æŒ‡æ ‡
        let cache_hits = CounterVec::new(
            Opts::new("cache_hits_total", "Cache hits"),
            &["cache_type", "key_pattern"]
        )?;
        
        let cache_misses = CounterVec::new(
            Opts::new("cache_misses_total", "Cache misses"),
            &["cache_type", "key_pattern"]
        )?;
        
        // æ³¨å†ŒæŒ‡æ ‡
        registry.register(Box::new(http_requests_total.clone()))?;
        registry.register(Box::new(http_request_duration.clone()))?;
        registry.register(Box::new(active_connections.clone()))?;
        registry.register(Box::new(database_connections.clone()))?;
        registry.register(Box::new(cache_hits.clone()))?;
        registry.register(Box::new(cache_misses.clone()))?;
        
        Ok(Self {
            registry,
            http_requests_total,
            http_request_duration,
            active_connections,
            database_connections,
            cache_hits,
            cache_misses,
            business_metrics: Arc::new(RwLock::new(HashMap::new())),
        })
    }
    
    pub fn record_http_request(&self, method: &str, endpoint: &str, status: u16, duration: f64) {
        self.http_requests_total
            .with_label_values(&[method, endpoint, &status.to_string()])
            .inc();
        
        self.http_request_duration
            .with_label_values(&[method, endpoint])
            .observe(duration);
    }
    
    pub fn update_active_connections(&self, count: i64) {
        self.active_connections.set(count as f64);
    }
    
    pub fn update_database_connections(&self, database: &str, status: &str, count: i64) {
        self.database_connections
            .with_label_values(&[database, status])
            .set(count as f64);
    }
    
    pub fn record_cache_hit(&self, cache_type: &str, key_pattern: &str) {
        self.cache_hits
            .with_label_values(&[cache_type, key_pattern])
            .inc();
    }
    
    pub fn record_cache_miss(&self, cache_type: &str, key_pattern: &str) {
        self.cache_misses
            .with_label_values(&[cache_type, key_pattern])
            .inc();
    }
    
    pub async fn set_business_metric(&self, name: &str, value: f64) {
        let mut metrics = self.business_metrics.write().await;
        if !metrics.contains_key(name) {
            let gauge = Gauge::new(name, &format!("Business metric: {}", name)).unwrap();
            self.registry.register(Box::new(gauge.clone())).unwrap();
            metrics.insert(name.to_string(), gauge);
        }
        if let Some(gauge) = metrics.get(name) {
            gauge.set(value);
        }
    }
    
    pub fn get_metrics(&self) -> Result<String, Box<dyn std::error::Error>> {
        let encoder = TextEncoder::new();
        let metric_families = self.registry.gather();
        Ok(encoder.encode_to_string(&metric_families)?)
    }
}

impl Clone for MetricsCollector {
    fn clone(&self) -> Self {
        Self {
            registry: self.registry.clone(),
            http_requests_total: self.http_requests_total.clone(),
            http_request_duration: self.http_request_duration.clone(),
            active_connections: self.active_connections.clone(),
            database_connections: self.database_connections.clone(),
            cache_hits: self.cache_hits.clone(),
            cache_misses: self.cache_misses.clone(),
            business_metrics: self.business_metrics.clone(),
        }
    }
}
```

### å‘Šè­¦ç³»ç»Ÿå®ç°

```rust
// src/monitoring/alerts.rs
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use tokio::time::{Duration, Instant};
use tracing::{error, info, warn};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertRule {
    pub name: String,
    pub condition: String,
    pub threshold: f64,
    pub duration: Duration,
    pub severity: AlertSeverity,
    pub notification_channels: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AlertSeverity {
    Critical,
    Warning,
    Info,
}

#[derive(Debug, Clone)]
pub struct Alert {
    pub rule_name: String,
    pub message: String,
    pub severity: AlertSeverity,
    pub timestamp: Instant,
    pub metadata: HashMap<String, String>,
}

pub struct AlertManager {
    rules: Vec<AlertRule>,
    active_alerts: HashMap<String, Alert>,
    notification_channels: HashMap<String, Box<dyn NotificationChannel>>,
}

impl AlertManager {
    pub fn new() -> Self {
        Self {
            rules: Vec::new(),
            active_alerts: HashMap::new(),
            notification_channels: HashMap::new(),
        }
    }
    
    pub fn add_rule(&mut self, rule: AlertRule) {
        self.rules.push(rule);
    }
    
    pub fn add_notification_channel(&mut self, name: String, channel: Box<dyn NotificationChannel>) {
        self.notification_channels.insert(name, channel);
    }
    
    pub async fn evaluate_rules(&mut self, metrics: &HashMap<String, f64>) {
        for rule in &self.rules {
            if let Some(value) = metrics.get(&rule.condition) {
                if *value > rule.threshold {
                    self.trigger_alert(rule, *value).await;
                } else {
                    self.resolve_alert(&rule.name).await;
                }
            }
        }
    }
    
    async fn trigger_alert(&mut self, rule: &AlertRule, value: f64) {
        let alert_key = rule.name.clone();
        
        if !self.active_alerts.contains_key(&alert_key) {
            let alert = Alert {
                rule_name: rule.name.clone(),
                message: format!("Alert triggered: {} = {:.2} (threshold: {:.2})", 
                    rule.condition, value, rule.threshold),
                severity: rule.severity.clone(),
                timestamp: Instant::now(),
                metadata: HashMap::new(),
            };
            
            self.active_alerts.insert(alert_key.clone(), alert.clone());
            
            // å‘é€é€šçŸ¥
            for channel_name in &rule.notification_channels {
                if let Some(channel) = self.notification_channels.get(channel_name) {
                    if let Err(e) = channel.send_notification(&alert).await {
                        error!("Failed to send notification via {}: {}", channel_name, e);
                    }
                }
            }
            
            info!("Alert triggered: {}", alert.message);
        }
    }
    
    async fn resolve_alert(&mut self, rule_name: &str) {
        if let Some(alert) = self.active_alerts.remove(rule_name) {
            info!("Alert resolved: {}", alert.message);
        }
    }
}

#[async_trait::async_trait]
pub trait NotificationChannel: Send + Sync {
    async fn send_notification(&self, alert: &Alert) -> Result<(), Box<dyn std::error::Error>>;
}

pub struct SlackNotificationChannel {
    webhook_url: String,
    channel: String,
}

impl SlackNotificationChannel {
    pub fn new(webhook_url: String, channel: String) -> Self {
        Self { webhook_url, channel }
    }
}

#[async_trait::async_trait]
impl NotificationChannel for SlackNotificationChannel {
    async fn send_notification(&self, alert: &Alert) -> Result<(), Box<dyn std::error::Error>> {
        let payload = serde_json::json!({
            "channel": self.channel,
            "text": format!("ğŸš¨ {} Alert: {}", 
                match alert.severity {
                    AlertSeverity::Critical => "CRITICAL",
                    AlertSeverity::Warning => "WARNING",
                    AlertSeverity::Info => "INFO",
                },
                alert.message
            ),
            "attachments": [{
                "color": match alert.severity {
                    AlertSeverity::Critical => "danger",
                    AlertSeverity::Warning => "warning",
                    AlertSeverity::Info => "good",
                },
                "fields": [
                    {
                        "title": "Rule",
                        "value": alert.rule_name,
                        "short": true
                    },
                    {
                        "title": "Timestamp",
                        "value": alert.timestamp.elapsed().as_secs().to_string(),
                        "short": true
                    }
                ]
            }]
        });
        
        let client = reqwest::Client::new();
        let response = client
            .post(&self.webhook_url)
            .json(&payload)
            .send()
            .await?;
        
        if !response.status().is_success() {
            return Err(format!("Slack API error: {}", response.status()).into());
        }
        
        Ok(())
    }
}

pub struct EmailNotificationChannel {
    smtp_server: String,
    username: String,
    password: String,
    from: String,
    to: Vec<String>,
}

impl EmailNotificationChannel {
    pub fn new(smtp_server: String, username: String, password: String, from: String, to: Vec<String>) -> Self {
        Self { smtp_server, username, password, from, to }
    }
}

#[async_trait::async_trait]
impl NotificationChannel for EmailNotificationChannel {
    async fn send_notification(&self, alert: &Alert) -> Result<(), Box<dyn std::error::Error>> {
        // å®ç°é‚®ä»¶å‘é€é€»è¾‘
        // è¿™é‡Œå¯ä»¥ä½¿ç”¨lettreæˆ–å…¶ä»–é‚®ä»¶åº“
        info!("Sending email notification for alert: {}", alert.message);
        Ok(())
    }
}
```

### ç›‘æ§ä¸­é—´ä»¶

```rust
// src/monitoring/middleware.rs
use axum::{
    extract::Request,
    http::{Method, StatusCode},
    middleware::Next,
    response::Response,
};
use std::time::Instant;
use tracing::{info, warn};

pub async fn monitoring_middleware(
    mut request: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    let start_time = Instant::now();
    let method = request.method().clone();
    let path = request.uri().path().to_string();
    
    // æ·»åŠ è¯·æ±‚IDåˆ°headers
    let request_id = uuid::Uuid::new_v4().to_string();
    request.headers_mut().insert(
        "x-request-id",
        request_id.parse().unwrap(),
    );
    
    let response = next.run(request).await;
    let duration = start_time.elapsed();
    let status = response.status();
    
    // è®°å½•è¯·æ±‚æŒ‡æ ‡
    if status.is_success() {
        info!(
            "HTTP {} {} - {}ms - {}",
            method,
            path,
            duration.as_millis(),
            status
        );
    } else {
        warn!(
            "HTTP {} {} - {}ms - {}",
            method,
            path,
            duration.as_millis(),
            status
        );
    }
    
    Ok(response)
}
```

## æœ€ä½³å®è·µ

### 1. ç›‘æ§ç­–ç•¥

- **åˆ†å±‚ç›‘æ§**: åŸºç¡€è®¾æ–½ã€åº”ç”¨ã€ä¸šåŠ¡ä¸‰å±‚ç›‘æ§
- **å…³é”®æŒ‡æ ‡**: å»¶è¿Ÿã€ååé‡ã€é”™è¯¯ç‡ã€å¯ç”¨æ€§
- **å‘Šè­¦è§„åˆ™**: åŸºäºSLAçš„å‘Šè­¦é˜ˆå€¼è®¾ç½®

### 2. æ€§èƒ½ä¼˜åŒ–

- **é‡‡æ ·ç­–ç•¥**: æ ¹æ®æµé‡è°ƒæ•´é‡‡æ ·ç‡
- **æ•°æ®å‹ç¼©**: å‡å°‘ç½‘ç»œä¼ è¾“å¼€é”€
- **ç¼“å­˜ç­–ç•¥**: åˆç†ä½¿ç”¨ç¼“å­˜å‡å°‘é‡å¤è®¡ç®—

### 3. å®‰å…¨è€ƒè™‘

- **æ•°æ®è„±æ•**: æ•æ„Ÿä¿¡æ¯ä¸è®°å½•åˆ°æ—¥å¿—
- **è®¿é—®æ§åˆ¶**: ç›‘æ§æ•°æ®è®¿é—®æƒé™ç®¡ç†
- **åŠ å¯†ä¼ è¾“**: ç›‘æ§æ•°æ®ä¼ è¾“åŠ å¯†

### 4. è¿ç»´ç®¡ç†

- **è‡ªåŠ¨åŒ–éƒ¨ç½²**: ç›‘æ§é…ç½®è‡ªåŠ¨åŒ–éƒ¨ç½²
- **ç‰ˆæœ¬ç®¡ç†**: ç›‘æ§è§„åˆ™ç‰ˆæœ¬æ§åˆ¶
- **æ•…éšœæ¢å¤**: ç›‘æ§ç³»ç»Ÿæ•…éšœæ¢å¤æœºåˆ¶

## éƒ¨ç½²é…ç½®

### Docker Composeé…ç½®

```yaml
# docker-compose.monitoring.yml
version: '3.8'

services:
  jaeger:
    image: jaegertracing/all-in-one:1.50
    ports:
      - "16686:16686"
      - "14268:14268"
    environment:
      - COLLECTOR_OTLP_ENABLED=true
    networks:
      - monitoring

  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--web.enable-lifecycle'
    networks:
      - monitoring

  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana-storage:/var/lib/grafana
      - ./grafana/provisioning:/etc/grafana/provisioning
    networks:
      - monitoring

  alertmanager:
    image: prom/alertmanager:latest
    ports:
      - "9093:9093"
    volumes:
      - ./alertmanager.yml:/etc/alertmanager/alertmanager.yml
    networks:
      - monitoring

  otel-collector:
    image: otel/opentelemetry-collector-contrib:latest
    ports:
      - "4317:4317"
      - "4318:4318"
    volumes:
      - ./otel-collector-config.yml:/etc/otelcol-contrib/otel-collector-config.yml
    command: ["--config=/etc/otelcol-contrib/otel-collector-config.yml"]
    networks:
      - monitoring

volumes:
  grafana-storage:

networks:
  monitoring:
    driver: bridge
```

### Prometheusé…ç½®

```yaml
# prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "alert_rules.yml"

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093

scrape_configs:
  - job_name: 'microservices'
    static_configs:
      - targets: ['microservice:8080']
    metrics_path: '/metrics'
    scrape_interval: 5s

  - job_name: 'jaeger'
    static_configs:
      - targets: ['jaeger:14269']
    metrics_path: '/metrics'
    scrape_interval: 15s
```

### å‘Šè­¦è§„åˆ™é…ç½®

```yaml
# alert_rules.yml
groups:
  - name: microservices
    rules:
      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.1
        for: 2m
        labels:
          severity: critical
        annotations:
          summary: "High error rate detected"
          description: "Error rate is {{ $value }} errors per second"

      - alert: HighLatency
        expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High latency detected"
          description: "95th percentile latency is {{ $value }} seconds"

      - alert: ServiceDown
        expr: up == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Service is down"
          description: "Service {{ $labels.instance }} is down"
```

## æ€§èƒ½æµ‹è¯•

### ç›‘æ§æ€§èƒ½æµ‹è¯•

```rust
// benches/monitoring_benchmark.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use microservice::monitoring::{MetricsCollector, TracingConfig, init_tracing};

fn benchmark_metrics_collection(c: &mut Criterion) {
    let metrics_collector = MetricsCollector::new().unwrap();
    
    c.bench_function("metrics_collection", |b| {
        b.iter(|| {
            metrics_collector.record_http_request(
                black_box("GET"),
                black_box("/api/users"),
                black_box(200),
                black_box(0.1),
            );
        })
    });
}

fn benchmark_tracing_overhead(c: &mut Criterion) {
    let rt = tokio::runtime::Runtime::new().unwrap();
    let config = TracingConfig::new(
        "benchmark".to_string(),
        "http://localhost:14268/api/traces".to_string(),
        "test".to_string(),
    );
    
    rt.block_on(init_tracing(config)).unwrap();
    
    c.bench_function("tracing_overhead", |b| {
        b.iter(|| {
            let _span = tracing::info_span!("benchmark_span");
            let _enter = _span.enter();
            black_box(42)
        })
    });
}

criterion_group!(benches, benchmark_metrics_collection, benchmark_tracing_overhead);
criterion_main!(benches);
```

## æ€»ç»“

æœ¬æŒ‡å—è¯¦ç»†ä»‹ç»äº†å¦‚ä½•åœ¨Rustå¾®æœåŠ¡ä¸­å®ç°é«˜çº§ç›‘æ§ä½“ç³»ï¼ŒåŒ…æ‹¬ï¼š

1. **åˆ†å¸ƒå¼è¿½è¸ª**: ä½¿ç”¨OpenTelemetryå’ŒJaegerå®ç°å®Œæ•´çš„è¯·æ±‚é“¾è·¯è¿½è¸ª
2. **æŒ‡æ ‡æ”¶é›†**: ä½¿ç”¨Prometheusæ”¶é›†å’Œå­˜å‚¨å„ç§æ€§èƒ½æŒ‡æ ‡
3. **å‘Šè­¦ç³»ç»Ÿ**: å®ç°åŸºäºè§„åˆ™çš„å‘Šè­¦å’Œå¤šç§é€šçŸ¥æ¸ é“
4. **å¯è§†åŒ–**: ä½¿ç”¨Grafanaåˆ›å»ºç›‘æ§ä»ªè¡¨æ¿
5. **æœ€ä½³å®è·µ**: ç›‘æ§ç­–ç•¥ã€æ€§èƒ½ä¼˜åŒ–ã€å®‰å…¨è€ƒè™‘å’Œè¿ç»´ç®¡ç†

é€šè¿‡è¿™å¥—å®Œæ•´çš„ç›‘æ§ä½“ç³»ï¼Œå¯ä»¥å®ç°å¯¹å¾®æœåŠ¡ç³»ç»Ÿçš„å…¨é¢å¯è§‚æµ‹æ€§ï¼ŒåŠæ—¶å‘ç°å’Œè§£å†³æ€§èƒ½é—®é¢˜ï¼Œç¡®ä¿ç³»ç»Ÿçš„é«˜å¯ç”¨æ€§å’Œç¨³å®šæ€§ã€‚
