# 15.1 å¸¸è§é—®é¢˜è§£å†³æ–¹æ¡ˆ

> å¾®æœåŠ¡æ¶æ„å¸¸è§é—®é¢˜çš„è¯Šæ–­å’Œè§£å†³æ–¹æ¡ˆ

## ğŸ“‹ ç›®å½•

- [æœåŠ¡å¯åŠ¨é—®é¢˜](#æœåŠ¡å¯åŠ¨é—®é¢˜)
- [æ€§èƒ½é—®é¢˜](#æ€§èƒ½é—®é¢˜)
- [æ•°æ®ä¸€è‡´æ€§é—®é¢˜](#æ•°æ®ä¸€è‡´æ€§é—®é¢˜)
- [ç½‘ç»œè¿æ¥é—®é¢˜](#ç½‘ç»œè¿æ¥é—®é¢˜)
- [ç›‘æ§å‘Šè­¦é—®é¢˜](#ç›‘æ§å‘Šè­¦é—®é¢˜)
- [å®‰å…¨ç›¸å…³é—®é¢˜](#å®‰å…¨ç›¸å…³é—®é¢˜)

## æœåŠ¡å¯åŠ¨é—®é¢˜

### 1. å®¹å™¨å¯åŠ¨å¤±è´¥

**é—®é¢˜ç—‡çŠ¶ï¼š**
- PodçŠ¶æ€ä¸ºCrashLoopBackOff
- å®¹å™¨ä¸æ–­é‡å¯
- æ—¥å¿—æ˜¾ç¤ºå¯åŠ¨é”™è¯¯

**è¯Šæ–­æ­¥éª¤ï¼š**
```bash
# æ£€æŸ¥PodçŠ¶æ€
kubectl get pods -n production -l app=microservice

# æŸ¥çœ‹Podè¯¦ç»†ä¿¡æ¯
kubectl describe pod <pod-name> -n production

# æŸ¥çœ‹å®¹å™¨æ—¥å¿—
kubectl logs <pod-name> -n production --previous

# æ£€æŸ¥äº‹ä»¶
kubectl get events -n production --sort-by='.lastTimestamp'
```

**å¸¸è§åŸå› å’Œè§£å†³æ–¹æ¡ˆï¼š**

| åŸå›  | ç—‡çŠ¶ | è§£å†³æ–¹æ¡ˆ |
|------|------|----------|
| é…ç½®é”™è¯¯ | ç¯å¢ƒå˜é‡ç¼ºå¤± | æ£€æŸ¥ConfigMapå’ŒSecreté…ç½® |
| èµ„æºä¸è¶³ | OOMKilled | å¢åŠ å†…å­˜é™åˆ¶æˆ–ä¼˜åŒ–å†…å­˜ä½¿ç”¨ |
| ä¾èµ–æœåŠ¡ä¸å¯ç”¨ | è¿æ¥è¶…æ—¶ | æ£€æŸ¥ä¾èµ–æœåŠ¡çŠ¶æ€å’Œç½‘ç»œè¿æ¥ |
| æƒé™é—®é¢˜ | æƒé™è¢«æ‹’ç» | æ£€æŸ¥ServiceAccountå’ŒRBACé…ç½® |

### 2. æ•°æ®åº“è¿æ¥å¤±è´¥

**é—®é¢˜ç—‡çŠ¶ï¼š**
- åº”ç”¨æ— æ³•è¿æ¥åˆ°æ•°æ®åº“
- è¿æ¥æ± è€—å°½
- è¿æ¥è¶…æ—¶

**è¯Šæ–­è„šæœ¬ï¼š**
```bash
#!/bin/bash
# æ•°æ®åº“è¿æ¥è¯Šæ–­è„šæœ¬

echo "ğŸ” æ£€æŸ¥æ•°æ®åº“è¿æ¥..."

# æ£€æŸ¥æ•°æ®åº“PodçŠ¶æ€
kubectl get pods -n production -l app=postgres

# æ£€æŸ¥æ•°æ®åº“æœåŠ¡
kubectl get svc -n production -l app=postgres

# æµ‹è¯•æ•°æ®åº“è¿æ¥
kubectl exec -n production <app-pod> -- nc -zv postgres-service 5432

# æ£€æŸ¥æ•°æ®åº“æ—¥å¿—
kubectl logs -n production -l app=postgres --tail=50

# æ£€æŸ¥è¿æ¥æ•°
kubectl exec -n production <postgres-pod> -- psql -U postgres -c "SELECT count(*) FROM pg_stat_activity;"
```

**è§£å†³æ–¹æ¡ˆï¼š**
```yaml
# æ•°æ®åº“è¿æ¥æ± é…ç½®ä¼˜åŒ–
apiVersion: v1
kind: ConfigMap
metadata:
  name: database-config
data:
  DATABASE_MAX_CONNECTIONS: "50"
  DATABASE_MIN_CONNECTIONS: "10"
  DATABASE_CONNECTION_TIMEOUT: "30s"
  DATABASE_IDLE_TIMEOUT: "600s"
```

## æ€§èƒ½é—®é¢˜

### 1. é«˜å»¶è¿Ÿé—®é¢˜

**é—®é¢˜ç—‡çŠ¶ï¼š**
- å“åº”æ—¶é—´è¶…è¿‡é¢„æœŸ
- ç”¨æˆ·æŠ•è¯‰åº”ç”¨ç¼“æ…¢
- ç›‘æ§æ˜¾ç¤ºP95å»¶è¿Ÿè¿‡é«˜

**è¯Šæ–­å·¥å…·ï¼š**
```bash
#!/bin/bash
# æ€§èƒ½è¯Šæ–­è„šæœ¬

echo "ğŸ” å¼€å§‹æ€§èƒ½è¯Šæ–­..."

# æ£€æŸ¥CPUä½¿ç”¨ç‡
kubectl top pods -n production

# æ£€æŸ¥å†…å­˜ä½¿ç”¨ç‡
kubectl top pods -n production --containers

# æ£€æŸ¥ç½‘ç»œå»¶è¿Ÿ
kubectl exec -n production <pod-name> -- ping -c 5 postgres-service

# æ£€æŸ¥æ•°æ®åº“æ€§èƒ½
kubectl exec -n production <postgres-pod> -- psql -U postgres -c "
SELECT query, mean_time, calls, total_time 
FROM pg_stat_statements 
ORDER BY mean_time DESC 
LIMIT 10;"
```

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**
```rust
// æ€§èƒ½ä¼˜åŒ–ä»£ç ç¤ºä¾‹
use tokio::time::{timeout, Duration};

pub struct OptimizedService {
    db_pool: sqlx::PgPool,
    cache: redis::Client,
}

impl OptimizedService {
    pub async fn get_user_optimized(&self, user_id: Uuid) -> Result<User, Box<dyn std::error::Error>> {
        // 1. å…ˆå°è¯•ä»ç¼“å­˜è·å–
        if let Some(user) = self.get_cached_user(user_id).await? {
            return Ok(user);
        }

        // 2. ä»æ•°æ®åº“è·å–ï¼Œè®¾ç½®è¶…æ—¶
        let user = timeout(
            Duration::from_secs(5),
            self.get_user_from_db(user_id)
        ).await??;

        // 3. ç¼“å­˜ç»“æœ
        self.cache_user(&user).await?;
        
        Ok(user)
    }

    async fn get_user_from_db(&self, user_id: Uuid) -> Result<User, sqlx::Error> {
        sqlx::query_as::<_, User>("SELECT * FROM users WHERE id = $1")
            .bind(user_id)
            .fetch_one(&self.db_pool)
            .await
    }
}
```

### 2. å†…å­˜æ³„æ¼é—®é¢˜

**é—®é¢˜ç—‡çŠ¶ï¼š**
- å†…å­˜ä½¿ç”¨æŒç»­å¢é•¿
- é¢‘ç¹çš„OOMKilled
- åƒåœ¾å›æ”¶é¢‘ç¹

**è¯Šæ–­æ–¹æ³•ï¼š**
```bash
# æ£€æŸ¥å†…å­˜ä½¿ç”¨è¶‹åŠ¿
kubectl top pods -n production --containers

# æ£€æŸ¥å†…å­˜é™åˆ¶
kubectl describe pod <pod-name> -n production | grep -A 5 "Limits:"

# åˆ†æå†…å­˜ä½¿ç”¨
kubectl exec -n production <pod-name> -- cat /proc/meminfo
```

**è§£å†³æ–¹æ¡ˆï¼š**
```rust
// å†…å­˜ä¼˜åŒ–ä»£ç ç¤ºä¾‹
use std::sync::Arc;
use tokio::sync::RwLock;

pub struct MemoryOptimizedService {
    // ä½¿ç”¨Arcå‡å°‘å†…å­˜å¤åˆ¶
    cache: Arc<RwLock<HashMap<String, Arc<String>>>>,
    // å®šæœŸæ¸…ç†è¿‡æœŸæ•°æ®
    cleanup_interval: Duration,
}

impl MemoryOptimizedService {
    pub fn new() -> Self {
        let service = Self {
            cache: Arc::new(RwLock::new(HashMap::new())),
            cleanup_interval: Duration::from_secs(300), // 5åˆ†é’Ÿæ¸…ç†ä¸€æ¬¡
        };
        
        // å¯åŠ¨æ¸…ç†ä»»åŠ¡
        service.start_cleanup_task();
        service
    }

    fn start_cleanup_task(&self) {
        let cache = self.cache.clone();
        let interval = self.cleanup_interval;
        
        tokio::spawn(async move {
            let mut cleanup_timer = tokio::time::interval(interval);
            loop {
                cleanup_timer.tick().await;
                
                // æ¸…ç†è¿‡æœŸæ•°æ®
                let mut cache_guard = cache.write().await;
                cache_guard.retain(|_, value| {
                    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
                    !value.is_empty()
                });
            }
        });
    }
}
```

## æ•°æ®ä¸€è‡´æ€§é—®é¢˜

### 1. åˆ†å¸ƒå¼äº‹åŠ¡é—®é¢˜

**é—®é¢˜ç—‡çŠ¶ï¼š**
- æ•°æ®ä¸ä¸€è‡´
- äº‹åŠ¡å›æ»šå¤±è´¥
- éƒ¨åˆ†æ›´æ–°æˆåŠŸ

**è¯Šæ–­è„šæœ¬ï¼š**
```bash
#!/bin/bash
# æ•°æ®ä¸€è‡´æ€§æ£€æŸ¥è„šæœ¬

echo "ğŸ” æ£€æŸ¥æ•°æ®ä¸€è‡´æ€§..."

# æ£€æŸ¥äº‹åŠ¡æ—¥å¿—
kubectl logs -n production -l app=microservice | grep -i "transaction\|rollback\|commit"

# æ£€æŸ¥æ•°æ®åº“çŠ¶æ€
kubectl exec -n production <postgres-pod> -- psql -U postgres -c "
SELECT * FROM pg_stat_database WHERE datname = 'microservice';"

# æ£€æŸ¥æ­»é”
kubectl exec -n production <postgres-pod> -- psql -U postgres -c "
SELECT * FROM pg_stat_activity WHERE state = 'active';"
```

**è§£å†³æ–¹æ¡ˆï¼š**
```rust
// Sagaæ¨¡å¼å®ç°
pub struct SagaManager {
    steps: Vec<SagaStep>,
    compensations: Vec<CompensationStep>,
}

impl SagaManager {
    pub async fn execute_saga(&self) -> Result<(), SagaError> {
        let mut executed_steps = Vec::new();
        
        for (index, step) in self.steps.iter().enumerate() {
            match step.execute().await {
                Ok(_) => {
                    executed_steps.push(index);
                }
                Err(e) => {
                    // æ‰§è¡Œè¡¥å¿æ“ä½œ
                    self.compensate(&executed_steps).await?;
                    return Err(SagaError::ExecutionFailed(e));
                }
            }
        }
        
        Ok(())
    }

    async fn compensate(&self, executed_steps: &[usize]) -> Result<(), SagaError> {
        // é€†åºæ‰§è¡Œè¡¥å¿æ“ä½œ
        for &step_index in executed_steps.iter().rev() {
            if let Some(compensation) = self.compensations.get(step_index) {
                if let Err(e) = compensation.execute().await {
                    return Err(SagaError::CompensationFailed(e));
                }
            }
        }
        Ok(())
    }
}
```

### 2. ç¼“å­˜ä¸€è‡´æ€§é—®é¢˜

**é—®é¢˜ç—‡çŠ¶ï¼š**
- ç¼“å­˜æ•°æ®è¿‡æœŸ
- æ•°æ®ä¸åŒæ­¥
- è¯»å–åˆ°æ—§æ•°æ®

**è¯Šæ–­æ–¹æ³•ï¼š**
```bash
# æ£€æŸ¥RedisçŠ¶æ€
kubectl exec -n production <redis-pod> -- redis-cli info memory

# æ£€æŸ¥ç¼“å­˜å‘½ä¸­ç‡
kubectl exec -n production <redis-pod> -- redis-cli info stats | grep hit_rate

# æ£€æŸ¥ç¼“å­˜é”®
kubectl exec -n production <redis-pod> -- redis-cli keys "*user*"
```

**è§£å†³æ–¹æ¡ˆï¼š**
```rust
// ç¼“å­˜ä¸€è‡´æ€§è§£å†³æ–¹æ¡ˆ
pub struct ConsistentCache {
    redis: redis::Client,
    db: sqlx::PgPool,
}

impl ConsistentCache {
    pub async fn get_user(&self, user_id: Uuid) -> Result<Option<User>, Box<dyn std::error::Error>> {
        // 1. å°è¯•ä»ç¼“å­˜è·å–
        if let Some(user) = self.get_from_cache(user_id).await? {
            return Ok(Some(user));
        }

        // 2. ä»æ•°æ®åº“è·å–
        let user = self.get_from_db(user_id).await?;
        
        // 3. å†™å…¥ç¼“å­˜
        if let Some(ref user) = user {
            self.set_cache(user_id, user).await?;
        }

        Ok(user)
    }

    pub async fn update_user(&self, user: &User) -> Result<(), Box<dyn std::error::Error>> {
        // 1. æ›´æ–°æ•°æ®åº“
        self.update_db(user).await?;
        
        // 2. æ›´æ–°ç¼“å­˜
        self.set_cache(user.id, user).await?;
        
        Ok(())
    }

    pub async fn delete_user(&self, user_id: Uuid) -> Result<(), Box<dyn std::error::Error>> {
        // 1. åˆ é™¤æ•°æ®åº“è®°å½•
        self.delete_from_db(user_id).await?;
        
        // 2. åˆ é™¤ç¼“å­˜
        self.delete_from_cache(user_id).await?;
        
        Ok(())
    }
}
```

## ç½‘ç»œè¿æ¥é—®é¢˜

### 1. æœåŠ¡é—´é€šä¿¡å¤±è´¥

**é—®é¢˜ç—‡çŠ¶ï¼š**
- æœåŠ¡è°ƒç”¨è¶…æ—¶
- è¿æ¥è¢«æ‹’ç»
- ç½‘ç»œä¸å¯è¾¾

**è¯Šæ–­è„šæœ¬ï¼š**
```bash
#!/bin/bash
# ç½‘ç»œè¿æ¥è¯Šæ–­è„šæœ¬

echo "ğŸ” æ£€æŸ¥ç½‘ç»œè¿æ¥..."

# æ£€æŸ¥æœåŠ¡çŠ¶æ€
kubectl get svc -n production

# æ£€æŸ¥ç«¯ç‚¹
kubectl get endpoints -n production

# æµ‹è¯•æœåŠ¡é—´è¿æ¥
kubectl exec -n production <pod-name> -- nc -zv user-service 8080
kubectl exec -n production <pod-name> -- nc -zv order-service 8080

# æ£€æŸ¥DNSè§£æ
kubectl exec -n production <pod-name> -- nslookup user-service

# æ£€æŸ¥ç½‘ç»œç­–ç•¥
kubectl get networkpolicies -n production
```

**è§£å†³æ–¹æ¡ˆï¼š**
```yaml
# ç½‘ç»œç­–ç•¥é…ç½®
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: microservice-network-policy
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: microservice
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: nginx-ingress
    ports:
    - protocol: TCP
      port: 8080
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: postgres
    ports:
    - protocol: TCP
      port: 5432
  - to:
    - podSelector:
        matchLabels:
          app: redis
    ports:
    - protocol: TCP
      port: 6379
```

### 2. è´Ÿè½½å‡è¡¡é—®é¢˜

**é—®é¢˜ç—‡çŠ¶ï¼š**
- è¯·æ±‚åˆ†å¸ƒä¸å‡
- éƒ¨åˆ†å®ä¾‹è¿‡è½½
- å“åº”æ—¶é—´å·®å¼‚å¤§

**è¯Šæ–­æ–¹æ³•ï¼š**
```bash
# æ£€æŸ¥è´Ÿè½½å‡è¡¡å™¨çŠ¶æ€
kubectl get svc -n production -o wide

# æ£€æŸ¥Podåˆ†å¸ƒ
kubectl get pods -n production -o wide

# æ£€æŸ¥HPAçŠ¶æ€
kubectl get hpa -n production

# æ£€æŸ¥èµ„æºä½¿ç”¨
kubectl top pods -n production
```

**è§£å†³æ–¹æ¡ˆï¼š**
```yaml
# è´Ÿè½½å‡è¡¡é…ç½®ä¼˜åŒ–
apiVersion: v1
kind: Service
metadata:
  name: microservice-service
  namespace: production
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
    service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"
spec:
  selector:
    app: microservice
  ports:
  - name: http
    port: 80
    targetPort: 8080
    protocol: TCP
  type: LoadBalancer
  sessionAffinity: None
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: microservice-hpa
  namespace: production
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: microservice
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

## ç›‘æ§å‘Šè­¦é—®é¢˜

### 1. æŒ‡æ ‡æ”¶é›†å¤±è´¥

**é—®é¢˜ç—‡çŠ¶ï¼š**
- Prometheusæ— æ³•æŠ“å–æŒ‡æ ‡
- ç›‘æ§é¢æ¿æ˜¾ç¤ºæ— æ•°æ®
- å‘Šè­¦è§„åˆ™ä¸è§¦å‘

**è¯Šæ–­è„šæœ¬ï¼š**
```bash
#!/bin/bash
# ç›‘æ§è¯Šæ–­è„šæœ¬

echo "ğŸ” æ£€æŸ¥ç›‘æ§çŠ¶æ€..."

# æ£€æŸ¥PrometheusçŠ¶æ€
kubectl get pods -n monitoring -l app=prometheus

# æ£€æŸ¥æŒ‡æ ‡ç«¯ç‚¹
kubectl exec -n production <pod-name> -- curl -s http://localhost:9090/metrics | head -20

# æ£€æŸ¥æœåŠ¡å‘ç°
kubectl port-forward -n monitoring svc/prometheus 9090:9090 &
sleep 5
curl -s "http://localhost:9090/api/v1/targets" | jq '.data.activeTargets[] | select(.health != "up")'

# æ£€æŸ¥å‘Šè­¦è§„åˆ™
curl -s "http://localhost:9090/api/v1/rules" | jq '.data.groups[].rules[] | select(.state != "ok")'
```

**è§£å†³æ–¹æ¡ˆï¼š**
```yaml
# ç›‘æ§é…ç½®ä¼˜åŒ–
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-config
  namespace: monitoring
data:
  prometheus.yml: |
    global:
      scrape_interval: 15s
      evaluation_interval: 15s
    
    scrape_configs:
      - job_name: 'microservice'
        static_configs:
          - targets: ['microservice-service:9090']
        metrics_path: /metrics
        scrape_interval: 10s
        scrape_timeout: 5s
        honor_labels: true
        relabel_configs:
          - source_labels: [__address__]
            target_label: instance
            regex: '([^:]+):.*'
            replacement: '${1}'
```

### 2. å‘Šè­¦è§„åˆ™é—®é¢˜

**é—®é¢˜ç—‡çŠ¶ï¼š**
- å‘Šè­¦ä¸è§¦å‘
- è¯¯æŠ¥è­¦å‘Š
- å‘Šè­¦å»¶è¿Ÿ

**è¯Šæ–­æ–¹æ³•ï¼š**
```bash
# æ£€æŸ¥å‘Šè­¦è§„åˆ™çŠ¶æ€
kubectl port-forward -n monitoring svc/prometheus 9090:9090 &
curl -s "http://localhost:9090/api/v1/rules" | jq '.data.groups[].rules[]'

# æ£€æŸ¥å‘Šè­¦å†å²
kubectl logs -n monitoring -l app=alertmanager --tail=100

# æµ‹è¯•å‘Šè­¦è§„åˆ™
curl -s "http://localhost:9090/api/v1/query?query=up" | jq
```

**è§£å†³æ–¹æ¡ˆï¼š**
```yaml
# å‘Šè­¦è§„åˆ™ä¼˜åŒ–
apiVersion: v1
kind: ConfigMap
metadata:
  name: alert-rules
  namespace: monitoring
data:
  alert_rules.yml: |
    groups:
    - name: microservice
      rules:
      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) / rate(http_requests_total[5m]) > 0.05
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High error rate detected"
          description: "Error rate is above 5% for 5 minutes"
          runbook_url: "https://wiki.company.com/runbooks/high-error-rate"
      
      - alert: ServiceDown
        expr: up{job="microservice"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Service is down"
          description: "Microservice is not responding"
          runbook_url: "https://wiki.company.com/runbooks/service-down"
```

## å®‰å…¨ç›¸å…³é—®é¢˜

### 1. è®¤è¯å¤±è´¥

**é—®é¢˜ç—‡çŠ¶ï¼š**
- JWTä»¤ç‰Œæ— æ•ˆ
- ç”¨æˆ·æ— æ³•ç™»å½•
- æƒé™éªŒè¯å¤±è´¥

**è¯Šæ–­è„šæœ¬ï¼š**
```bash
#!/bin/bash
# è®¤è¯é—®é¢˜è¯Šæ–­è„šæœ¬

echo "ğŸ” æ£€æŸ¥è®¤è¯çŠ¶æ€..."

# æ£€æŸ¥JWTå¯†é’¥
kubectl get secret jwt-secret -n production -o yaml

# æ£€æŸ¥è®¤è¯æœåŠ¡æ—¥å¿—
kubectl logs -n production -l app=auth-service --tail=50

# æµ‹è¯•JWTä»¤ç‰Œ
kubectl exec -n production <pod-name> -- curl -H "Authorization: Bearer <token>" http://localhost:8080/api/users/me
```

**è§£å†³æ–¹æ¡ˆï¼š**
```rust
// JWTè®¤è¯ä¼˜åŒ–
use jsonwebtoken::{decode, encode, Header, Algorithm, Validation, DecodingKey, EncodingKey};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: String,
    pub exp: usize,
    pub iat: usize,
    pub role: String,
}

pub struct JwtService {
    encoding_key: EncodingKey,
    decoding_key: DecodingKey,
    validation: Validation,
}

impl JwtService {
    pub fn new(secret: &str) -> Self {
        let encoding_key = EncodingKey::from_secret(secret.as_ref());
        let decoding_key = DecodingKey::from_secret(secret.as_ref());
        let mut validation = Validation::new(Algorithm::HS256);
        validation.leeway = 60; // å…è®¸60ç§’çš„æ—¶é—´åå·®
        
        Self {
            encoding_key,
            decoding_key,
            validation,
        }
    }

    pub fn generate_token(&self, user_id: String, role: String) -> Result<String, jsonwebtoken::errors::Error> {
        let now = chrono::Utc::now().timestamp() as usize;
        let claims = Claims {
            sub: user_id,
            exp: now + 3600, // 1å°æ—¶è¿‡æœŸ
            iat: now,
            role,
        };

        encode(&Header::default(), &claims, &self.encoding_key)
    }

    pub fn validate_token(&self, token: &str) -> Result<Claims, jsonwebtoken::errors::Error> {
        let token_data = decode::<Claims>(token, &self.decoding_key, &self.validation)?;
        Ok(token_data.claims)
    }
}
```

### 2. æƒé™é—®é¢˜

**é—®é¢˜ç—‡çŠ¶ï¼š**
- è®¿é—®è¢«æ‹’ç»
- æƒé™ä¸è¶³
- RBACé…ç½®é”™è¯¯

**è¯Šæ–­æ–¹æ³•ï¼š**
```bash
# æ£€æŸ¥RBACé…ç½®
kubectl get roles -n production
kubectl get rolebindings -n production
kubectl get serviceaccounts -n production

# æ£€æŸ¥æƒé™
kubectl auth can-i get pods --as=system:serviceaccount:production:microservice -n production

# æ£€æŸ¥å®¡è®¡æ—¥å¿—
kubectl get events -n production --sort-by='.lastTimestamp' | grep -i "forbidden\|unauthorized"
```

**è§£å†³æ–¹æ¡ˆï¼š**
```yaml
# RBACé…ç½®ä¼˜åŒ–
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: production
  name: microservice-role
rules:
- apiGroups: [""]
  resources: ["pods", "services", "configmaps", "secrets"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments", "replicasets"]
  verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: microservice-rolebinding
  namespace: production
subjects:
- kind: ServiceAccount
  name: microservice
  namespace: production
roleRef:
  kind: Role
  name: microservice-role
  apiGroup: rbac.authorization.k8s.io
```

## æ€»ç»“

æœ¬æ•…éšœæ’é™¤æŒ‡å—æä¾›äº†å¾®æœåŠ¡æ¶æ„å¸¸è§é—®é¢˜çš„è¯Šæ–­å’Œè§£å†³æ–¹æ¡ˆï¼š

1. **æœåŠ¡å¯åŠ¨é—®é¢˜**ï¼šå®¹å™¨å¯åŠ¨å¤±è´¥ã€æ•°æ®åº“è¿æ¥é—®é¢˜
2. **æ€§èƒ½é—®é¢˜**ï¼šé«˜å»¶è¿Ÿã€å†…å­˜æ³„æ¼
3. **æ•°æ®ä¸€è‡´æ€§é—®é¢˜**ï¼šåˆ†å¸ƒå¼äº‹åŠ¡ã€ç¼“å­˜ä¸€è‡´æ€§
4. **ç½‘ç»œè¿æ¥é—®é¢˜**ï¼šæœåŠ¡é—´é€šä¿¡ã€è´Ÿè½½å‡è¡¡
5. **ç›‘æ§å‘Šè­¦é—®é¢˜**ï¼šæŒ‡æ ‡æ”¶é›†ã€å‘Šè­¦è§„åˆ™
6. **å®‰å…¨ç›¸å…³é—®é¢˜**ï¼šè®¤è¯å¤±è´¥ã€æƒé™é—®é¢˜

é€šè¿‡ç³»ç»ŸåŒ–çš„è¯Šæ–­æ–¹æ³•å’Œé’ˆå¯¹æ€§çš„è§£å†³æ–¹æ¡ˆï¼Œå¯ä»¥å¿«é€Ÿå®šä½å’Œè§£å†³å¾®æœåŠ¡æ¶æ„ä¸­çš„å„ç§é—®é¢˜ï¼Œç¡®ä¿ç³»ç»Ÿçš„ç¨³å®šè¿è¡Œã€‚
