# å¾®æœåŠ¡æ¶æ„è®¾è®¡æ¨¡å¼

> åŸºäºRust 1.90çš„å¾®æœåŠ¡æ¶æ„è®¾è®¡æ¨¡å¼å®Œæ•´æŒ‡å—

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£æ·±å…¥æ¢è®¨å¾®æœåŠ¡æ¶æ„ä¸­çš„æ ¸å¿ƒè®¾è®¡æ¨¡å¼ï¼ŒåŒ…æ‹¬æ¥å…¥å±‚æ¨¡å¼ã€æœåŠ¡é—´é€šä¿¡ã€æ•°æ®ç®¡ç†ã€å¼¹æ€§è®¾è®¡ã€éƒ¨ç½²ç­–ç•¥å’Œå¯è§‚æµ‹æ€§ç­‰å…³é”®é¢†åŸŸã€‚é€šè¿‡å®é™…ä»£ç ç¤ºä¾‹å’Œæœ€ä½³å®è·µï¼Œå±•ç¤ºå¦‚ä½•åœ¨Rustå¾®æœåŠ¡ä¸­åº”ç”¨è¿™äº›è®¾è®¡æ¨¡å¼ã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

- ç†è§£å¾®æœåŠ¡æ¶æ„çš„æ ¸å¿ƒè®¾è®¡æ¨¡å¼
- æŒæ¡åœ¨Rustå¾®æœåŠ¡ä¸­åº”ç”¨è¿™äº›æ¨¡å¼çš„æŠ€æœ¯å®ç°
- äº†è§£å„ç§æ¨¡å¼çš„ä½¿ç”¨åœºæ™¯å’Œæƒè¡¡è€ƒè™‘
- å­¦ä¹ å¦‚ä½•æ„å»ºå¯æ‰©å±•ã€å¯ç»´æŠ¤çš„å¾®æœåŠ¡ç³»ç»Ÿ

## ğŸ“š å†…å®¹å¤§çº²

- [å¾®æœåŠ¡æ¶æ„è®¾è®¡æ¨¡å¼](#å¾®æœåŠ¡æ¶æ„è®¾è®¡æ¨¡å¼)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [ğŸ“š å†…å®¹å¤§çº²](#-å†…å®¹å¤§çº²)
  - [ğŸ”§ æ¥å…¥å±‚æ¨¡å¼](#-æ¥å…¥å±‚æ¨¡å¼)
    - [APIç½‘å…³æ¨¡å¼](#apiç½‘å…³æ¨¡å¼)
    - [BFF (Backend for Frontend) æ¨¡å¼](#bff-backend-for-frontend-æ¨¡å¼)
  - [ğŸ”„ æœåŠ¡é—´é€šä¿¡æ¨¡å¼](#-æœåŠ¡é—´é€šä¿¡æ¨¡å¼)
    - [åŒæ­¥é€šä¿¡ï¼šHTTP/REST](#åŒæ­¥é€šä¿¡httprest)
    - [å¼‚æ­¥é€šä¿¡ï¼šæ¶ˆæ¯é©±åŠ¨ (EDA)](#å¼‚æ­¥é€šä¿¡æ¶ˆæ¯é©±åŠ¨-eda)
  - [ğŸ“Š æ•°æ®ç®¡ç†æ¨¡å¼](#-æ•°æ®ç®¡ç†æ¨¡å¼)
    - [æ¯æœåŠ¡ç‹¬ç«‹æ•°æ®åº“](#æ¯æœåŠ¡ç‹¬ç«‹æ•°æ®åº“)
    - [åè…å±‚ (Anti-Corruption Layer)](#åè…å±‚-anti-corruption-layer)
  - [ğŸ›¡ï¸ å¼¹æ€§ä¸éŸ§æ€§æ¨¡å¼](#ï¸-å¼¹æ€§ä¸éŸ§æ€§æ¨¡å¼)
    - [ç†”æ–­å™¨æ¨¡å¼](#ç†”æ–­å™¨æ¨¡å¼)
  - [ğŸ“– æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [1. æ¨¡å¼é€‰æ‹©åŸåˆ™](#1-æ¨¡å¼é€‰æ‹©åŸåˆ™)
    - [2. å®æ–½å»ºè®®](#2-å®æ–½å»ºè®®)
    - [3. å¸¸è§é™·é˜±](#3-å¸¸è§é™·é˜±)
  - [ğŸ”š æ€»ç»“](#-æ€»ç»“)
    - [å…³é”®è¦ç‚¹](#å…³é”®è¦ç‚¹)

## ğŸ”§ æ¥å…¥å±‚æ¨¡å¼

### APIç½‘å…³æ¨¡å¼

APIç½‘å…³ä½œä¸ºå¾®æœåŠ¡æ¶æ„çš„ç»Ÿä¸€å…¥å£ï¼Œæä¾›è·¯ç”±ã€è®¤è¯ã€é™æµç­‰åŠŸèƒ½ã€‚

```rust
// src/gateway.rs
use axum::{
    extract::{Request, State},
    http::{HeaderMap, StatusCode},
    middleware::Next,
    response::Response,
    routing::{get, post},
    Router,
};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;

#[derive(Debug, Clone)]
pub struct GatewayConfig {
    pub routes: HashMap<String, String>,
    pub rate_limits: HashMap<String, u32>,
    pub auth_required: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct GatewayState {
    pub config: GatewayConfig,
    pub service_registry: Arc<RwLock<HashMap<String, String>>>,
}

// è·¯ç”±ä¸­é—´ä»¶
pub async fn route_middleware(
    State(state): State<GatewayState>,
    headers: HeaderMap,
    request: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    let path = request.uri().path();
    
    // æŸ¥æ‰¾ç›®æ ‡æœåŠ¡
    if let Some(target_service) = state.config.routes.get(path) {
        // æ£€æŸ¥è®¤è¯è¦æ±‚
        if state.config.auth_required.contains(&path.to_string()) {
            if !validate_auth(&headers).await {
                return Err(StatusCode::UNAUTHORIZED);
            }
        }
        
        // è½¬å‘è¯·æ±‚åˆ°ç›®æ ‡æœåŠ¡
        forward_request(target_service, request).await
    } else {
        Err(StatusCode::NOT_FOUND)
    }
}

// è®¤è¯éªŒè¯
async fn validate_auth(headers: &HeaderMap) -> bool {
    if let Some(auth_header) = headers.get("Authorization") {
        // éªŒè¯JWT token
        validate_jwt_token(auth_header.to_str().unwrap_or("")).await
    } else {
        false
    }
}

// JWTéªŒè¯
async fn validate_jwt_token(token: &str) -> bool {
    // å®é™…çš„JWTéªŒè¯é€»è¾‘
    token.starts_with("Bearer ")
}

// è¯·æ±‚è½¬å‘
async fn forward_request(target_service: &str, request: Request) -> Result<Response, StatusCode> {
    // å®é™…çš„è¯·æ±‚è½¬å‘é€»è¾‘
    // è¿™é‡Œå¯ä»¥ä½¿ç”¨HTTPå®¢æˆ·ç«¯è½¬å‘è¯·æ±‚
    Ok(Response::new("Forwarded".into()))
}
```

### BFF (Backend for Frontend) æ¨¡å¼

ä¸ºä¸åŒå‰ç«¯åº”ç”¨æä¾›å®šåˆ¶åŒ–çš„APIæ¥å£ã€‚

```rust
// src/bff.rs
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::Json,
    routing::get,
    Router,
};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct UserProfile {
    pub id: u64,
    pub name: String,
    pub email: String,
    pub avatar: String,
    pub preferences: UserPreferences,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UserPreferences {
    pub theme: String,
    pub language: String,
    pub notifications: bool,
}

// BFFæœåŠ¡
pub struct BFFService {
    pub user_service: String,
    pub order_service: String,
    pub notification_service: String,
}

impl BFFService {
    pub fn new() -> Self {
        Self {
            user_service: "http://user-service:8080".to_string(),
            order_service: "http://order-service:8080".to_string(),
            notification_service: "http://notification-service:8080".to_string(),
        }
    }
    
    // ä¸ºç§»åŠ¨ç«¯æä¾›èšåˆçš„ç”¨æˆ·ä»ªè¡¨æ¿æ•°æ®
    pub async fn get_mobile_dashboard(&self, user_id: u64) -> Result<Json<serde_json::Value>, StatusCode> {
        // å¹¶è¡Œè·å–ç”¨æˆ·ä¿¡æ¯ã€è®¢å•å’Œé€šçŸ¥
        let (user_result, orders_result, notifications_result) = tokio::join!(
            self.get_user_profile(user_id),
            self.get_user_orders(user_id),
            self.get_user_notifications(user_id)
        );
        
        let user = user_result?;
        let orders = orders_result?;
        let notifications = notifications_result?;
        
        let dashboard = serde_json::json!({
            "user": user,
            "recent_orders": orders,
            "notifications": notifications,
            "mobile_optimized": true
        });
        
        Ok(Json(dashboard))
    }
    
    async fn get_user_profile(&self, user_id: u64) -> Result<UserProfile, StatusCode> {
        // è°ƒç”¨ç”¨æˆ·æœåŠ¡è·å–ç”¨æˆ·ä¿¡æ¯
        Ok(UserProfile {
            id: user_id,
            name: "John Doe".to_string(),
            email: "john@example.com".to_string(),
            avatar: "avatar.jpg".to_string(),
            preferences: UserPreferences {
                theme: "dark".to_string(),
                language: "en".to_string(),
                notifications: true,
            },
        })
    }
    
    async fn get_user_orders(&self, user_id: u64) -> Result<Vec<serde_json::Value>, StatusCode> {
        // è°ƒç”¨è®¢å•æœåŠ¡è·å–è®¢å•ä¿¡æ¯
        Ok(vec![serde_json::json!({
            "id": 1,
            "status": "completed",
            "total": 99.99
        })])
    }
    
    async fn get_user_notifications(&self, user_id: u64) -> Result<Vec<String>, StatusCode> {
        // è°ƒç”¨é€šçŸ¥æœåŠ¡è·å–é€šçŸ¥
        Ok(vec!["New order received".to_string()])
    }
}
```

## ğŸ”„ æœåŠ¡é—´é€šä¿¡æ¨¡å¼

### åŒæ­¥é€šä¿¡ï¼šHTTP/REST

```rust
// src/http_client.rs
use axum::{
    extract::State,
    http::{HeaderMap, HeaderValue, StatusCode},
    response::Json,
};
use reqwest::Client;
use serde::{Deserialize, Serialize};
use std::time::Duration;

#[derive(Debug, Clone)]
pub struct HttpClient {
    pub client: Client,
    pub base_url: String,
    pub timeout: Duration,
}

impl HttpClient {
    pub fn new(base_url: String) -> Self {
        let client = Client::builder()
            .timeout(Duration::from_secs(30))
            .build()
            .unwrap();
        
        Self {
            client,
            base_url,
            timeout: Duration::from_secs(30),
        }
    }
    
    pub async fn get<T>(&self, path: &str) -> Result<T, StatusCode>
    where
        T: for<'de> Deserialize<'de>,
    {
        let url = format!("{}{}", self.base_url, path);
        
        match self.client.get(&url).send().await {
            Ok(response) => {
                if response.status().is_success() {
                    match response.json::<T>().await {
                        Ok(data) => Ok(data),
                        Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
                    }
                } else {
                    Err(StatusCode::from_u16(response.status().as_u16()).unwrap())
                }
            }
            Err(_) => Err(StatusCode::SERVICE_UNAVAILABLE),
        }
    }
    
    pub async fn post<T, U>(&self, path: &str, body: &T) -> Result<U, StatusCode>
    where
        T: Serialize,
        U: for<'de> Deserialize<'de>,
    {
        let url = format!("{}{}", self.base_url, path);
        
        match self.client.post(&url).json(body).send().await {
            Ok(response) => {
                if response.status().is_success() {
                    match response.json::<U>().await {
                        Ok(data) => Ok(data),
                        Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
                    }
                } else {
                    Err(StatusCode::from_u16(response.status().as_u16()).unwrap())
                }
            }
            Err(_) => Err(StatusCode::SERVICE_UNAVAILABLE),
        }
    }
}

// æœåŠ¡é—´é€šä¿¡ç¤ºä¾‹
pub struct UserServiceClient {
    pub http_client: HttpClient,
}

impl UserServiceClient {
    pub fn new() -> Self {
        Self {
            http_client: HttpClient::new("http://user-service:8080".to_string()),
        }
    }
    
    pub async fn get_user(&self, user_id: u64) -> Result<User, StatusCode> {
        self.http_client.get(&format!("/users/{}", user_id)).await
    }
    
    pub async fn create_user(&self, user: CreateUserRequest) -> Result<User, StatusCode> {
        self.http_client.post("/users", &user).await
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct User {
    pub id: u64,
    pub name: String,
    pub email: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CreateUserRequest {
    pub name: String,
    pub email: String,
}
```

### å¼‚æ­¥é€šä¿¡ï¼šæ¶ˆæ¯é©±åŠ¨ (EDA)

```rust
// src/message_driven.rs
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use tokio::sync::mpsc;
use uuid::Uuid;

// äº‹ä»¶å®šä¹‰
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DomainEvent {
    pub id: Uuid,
    pub event_type: String,
    pub aggregate_id: String,
    pub version: u64,
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub data: serde_json::Value,
}

// ç”¨æˆ·åˆ›å»ºäº‹ä»¶
#[derive(Debug, Serialize, Deserialize)]
pub struct UserCreatedEvent {
    pub user_id: u64,
    pub name: String,
    pub email: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
}

// äº‹ä»¶å¤„ç†å™¨trait
#[async_trait]
pub trait EventHandler {
    async fn handle(&self, event: &DomainEvent) -> Result<(), Box<dyn std::error::Error>>;
}

// ç”¨æˆ·æœåŠ¡äº‹ä»¶å¤„ç†å™¨
pub struct UserEventHandler {
    pub notification_service: String,
    pub analytics_service: String,
}

#[async_trait]
impl EventHandler for UserEventHandler {
    async fn handle(&self, event: &DomainEvent) -> Result<(), Box<dyn std::error::Error>> {
        match event.event_type.as_str() {
            "UserCreated" => {
                let user_created: UserCreatedEvent = serde_json::from_value(event.data.clone())?;
                
                // å‘é€æ¬¢è¿é‚®ä»¶
                self.send_welcome_email(&user_created).await?;
                
                // è®°å½•ç”¨æˆ·æ³¨å†Œåˆ†æ
                self.record_user_registration(&user_created).await?;
            }
            _ => {
                // å¿½ç•¥æœªçŸ¥äº‹ä»¶ç±»å‹
            }
        }
        
        Ok(())
    }
}

impl UserEventHandler {
    pub fn new() -> Self {
        Self {
            notification_service: "http://notification-service:8080".to_string(),
            analytics_service: "http://analytics-service:8080".to_string(),
        }
    }
    
    async fn send_welcome_email(&self, event: &UserCreatedEvent) -> Result<(), Box<dyn std::error::Error>> {
        // å‘é€æ¬¢è¿é‚®ä»¶çš„é€»è¾‘
        println!("Sending welcome email to: {}", event.email);
        Ok(())
    }
    
    async fn record_user_registration(&self, event: &UserCreatedEvent) -> Result<(), Box<dyn std::error::Error>> {
        // è®°å½•ç”¨æˆ·æ³¨å†Œåˆ†æçš„é€»è¾‘
        println!("Recording user registration: {}", event.user_id);
        Ok(())
    }
}

// äº‹ä»¶æ€»çº¿
pub struct EventBus {
    pub handlers: HashMap<String, Vec<Box<dyn EventHandler + Send + Sync>>>,
    pub event_channel: mpsc::UnboundedSender<DomainEvent>,
}

impl EventBus {
    pub fn new() -> (Self, mpsc::UnboundedReceiver<DomainEvent>) {
        let (tx, rx) = mpsc::unbounded_channel();
        
        let bus = Self {
            handlers: HashMap::new(),
            event_channel: tx,
        };
        
        (bus, rx)
    }
    
    pub fn subscribe(&mut self, event_type: &str, handler: Box<dyn EventHandler + Send + Sync>) {
        self.handlers
            .entry(event_type.to_string())
            .or_insert_with(Vec::new)
            .push(handler);
    }
    
    pub async fn publish(&self, event: DomainEvent) -> Result<(), Box<dyn std::error::Error>> {
        self.event_channel.send(event)?;
        Ok(())
    }
    
    pub async fn start_event_loop(mut self, mut receiver: mpsc::UnboundedReceiver<DomainEvent>) {
        while let Some(event) = receiver.recv().await {
            if let Some(handlers) = self.handlers.get(&event.event_type) {
                for handler in handlers {
                    if let Err(e) = handler.handle(&event).await {
                        eprintln!("Error handling event {}: {}", event.event_type, e);
                    }
                }
            }
        }
    }
}
```

## ğŸ“Š æ•°æ®ç®¡ç†æ¨¡å¼

### æ¯æœåŠ¡ç‹¬ç«‹æ•°æ®åº“

```rust
// src/database_per_service.rs
use sqlx::{PgPool, Row};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

// ç”¨æˆ·æœåŠ¡æ•°æ®åº“
pub struct UserDatabase {
    pub pool: PgPool,
}

impl UserDatabase {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
    
    pub async fn create_user(&self, user: CreateUserRequest) -> Result<User, sqlx::Error> {
        let row = sqlx::query(
            "INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id, name, email"
        )
        .bind(&user.name)
        .bind(&user.email)
        .fetch_one(&self.pool)
        .await?;
        
        Ok(User {
            id: row.get("id"),
            name: row.get("name"),
            email: row.get("email"),
        })
    }
    
    pub async fn get_user(&self, id: u64) -> Result<Option<User>, sqlx::Error> {
        let row = sqlx::query("SELECT id, name, email FROM users WHERE id = $1")
            .bind(id)
            .fetch_optional(&self.pool)
            .await?;
        
        if let Some(row) = row {
            Ok(Some(User {
                id: row.get("id"),
                name: row.get("name"),
                email: row.get("email"),
            }))
        } else {
            Ok(None)
        }
    }
}

// è®¢å•æœåŠ¡æ•°æ®åº“
pub struct OrderDatabase {
    pub pool: PgPool,
}

impl OrderDatabase {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
    
    pub async fn create_order(&self, order: CreateOrderRequest) -> Result<Order, sqlx::Error> {
        let row = sqlx::query(
            "INSERT INTO orders (user_id, total, status) VALUES ($1, $2, $3) RETURNING id, user_id, total, status"
        )
        .bind(order.user_id)
        .bind(order.total)
        .bind("pending")
        .fetch_one(&self.pool)
        .await?;
        
        Ok(Order {
            id: row.get("id"),
            user_id: row.get("user_id"),
            total: row.get("total"),
            status: row.get("status"),
        })
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct User {
    pub id: u64,
    pub name: String,
    pub email: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CreateUserRequest {
    pub name: String,
    pub email: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Order {
    pub id: u64,
    pub user_id: u64,
    pub total: f64,
    pub status: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CreateOrderRequest {
    pub user_id: u64,
    pub total: f64,
}
```

### åè…å±‚ (Anti-Corruption Layer)

```rust
// src/anti_corruption_layer.rs
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

// å¤–éƒ¨ç³»ç»Ÿæ•°æ®æ¨¡å‹
#[derive(Debug, Serialize, Deserialize)]
pub struct ExternalUser {
    pub user_id: String,
    pub full_name: String,
    pub email_address: String,
    pub created_date: String,
}

// å†…éƒ¨ç³»ç»Ÿæ•°æ®æ¨¡å‹
#[derive(Debug, Serialize, Deserialize)]
pub struct InternalUser {
    pub id: u64,
    pub name: String,
    pub email: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
}

// åè…å±‚é€‚é…å™¨
pub struct UserAdapter;

impl UserAdapter {
    // å°†å¤–éƒ¨ç³»ç»Ÿæ•°æ®è½¬æ¢ä¸ºå†…éƒ¨ç³»ç»Ÿæ•°æ®
    pub fn from_external(external_user: ExternalUser) -> Result<InternalUser, String> {
        // æ•°æ®éªŒè¯å’Œè½¬æ¢
        if external_user.email_address.is_empty() {
            return Err("Email address cannot be empty".to_string());
        }
        
        let id = external_user.user_id.parse::<u64>()
            .map_err(|_| "Invalid user ID format".to_string())?;
        
        let created_at = chrono::DateTime::parse_from_rfc3339(&external_user.created_date)
            .map_err(|_| "Invalid date format".to_string())?
            .with_timezone(&chrono::Utc);
        
        Ok(InternalUser {
            id,
            name: external_user.full_name,
            email: external_user.email_address,
            created_at,
        })
    }
    
    // å°†å†…éƒ¨ç³»ç»Ÿæ•°æ®è½¬æ¢ä¸ºå¤–éƒ¨ç³»ç»Ÿæ•°æ®
    pub fn to_external(internal_user: InternalUser) -> ExternalUser {
        ExternalUser {
            user_id: internal_user.id.to_string(),
            full_name: internal_user.name,
            email_address: internal_user.email,
            created_date: internal_user.created_at.to_rfc3339(),
        }
    }
}

// å¤–éƒ¨ç³»ç»Ÿå®¢æˆ·ç«¯
pub struct ExternalSystemClient {
    pub base_url: String,
    pub api_key: String,
}

impl ExternalSystemClient {
    pub fn new(base_url: String, api_key: String) -> Self {
        Self { base_url, api_key }
    }
    
    pub async fn get_user(&self, user_id: &str) -> Result<ExternalUser, Box<dyn std::error::Error>> {
        // è°ƒç”¨å¤–éƒ¨ç³»ç»ŸAPI
        let url = format!("{}/users/{}", self.base_url, user_id);
        
        // è¿™é‡Œä½¿ç”¨reqwestæˆ–å…¶ä»–HTTPå®¢æˆ·ç«¯
        // å®é™…å®ç°ä¸­ä¼šå‘é€HTTPè¯·æ±‚å¹¶è§£æå“åº”
        
        // æ¨¡æ‹Ÿå“åº”
        Ok(ExternalUser {
            user_id: user_id.to_string(),
            full_name: "John Doe".to_string(),
            email_address: "john@example.com".to_string(),
            created_date: "2025-09-27T10:00:00Z".to_string(),
        })
    }
}

// ç”¨æˆ·æœåŠ¡ä½¿ç”¨åè…å±‚
pub struct UserService {
    pub external_client: ExternalSystemClient,
    pub user_repository: UserRepository,
}

impl UserService {
    pub fn new(external_client: ExternalSystemClient, user_repository: UserRepository) -> Self {
        Self {
            external_client,
            user_repository,
        }
    }
    
    pub async fn sync_user_from_external(&self, external_user_id: &str) -> Result<InternalUser, Box<dyn std::error::Error>> {
        // ä»å¤–éƒ¨ç³»ç»Ÿè·å–ç”¨æˆ·æ•°æ®
        let external_user = self.external_client.get_user(external_user_id).await?;
        
        // ä½¿ç”¨åè…å±‚è½¬æ¢æ•°æ®
        let internal_user = UserAdapter::from_external(external_user)?;
        
        // ä¿å­˜åˆ°å†…éƒ¨æ•°æ®åº“
        self.user_repository.save(internal_user.clone()).await?;
        
        Ok(internal_user)
    }
}

// æ¨¡æ‹Ÿçš„ç”¨æˆ·ä»“åº“
pub struct UserRepository;

impl UserRepository {
    pub async fn save(&self, user: InternalUser) -> Result<(), Box<dyn std::error::Error>> {
        // ä¿å­˜ç”¨æˆ·åˆ°æ•°æ®åº“çš„é€»è¾‘
        println!("Saving user: {:?}", user);
        Ok(())
    }
}
```

## ğŸ›¡ï¸ å¼¹æ€§ä¸éŸ§æ€§æ¨¡å¼

### ç†”æ–­å™¨æ¨¡å¼

```rust
// src/circuit_breaker.rs
use std::sync::atomic::{AtomicU32, Ordering};
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::RwLock;

#[derive(Debug, Clone)]
pub enum CircuitState {
    Closed,    // æ­£å¸¸çŠ¶æ€
    Open,      // ç†”æ–­çŠ¶æ€
    HalfOpen,  // åŠå¼€çŠ¶æ€
}

pub struct CircuitBreaker {
    pub failure_threshold: u32,
    pub recovery_timeout: Duration,
    pub state: Arc<RwLock<CircuitState>>,
    pub failure_count: AtomicU32,
    pub last_failure_time: Arc<RwLock<Option<Instant>>>,
}

impl CircuitBreaker {
    pub fn new(failure_threshold: u32, recovery_timeout: Duration) -> Self {
        Self {
            failure_threshold,
            recovery_timeout,
            state: Arc::new(RwLock::new(CircuitState::Closed)),
            failure_count: AtomicU32::new(0),
            last_failure_time: Arc::new(RwLock::new(None)),
        }
    }
    
    pub async fn call<F, T, E>(&self, operation: F) -> Result<T, E>
    where
        F: FnOnce() -> Result<T, E>,
    {
        let current_state = self.state.read().await;
        
        match *current_state {
            CircuitState::Open => {
                // æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿›å…¥åŠå¼€çŠ¶æ€
                if self.should_attempt_reset().await {
                    drop(current_state);
                    let mut state = self.state.write().await;
                    *state = CircuitState::HalfOpen;
                } else {
                    return Err(self.create_circuit_open_error());
                }
            }
            CircuitState::HalfOpen => {
                // åŠå¼€çŠ¶æ€ï¼Œå…è®¸ä¸€æ¬¡å°è¯•
            }
            CircuitState::Closed => {
                // æ­£å¸¸çŠ¶æ€
            }
        }
        
        // æ‰§è¡Œæ“ä½œ
        match operation() {
            Ok(result) => {
                self.on_success().await;
                Ok(result)
            }
            Err(error) => {
                self.on_failure().await;
                Err(error)
            }
        }
    }
    
    async fn should_attempt_reset(&self) -> bool {
        if let Some(last_failure) = *self.last_failure_time.read().await {
            Instant::now().duration_since(last_failure) >= self.recovery_timeout
        } else {
            true
        }
    }
    
    async fn on_success(&self) {
        self.failure_count.store(0, Ordering::Relaxed);
        let mut state = self.state.write().await;
        *state = CircuitState::Closed;
    }
    
    async fn on_failure(&self) {
        let count = self.failure_count.fetch_add(1, Ordering::Relaxed) + 1;
        let mut last_failure = self.last_failure_time.write().await;
        *last_failure = Some(Instant::now());
        
        if count >= self.failure_threshold {
            let mut state = self.state.write().await;
            *state = CircuitState::Open;
        }
    }
    
    fn create_circuit_open_error<E>(&self) -> E {
        // è¿™é‡Œéœ€è¦æ ¹æ®å…·ä½“çš„é”™è¯¯ç±»å‹æ¥å®ç°
        // ä¸ºäº†ç¤ºä¾‹ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªé€šç”¨çš„é”™è¯¯
        panic!("Circuit breaker is open")
    }
}

// ä½¿ç”¨ç†”æ–­å™¨çš„æœåŠ¡å®¢æˆ·ç«¯
pub struct ResilientServiceClient {
    pub circuit_breaker: CircuitBreaker,
    pub http_client: HttpClient,
}

impl ResilientServiceClient {
    pub fn new() -> Self {
        Self {
            circuit_breaker: CircuitBreaker::new(
                5, // å¤±è´¥é˜ˆå€¼
                Duration::from_secs(60), // æ¢å¤è¶…æ—¶
            ),
            http_client: HttpClient::new("http://external-service:8080".to_string()),
        }
    }
    
    pub async fn call_external_service(&self) -> Result<String, Box<dyn std::error::Error>> {
        self.circuit_breaker.call(|| async {
            // æ¨¡æ‹Ÿå¤–éƒ¨æœåŠ¡è°ƒç”¨
            self.http_client.get::<String>("/api/data").await
                .map_err(|e| format!("HTTP error: {}", e))
        }).await
    }
}
```

## ğŸ“– æœ€ä½³å®è·µ

### 1. æ¨¡å¼é€‰æ‹©åŸåˆ™

- **æ ¹æ®ä¸šåŠ¡éœ€æ±‚é€‰æ‹©æ¨¡å¼**: ä¸åŒçš„ä¸šåŠ¡åœºæ™¯éœ€è¦ä¸åŒçš„æ¶æ„æ¨¡å¼
- **è€ƒè™‘ç³»ç»Ÿå¤æ‚åº¦**: ç®€å•ç³»ç»Ÿé¿å…è¿‡åº¦è®¾è®¡ï¼Œå¤æ‚ç³»ç»Ÿéœ€è¦åˆé€‚çš„æ¨¡å¼
- **æ€§èƒ½ä¸ä¸€è‡´æ€§æƒè¡¡**: åœ¨æ€§èƒ½å’Œä¸€è‡´æ€§ä¹‹é—´æ‰¾åˆ°å¹³è¡¡ç‚¹
- **å›¢é˜ŸæŠ€èƒ½åŒ¹é…**: é€‰æ‹©å›¢é˜Ÿç†Ÿæ‚‰å’Œèƒ½å¤Ÿç»´æŠ¤çš„æ¨¡å¼

### 2. å®æ–½å»ºè®®

- **æ¸è¿›å¼é‡‡ç”¨**: é€æ­¥å¼•å…¥æ–°çš„æ¶æ„æ¨¡å¼ï¼Œé¿å…å¤§è§„æ¨¡é‡æ„
- **ç›‘æ§å’Œåº¦é‡**: å»ºç«‹å®Œå–„çš„ç›‘æ§ä½“ç³»ï¼ŒåŠæ—¶å‘ç°é—®é¢˜
- **æ–‡æ¡£å’ŒåŸ¹è®­**: ä¸ºå›¢é˜Ÿæä¾›å……åˆ†çš„æ–‡æ¡£å’ŒåŸ¹è®­æ”¯æŒ
- **æŒç»­æ”¹è¿›**: æ ¹æ®å®é™…è¿è¡Œæƒ…å†µæŒç»­ä¼˜åŒ–æ¶æ„

### 3. å¸¸è§é™·é˜±

- **è¿‡åº¦è®¾è®¡**: é¿å…ä¸ºäº†ä½¿ç”¨æ¨¡å¼è€Œä½¿ç”¨æ¨¡å¼
- **å¿½ç•¥è¿ç»´**: è®¾è®¡æ—¶è€ƒè™‘è¿ç»´çš„å¤æ‚æ€§å’Œæˆæœ¬
- **ç¼ºä¹æµ‹è¯•**: ç¡®ä¿æ¶æ„æ¨¡å¼æœ‰å……åˆ†çš„æµ‹è¯•è¦†ç›–
- **æŠ€æœ¯å€ºåŠ¡**: åŠæ—¶å¤„ç†æ¶æ„æ¼”è¿›ä¸­çš„æŠ€æœ¯å€ºåŠ¡

## ğŸ”š æ€»ç»“

å¾®æœåŠ¡æ¶æ„è®¾è®¡æ¨¡å¼æ˜¯æ„å»ºå¯æ‰©å±•ã€å¯ç»´æŠ¤å¾®æœåŠ¡ç³»ç»Ÿçš„é‡è¦å·¥å…·ã€‚é€šè¿‡åˆç†é€‰æ‹©å’Œç»„åˆè¿™äº›æ¨¡å¼ï¼Œå¯ä»¥æ„å»ºå‡ºæ»¡è¶³ä¸šåŠ¡éœ€æ±‚çš„é«˜è´¨é‡å¾®æœåŠ¡ç³»ç»Ÿã€‚

### å…³é”®è¦ç‚¹

- **æ¨¡å¼ä¸æ˜¯é“¶å¼¹**: æ¯ä¸ªæ¨¡å¼éƒ½æœ‰å…¶é€‚ç”¨åœºæ™¯å’Œå±€é™æ€§
- **ç»„åˆä½¿ç”¨**: å®é™…ç³»ç»Ÿä¸­é€šå¸¸éœ€è¦ç»„åˆä½¿ç”¨å¤šç§æ¨¡å¼
- **æŒç»­æ¼”è¿›**: æ¶æ„æ¨¡å¼éœ€è¦æ ¹æ®ä¸šåŠ¡å‘å±•æŒç»­æ¼”è¿›
- **å›¢é˜Ÿåä½œ**: æˆåŠŸçš„æ¶æ„å®æ–½éœ€è¦å›¢é˜Ÿçš„ç†è§£å’Œæ”¯æŒ

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¶é—´**: 2025-09-27  
**æ›´æ–°æ—¶é—´**: 2025-09-27
