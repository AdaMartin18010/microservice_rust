# 错误处理与容错机制

> 基于Rust 1.90的微服务错误处理与容错机制完整指南

## 📋 概述

本文档深入探讨微服务架构中的错误处理和容错机制设计。通过统一的错误模型、完善的容错策略和全面的可观测性，构建高可用、高可靠的微服务系统。

## 🎯 学习目标

- 理解微服务错误处理的核心原则和最佳实践
- 掌握统一错误模型的设计和实现
- 了解各种容错策略的应用场景和实现方法
- 学习如何建立完善的错误监控和告警体系

## 📚 内容大纲

- [错误处理与容错机制](#错误处理与容错机制)
  - [📋 概述](#-概述)
  - [🎯 学习目标](#-学习目标)
  - [📚 内容大纲](#-内容大纲)
  - [🔧 统一错误模型](#-统一错误模型)
    - [错误类型定义](#错误类型定义)
    - [HTTP错误响应处理](#http错误响应处理)
  - [🔄 容错策略](#-容错策略)
    - [重试机制](#重试机制)
  - [📖 最佳实践](#-最佳实践)
    - [1. 错误处理原则](#1-错误处理原则)
    - [2. 容错策略选择](#2-容错策略选择)
    - [3. 监控和告警](#3-监控和告警)
  - [🔚 总结](#-总结)
    - [关键要点](#关键要点)

## 🔧 统一错误模型

### 错误类型定义

```rust
// src/error.rs
use thiserror::Error;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

// 错误级别
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ErrorLevel {
    User,      // 用户错误
    System,    // 系统错误
    Dependency, // 依赖错误
}

// 错误分类
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ErrorCategory {
    Validation,    // 验证错误
    Authentication, // 认证错误
    Authorization,  // 授权错误
    NotFound,      // 资源不存在
    Conflict,      // 冲突错误
    Timeout,       // 超时错误
    RateLimit,     // 限流错误
    CircuitBreaker, // 熔断器错误
    Internal,      // 内部错误
    External,      // 外部依赖错误
}

// 统一错误结构
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceError {
    pub code: String,
    pub message: String,
    pub level: ErrorLevel,
    pub category: ErrorCategory,
    pub details: Option<HashMap<String, serde_json::Value>>,
    pub trace_id: Option<String>,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

impl ServiceError {
    pub fn new(
        code: &str,
        message: &str,
        level: ErrorLevel,
        category: ErrorCategory,
    ) -> Self {
        Self {
            code: code.to_string(),
            message: message.to_string(),
            level,
            category,
            details: None,
            trace_id: None,
            timestamp: chrono::Utc::now(),
        }
    }
    
    // 用户错误
    pub fn user_error(code: &str, message: &str, category: ErrorCategory) -> Self {
        Self::new(code, message, ErrorLevel::User, category)
    }
    
    // 系统错误
    pub fn system_error(code: &str, message: &str, category: ErrorCategory) -> Self {
        Self::new(code, message, ErrorLevel::System, category)
    }
    
    // 依赖错误
    pub fn dependency_error(code: &str, message: &str, category: ErrorCategory) -> Self {
        Self::new(code, message, ErrorLevel::Dependency, category)
    }
}

// 使用thiserror定义具体错误类型
#[derive(Error, Debug)]
pub enum UserServiceError {
    #[error("用户不存在: {user_id}")]
    UserNotFound { user_id: u64 },
    
    #[error("邮箱已存在: {email}")]
    EmailAlreadyExists { email: String },
    
    #[error("密码强度不足")]
    WeakPassword,
    
    #[error("数据库连接失败")]
    DatabaseConnectionFailed,
    
    #[error("外部服务调用失败: {service}")]
    ExternalServiceError { service: String },
    
    #[error("请求超时")]
    RequestTimeout,
    
    #[error("限流触发")]
    RateLimitExceeded,
}

impl UserServiceError {
    pub fn to_service_error(&self) -> ServiceError {
        match self {
            UserServiceError::UserNotFound { user_id } => {
                ServiceError::user_error(
                    "USER_NOT_FOUND",
                    &format!("用户不存在: {}", user_id),
                    ErrorCategory::NotFound,
                )
            }
            UserServiceError::EmailAlreadyExists { email } => {
                ServiceError::user_error(
                    "EMAIL_EXISTS",
                    &format!("邮箱已存在: {}", email),
                    ErrorCategory::Conflict,
                )
            }
            UserServiceError::WeakPassword => {
                ServiceError::user_error(
                    "WEAK_PASSWORD",
                    "密码强度不足",
                    ErrorCategory::Validation,
                )
            }
            UserServiceError::DatabaseConnectionFailed => {
                ServiceError::system_error(
                    "DB_CONNECTION_FAILED",
                    "数据库连接失败",
                    ErrorCategory::Internal,
                )
            }
            UserServiceError::ExternalServiceError { service } => {
                ServiceError::dependency_error(
                    "EXTERNAL_SERVICE_ERROR",
                    &format!("外部服务调用失败: {}", service),
                    ErrorCategory::External,
                )
            }
            UserServiceError::RequestTimeout => {
                ServiceError::system_error(
                    "REQUEST_TIMEOUT",
                    "请求超时",
                    ErrorCategory::Timeout,
                )
            }
            UserServiceError::RateLimitExceeded => {
                ServiceError::user_error(
                    "RATE_LIMIT_EXCEEDED",
                    "限流触发",
                    ErrorCategory::RateLimit,
                )
            }
        }
    }
}
```

### HTTP错误响应处理

```rust
// src/http_error_handler.rs
use axum::{
    extract::Request,
    http::StatusCode,
    middleware::Next,
    response::{IntoResponse, Response},
    Json,
};
use serde_json::json;
use tracing::{error, warn};

// HTTP错误响应
#[derive(Debug, Serialize, Deserialize)]
pub struct ErrorResponse {
    pub error: ServiceError,
    pub request_id: Option<String>,
}

impl IntoResponse for ServiceError {
    fn into_response(self) -> Response {
        let status_code = match self.category {
            ErrorCategory::Validation => StatusCode::BAD_REQUEST,
            ErrorCategory::Authentication => StatusCode::UNAUTHORIZED,
            ErrorCategory::Authorization => StatusCode::FORBIDDEN,
            ErrorCategory::NotFound => StatusCode::NOT_FOUND,
            ErrorCategory::Conflict => StatusCode::CONFLICT,
            ErrorCategory::RateLimit => StatusCode::TOO_MANY_REQUESTS,
            ErrorCategory::Timeout => StatusCode::REQUEST_TIMEOUT,
            ErrorCategory::CircuitBreaker => StatusCode::SERVICE_UNAVAILABLE,
            ErrorCategory::Internal => StatusCode::INTERNAL_SERVER_ERROR,
            ErrorCategory::External => StatusCode::BAD_GATEWAY,
        };
        
        let response = ErrorResponse {
            error: self.clone(),
            request_id: self.trace_id,
        };
        
        // 记录错误日志
        match self.level {
            ErrorLevel::User => {
                warn!(
                    "User error: {} - {}",
                    self.code,
                    self.message
                );
            }
            ErrorLevel::System | ErrorLevel::Dependency => {
                error!(
                    "System error: {} - {} - {:?}",
                    self.code,
                    self.message,
                    self.details
                );
            }
        }
        
        (status_code, Json(response)).into_response()
    }
}
```

## 🔄 容错策略

### 重试机制

```rust
// src/retry.rs
use std::time::Duration;
use tokio::time::sleep;
use rand::Rng;

#[derive(Debug, Clone)]
pub struct RetryConfig {
    pub max_attempts: u32,
    pub base_delay: Duration,
    pub max_delay: Duration,
    pub backoff_multiplier: f64,
    pub jitter: bool,
}

impl Default for RetryConfig {
    fn default() -> Self {
        Self {
            max_attempts: 3,
            base_delay: Duration::from_millis(100),
            max_delay: Duration::from_secs(5),
            backoff_multiplier: 2.0,
            jitter: true,
        }
    }
}

pub struct RetryExecutor {
    pub config: RetryConfig,
}

impl RetryExecutor {
    pub fn new(config: RetryConfig) -> Self {
        Self { config }
    }
    
    pub async fn execute<F, T, E>(&self, operation: F) -> Result<T, E>
    where
        F: Fn() -> Result<T, E>,
        E: Clone,
    {
        let mut attempt = 0;
        let mut delay = self.config.base_delay;
        
        loop {
            attempt += 1;
            
            match operation() {
                Ok(result) => return Ok(result),
                Err(error) => {
                    if attempt >= self.config.max_attempts {
                        return Err(error);
                    }
                    
                    // 计算延迟时间
                    let actual_delay = if self.config.jitter {
                        self.add_jitter(delay)
                    } else {
                        delay
                    };
                    
                    // 等待后重试
                    sleep(actual_delay).await;
                    
                    // 指数退避
                    delay = Duration::from_millis(
                        (delay.as_millis() as f64 * self.config.backoff_multiplier) as u64
                    ).min(self.config.max_delay);
                }
            }
        }
    }
    
    fn add_jitter(&self, delay: Duration) -> Duration {
        let mut rng = rand::thread_rng();
        let jitter_factor = rng.gen_range(0.5..1.5);
        Duration::from_millis((delay.as_millis() as f64 * jitter_factor) as u64)
    }
}
```

## 📖 最佳实践

### 1. 错误处理原则

- **快速失败**: 对于不可恢复的错误，应该快速失败并返回明确的错误信息
- **优雅降级**: 对于可恢复的错误，应该提供降级方案
- **错误分类**: 将错误分为用户错误、系统错误和依赖错误
- **错误传播**: 合理传播错误，避免信息丢失

### 2. 容错策略选择

- **重试策略**: 适用于临时性错误，需要设置合理的重试次数和间隔
- **熔断器**: 适用于外部依赖，防止级联故障
- **限流**: 保护系统不被过载，需要根据系统容量设置
- **降级**: 在系统压力过大时提供基本功能

### 3. 监控和告警

- **错误率监控**: 监控各种错误的发生率
- **响应时间监控**: 监控系统响应时间
- **依赖健康检查**: 监控外部依赖的健康状态
- **告警阈值**: 设置合理的告警阈值，避免告警疲劳

## 🔚 总结

错误处理和容错机制是微服务架构中确保系统高可用性的重要组成部分。通过统一的错误模型、完善的容错策略和全面的可观测性，可以构建出高可靠、高可用的微服务系统。

### 关键要点

- **预防胜于治疗**: 通过设计避免错误的发生
- **快速恢复**: 当错误发生时，能够快速恢复服务
- **可观测性**: 建立完善的监控和告警体系
- **持续改进**: 根据监控数据持续优化错误处理策略

---

**文档版本**: v1.0  
**创建时间**: 2025-09-27  
**更新时间**: 2025-09-27
