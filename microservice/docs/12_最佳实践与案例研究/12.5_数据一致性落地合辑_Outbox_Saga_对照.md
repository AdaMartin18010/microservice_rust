# æ•°æ®ä¸€è‡´æ€§è½åœ°åˆè¾‘ï¼šOutbox/Saga/äº‹ä»¶å›æ”¾

> åŸºäºRust 1.90å’Œ2025å¹´æœ€æ–°æŠ€æœ¯æ ˆçš„åˆ†å¸ƒå¼æ•°æ®ä¸€è‡´æ€§å®Œæ•´è§£å†³æ–¹æ¡ˆ

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›äº†åˆ†å¸ƒå¼ç³»ç»Ÿä¸­æ•°æ®ä¸€è‡´æ€§çš„å®Œæ•´è§£å†³æ–¹æ¡ˆï¼ŒåŒ…æ‹¬Outboxæ¨¡å¼ã€Sagaæ¨¡å¼ã€äº‹ä»¶å›æ”¾ç­‰æ ¸å¿ƒæ¨¡å¼çš„é€‰æ‹©çŸ©é˜µã€å®ç°ç¤ºä¾‹å’Œæœ€ä½³å®è·µã€‚

## ğŸ¯ ä¸€è‡´æ€§æ¨¡å¼é€‰æ‹©çŸ©é˜µ

| åœºæ™¯ | ä¸€è‡´æ€§è¦æ±‚ | æ€§èƒ½è¦æ±‚ | å¤æ‚åº¦ | æ¨èæ¨¡å¼ | å¤‡é€‰æ–¹æ¡ˆ |
|------|------------|----------|--------|----------|----------|
| è®¢å•å¤„ç† | å¼ºä¸€è‡´æ€§ | ä¸­ç­‰ | ä¸­ç­‰ | Saga | 2PC |
| ç”¨æˆ·æ³¨å†Œ | æœ€ç»ˆä¸€è‡´æ€§ | é«˜ | ä½ | Outbox | äº‹ä»¶æº¯æº |
| åº“å­˜ç®¡ç† | å¼ºä¸€è‡´æ€§ | é«˜ | é«˜ | Saga + é” | ä¹è§‚é” |
| æ”¯ä»˜å¤„ç† | å¼ºä¸€è‡´æ€§ | ä¸­ç­‰ | é«˜ | Saga | 2PC |
| æ—¥å¿—è®°å½• | æœ€ç»ˆä¸€è‡´æ€§ | é«˜ | ä½ | Outbox | ç›´æ¥å†™å…¥ |
| é€šçŸ¥å‘é€ | æœ€ç»ˆä¸€è‡´æ€§ | é«˜ | ä½ | Outbox | æ¶ˆæ¯é˜Ÿåˆ— |

## ğŸ—ï¸ æ ¸å¿ƒæ¨¡å¼è¯¦è§£

### 1. Outboxæ¨¡å¼

#### 1.1 æ¨¡å¼æ¦‚è¿°

Outboxæ¨¡å¼é€šè¿‡å°†ä¸šåŠ¡æ•°æ®å’Œäº‹ä»¶æ•°æ®å­˜å‚¨åœ¨åŒä¸€ä¸ªäº‹åŠ¡ä¸­ï¼Œç¡®ä¿æ•°æ®ä¸€è‡´æ€§ã€‚

```rust
// æ•°æ®åº“è¡¨ç»“æ„
CREATE TABLE orders (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    status VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE outbox_events (
    id UUID PRIMARY KEY,
    aggregate_id UUID NOT NULL,
    event_type VARCHAR(100) NOT NULL,
    event_data JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    processed_at TIMESTAMP,
    status VARCHAR(20) DEFAULT 'pending'
);
```

#### 1.2 Rustå®ç°

```rust
use sqlx::{PgPool, Postgres, Transaction};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize)]
pub struct Order {
    pub id: Uuid,
    pub user_id: Uuid,
    pub amount: f64,
    pub status: String,
    pub created_at: DateTime<Utc>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OutboxEvent {
    pub id: Uuid,
    pub aggregate_id: Uuid,
    pub event_type: String,
    pub event_data: serde_json::Value,
    pub created_at: DateTime<Utc>,
    pub processed_at: Option<DateTime<Utc>>,
    pub status: String,
}

pub struct OrderService {
    pool: PgPool,
}

impl OrderService {
    pub async fn create_order(
        &self,
        user_id: Uuid,
        amount: f64,
    ) -> Result<Order, sqlx::Error> {
        let mut tx = self.pool.begin().await?;
        
        // 1. åˆ›å»ºè®¢å•
        let order_id = Uuid::new_v4();
        let order = sqlx::query_as!(
            Order,
            r#"
            INSERT INTO orders (id, user_id, amount, status)
            VALUES ($1, $2, $3, 'pending')
            RETURNING id, user_id, amount, status, created_at
            "#,
            order_id,
            user_id,
            amount
        )
        .fetch_one(&mut *tx)
        .await?;
        
        // 2. åˆ›å»ºOutboxäº‹ä»¶
        let event = OrderCreatedEvent {
            order_id,
            user_id,
            amount,
            created_at: Utc::now(),
        };
        
        sqlx::query!(
            r#"
            INSERT INTO outbox_events (id, aggregate_id, event_type, event_data)
            VALUES ($1, $2, $3, $4)
            "#,
            Uuid::new_v4(),
            order_id,
            "OrderCreated",
            serde_json::to_value(&event)?
        )
        .execute(&mut *tx)
        .await?;
        
        // 3. æäº¤äº‹åŠ¡
        tx.commit().await?;
        
        Ok(order)
    }
}
```

### 2. Sagaæ¨¡å¼

#### 2.1 æ¨¡å¼æ¦‚è¿°

Sagaæ¨¡å¼é€šè¿‡å°†é•¿äº‹åŠ¡åˆ†è§£ä¸ºå¤šä¸ªæœ¬åœ°äº‹åŠ¡ï¼Œæ¯ä¸ªæœ¬åœ°äº‹åŠ¡éƒ½æœ‰å¯¹åº”çš„è¡¥å¿æ“ä½œã€‚

```rust
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize)]
pub enum SagaStep {
    ReserveInventory { product_id: Uuid, quantity: i32 },
    ProcessPayment { order_id: Uuid, amount: f64 },
    CreateOrder { user_id: Uuid, items: Vec<OrderItem> },
    SendNotification { user_id: Uuid, message: String },
}

#[derive(Debug, Serialize, Deserialize)]
pub enum CompensatingAction {
    ReleaseInventory { product_id: Uuid, quantity: i32 },
    RefundPayment { order_id: Uuid, amount: f64 },
    CancelOrder { order_id: Uuid },
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OrderItem {
    pub product_id: Uuid,
    pub quantity: i32,
    pub price: f64,
}

pub struct SagaOrchestrator {
    pool: PgPool,
}

impl SagaOrchestrator {
    pub async fn create_order_saga(
        &self,
        user_id: Uuid,
        items: Vec<OrderItem>,
    ) -> Result<Uuid, Box<dyn std::error::Error>> {
        let saga_id = Uuid::new_v4();
        let order_id = Uuid::new_v4();
        
        // è®¡ç®—æ€»é‡‘é¢
        let total_amount: f64 = items.iter()
            .map(|item| item.price * item.quantity as f64)
            .sum();
        
        // åˆ›å»ºSagaæ­¥éª¤
        let steps = vec![
            SagaStep::ReserveInventory {
                product_id: items[0].product_id,
                quantity: items[0].quantity,
            },
            SagaStep::ProcessPayment {
                order_id,
                amount: total_amount,
            },
            SagaStep::CreateOrder {
                user_id,
                items: items.clone(),
            },
            SagaStep::SendNotification {
                user_id,
                message: format!("Order {} created successfully", order_id),
            },
        ];
        
        // åˆ›å»ºè¡¥å¿æ“ä½œ
        let compensating_actions = vec![
            CompensatingAction::ReleaseInventory {
                product_id: items[0].product_id,
                quantity: items[0].quantity,
            },
            CompensatingAction::RefundPayment {
                order_id,
                amount: total_amount,
            },
            CompensatingAction::CancelOrder { order_id },
        ];
        
        // æ‰§è¡ŒSaga
        self.execute_saga(&steps, &compensating_actions).await?;
        
        Ok(saga_id)
    }
    
    async fn execute_saga(
        &self,
        steps: &[SagaStep],
        compensating_actions: &[CompensatingAction],
    ) -> Result<(), Box<dyn std::error::Error>> {
        for (i, step) in steps.iter().enumerate() {
            match self.execute_step(step).await {
                Ok(()) => {
                    // æ­¥éª¤æ‰§è¡ŒæˆåŠŸï¼Œç»§ç»­ä¸‹ä¸€æ­¥
                }
                Err(e) => {
                    eprintln!("Step {} failed: {}", i, e);
                    // å¼€å§‹è¡¥å¿
                    self.compensate_saga(compensating_actions, i).await?;
                    return Err(e);
                }
            }
        }
        Ok(())
    }
    
    async fn execute_step(&self, step: &SagaStep) -> Result<(), Box<dyn std::error::Error>> {
        match step {
            SagaStep::ReserveInventory { product_id, quantity } => {
                self.reserve_inventory(*product_id, *quantity).await?;
            }
            SagaStep::ProcessPayment { order_id, amount } => {
                self.process_payment(*order_id, *amount).await?;
            }
            SagaStep::CreateOrder { user_id, items } => {
                self.create_order(*user_id, items.clone()).await?;
            }
            SagaStep::SendNotification { user_id, message } => {
                self.send_notification(*user_id, message.clone()).await?;
            }
        }
        Ok(())
    }
    
    async fn compensate_saga(
        &self,
        compensating_actions: &[CompensatingAction],
        failed_step: usize,
    ) -> Result<(), Box<dyn std::error::Error>> {
        // ä»å¤±è´¥æ­¥éª¤çš„å‰ä¸€æ­¥å¼€å§‹è¡¥å¿
        for i in (0..failed_step).rev() {
            if let Some(compensating_action) = compensating_actions.get(i) {
                match self.execute_compensating_action(compensating_action).await {
                    Ok(()) => {
                        eprintln!("Compensated step {}", i);
                    }
                    Err(e) => {
                        eprintln!("Failed to compensate step {}: {}", i, e);
                        // è®°å½•è¡¥å¿å¤±è´¥ï¼Œéœ€è¦äººå·¥å¹²é¢„
                    }
                }
            }
        }
        Ok(())
    }
    
    // å…·ä½“çš„ä¸šåŠ¡æ–¹æ³•å®ç°
    async fn reserve_inventory(&self, product_id: Uuid, quantity: i32) -> Result<(), sqlx::Error> {
        sqlx::query!(
            r#"
            UPDATE inventory
            SET reserved_quantity = reserved_quantity + $2
            WHERE product_id = $1 AND available_quantity >= $2
            "#,
            product_id,
            quantity
        )
        .execute(&self.pool)
        .await?;
        Ok(())
    }
    
    async fn process_payment(&self, order_id: Uuid, amount: f64) -> Result<(), sqlx::Error> {
        sqlx::query!(
            r#"
            INSERT INTO payments (id, order_id, amount, status, created_at)
            VALUES ($1, $2, $3, 'completed', NOW())
            "#,
            Uuid::new_v4(),
            order_id,
            amount
        )
        .execute(&self.pool)
        .await?;
        Ok(())
    }
    
    async fn create_order(&self, user_id: Uuid, items: Vec<OrderItem>) -> Result<(), sqlx::Error> {
        let order_id = Uuid::new_v4();
        sqlx::query!(
            r#"
            INSERT INTO orders (id, user_id, status, created_at)
            VALUES ($1, $2, 'created', NOW())
            "#,
            order_id,
            user_id
        )
        .execute(&self.pool)
        .await?;
        
        for item in items {
            sqlx::query!(
                r#"
                INSERT INTO order_items (id, order_id, product_id, quantity, price)
                VALUES ($1, $2, $3, $4, $5)
                "#,
                Uuid::new_v4(),
                order_id,
                item.product_id,
                item.quantity,
                item.price
            )
            .execute(&self.pool)
            .await?;
        }
        Ok(())
    }
    
    async fn send_notification(&self, user_id: Uuid, message: String) -> Result<(), sqlx::Error> {
        // æ¨¡æ‹Ÿå‘é€é€šçŸ¥
        println!("Sending notification to user {}: {}", user_id, message);
        Ok(())
    }
    
    async fn execute_compensating_action(
        &self,
        action: &CompensatingAction,
    ) -> Result<(), Box<dyn std::error::Error>> {
        match action {
            CompensatingAction::ReleaseInventory { product_id, quantity } => {
                self.release_inventory(*product_id, *quantity).await?;
            }
            CompensatingAction::RefundPayment { order_id, amount } => {
                self.refund_payment(*order_id, *amount).await?;
            }
            CompensatingAction::CancelOrder { order_id } => {
                self.cancel_order(*order_id).await?;
            }
        }
        Ok(())
    }
    
    async fn release_inventory(&self, product_id: Uuid, quantity: i32) -> Result<(), sqlx::Error> {
        sqlx::query!(
            r#"
            UPDATE inventory
            SET reserved_quantity = reserved_quantity - $2
            WHERE product_id = $1
            "#,
            product_id,
            quantity
        )
        .execute(&self.pool)
        .await?;
        Ok(())
    }
    
    async fn refund_payment(&self, order_id: Uuid, amount: f64) -> Result<(), sqlx::Error> {
        sqlx::query!(
            r#"
            UPDATE payments
            SET status = 'refunded', refunded_at = NOW()
            WHERE order_id = $1
            "#,
            order_id
        )
        .execute(&self.pool)
        .await?;
        Ok(())
    }
    
    async fn cancel_order(&self, order_id: Uuid) -> Result<(), sqlx::Error> {
        sqlx::query!(
            r#"
            UPDATE orders
            SET status = 'cancelled', cancelled_at = NOW()
            WHERE id = $1
            "#,
            order_id
        )
        .execute(&self.pool)
        .await?;
        Ok(())
    }
}
```

## ğŸ“Š æ€§èƒ½å¯¹æ¯”åˆ†æ

### 1. æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”

| æ¨¡å¼ | å»¶è¿Ÿ | ååé‡ | èµ„æºä½¿ç”¨ | å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|------|--------|----------|--------|----------|
| Outbox | ä½ | é«˜ | ä¸­ç­‰ | ä½ | æœ€ç»ˆä¸€è‡´æ€§ |
| Saga | ä¸­ç­‰ | ä¸­ç­‰ | é«˜ | é«˜ | å¼ºä¸€è‡´æ€§ |
| äº‹ä»¶å›æ”¾ | é«˜ | ä½ | é«˜ | é«˜ | å®¡è®¡å’Œæ¢å¤ |
| 2PC | é«˜ | ä½ | ä¸­ç­‰ | ä¸­ç­‰ | å¼ºä¸€è‡´æ€§ |

## ğŸš€ æœ€ä½³å®è·µæ€»ç»“

### 1. æ¨¡å¼é€‰æ‹©åŸåˆ™

- âœ… **å¼ºä¸€è‡´æ€§éœ€æ±‚**ï¼šé€‰æ‹©Sagaæ¨¡å¼
- âœ… **æœ€ç»ˆä¸€è‡´æ€§å¯æ¥å—**ï¼šé€‰æ‹©Outboxæ¨¡å¼
- âœ… **å®¡è®¡å’Œæ¢å¤éœ€æ±‚**ï¼šé€‰æ‹©äº‹ä»¶å›æ”¾æ¨¡å¼
- âœ… **ç®€å•åœºæ™¯**ï¼šé€‰æ‹©Outboxæ¨¡å¼
- âœ… **å¤æ‚ä¸šåŠ¡æµç¨‹**ï¼šé€‰æ‹©Sagaæ¨¡å¼

### 2. å®ç°æœ€ä½³å®è·µ

- âœ… **å¹‚ç­‰æ€§**ï¼šæ‰€æœ‰æ“ä½œéƒ½è¦æ”¯æŒå¹‚ç­‰æ€§
- âœ… **è¶…æ—¶å¤„ç†**ï¼šè®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´
- âœ… **é‡è¯•æœºåˆ¶**ï¼šå®ç°æŒ‡æ•°é€€é¿é‡è¯•
- âœ… **ç›‘æ§å‘Šè­¦**ï¼šç›‘æ§å…³é”®æŒ‡æ ‡å’Œå¼‚å¸¸
- âœ… **æ—¥å¿—è®°å½•**ï¼šè¯¦ç»†è®°å½•æ“ä½œæ—¥å¿—

### 3. æ€§èƒ½ä¼˜åŒ–å»ºè®®

- âœ… **æ‰¹é‡å¤„ç†**ï¼šæ‰¹é‡å¤„ç†äº‹ä»¶å’Œæ“ä½œ
- âœ… **å¼‚æ­¥å¤„ç†**ï¼šä½¿ç”¨å¼‚æ­¥å¤„ç†æé«˜æ€§èƒ½
- âœ… **è¿æ¥æ± **ï¼šä½¿ç”¨æ•°æ®åº“è¿æ¥æ± 
- âœ… **ç¼“å­˜ç­–ç•¥**ï¼šåˆç†ä½¿ç”¨ç¼“å­˜å‡å°‘æ•°æ®åº“è®¿é—®
- âœ… **åˆ†ç‰‡ç­–ç•¥**ï¼šå¯¹å¤§æ•°æ®é‡è¿›è¡Œåˆ†ç‰‡å¤„ç†

## ğŸ”— ç›¸å…³æ–‡æ¡£

- [å¾®æœåŠ¡æ¶æ„è®¾è®¡æ¨¡å¼](./12.1_å¾®æœåŠ¡æ¶æ„è®¾è®¡æ¨¡å¼.md)
- [é”™è¯¯å¤„ç†ä¸å®¹é”™æœºåˆ¶](./12.2_é”™è¯¯å¤„ç†ä¸å®¹é”™æœºåˆ¶.md)
- [æ•°æ®ä¸€è‡´æ€§ç­–ç•¥](./12.3_æ•°æ®ä¸€è‡´æ€§ç­–ç•¥.md)
- [å½¢å¼åŒ–éªŒè¯TLA+å…¥é—¨](./11_æ€§èƒ½ä¼˜åŒ–ä¸æµ‹è¯•/11.5_å½¢å¼åŒ–éªŒè¯_TLA+_å…¥é—¨.md)
- [æ¶ˆæ¯é˜Ÿåˆ—ä¸äº‹ä»¶é©±åŠ¨](./07_æ¶ˆæ¯é˜Ÿåˆ—ä¸äº‹ä»¶é©±åŠ¨/7.4_äº‹ä»¶é©±åŠ¨æ¶æ„æ¨¡å¼.md)

## ğŸ“ æ›´æ–°æ—¥å¿—

- **2025-01-XX**: åˆå§‹ç‰ˆæœ¬åˆ›å»º
- **2025-01-XX**: æ·»åŠ Rust 1.90æœ€æ–°å®è·µ
- **2025-01-XX**: å®Œå–„å®ç°ç¤ºä¾‹
- **2025-01-XX**: å¢åŠ æ€§èƒ½å¯¹æ¯”åˆ†æ

---

**æ³¨æ„**ï¼šæœ¬æ–‡æ¡£åŸºäºRust 1.90å’Œ2025å¹´æœ€æ–°æŠ€æœ¯æ ˆï¼Œå»ºè®®å®šæœŸæ›´æ–°ä»¥ä¿æŒæ—¶æ•ˆæ€§ã€‚
