# 数据一致性落地合辑：Outbox/Saga/事件回放

> 基于Rust 1.90和2025年最新技术栈的分布式数据一致性完整解决方案

## 📋 概述

本文档提供了分布式系统中数据一致性的完整解决方案，包括Outbox模式、Saga模式、事件回放等核心模式的选择矩阵、实现示例和最佳实践。

## 🎯 一致性模式选择矩阵

| 场景 | 一致性要求 | 性能要求 | 复杂度 | 推荐模式 | 备选方案 |
|------|------------|----------|--------|----------|----------|
| 订单处理 | 强一致性 | 中等 | 中等 | Saga | 2PC |
| 用户注册 | 最终一致性 | 高 | 低 | Outbox | 事件溯源 |
| 库存管理 | 强一致性 | 高 | 高 | Saga + 锁 | 乐观锁 |
| 支付处理 | 强一致性 | 中等 | 高 | Saga | 2PC |
| 日志记录 | 最终一致性 | 高 | 低 | Outbox | 直接写入 |
| 通知发送 | 最终一致性 | 高 | 低 | Outbox | 消息队列 |

## 🏗️ 核心模式详解

### 1. Outbox模式

#### 1.1 模式概述

Outbox模式通过将业务数据和事件数据存储在同一个事务中，确保数据一致性。

```rust
// 数据库表结构
CREATE TABLE orders (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    status VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE outbox_events (
    id UUID PRIMARY KEY,
    aggregate_id UUID NOT NULL,
    event_type VARCHAR(100) NOT NULL,
    event_data JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    processed_at TIMESTAMP,
    status VARCHAR(20) DEFAULT 'pending'
);
```

#### 1.2 Rust实现

```rust
use sqlx::{PgPool, Postgres, Transaction};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize)]
pub struct Order {
    pub id: Uuid,
    pub user_id: Uuid,
    pub amount: f64,
    pub status: String,
    pub created_at: DateTime<Utc>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OutboxEvent {
    pub id: Uuid,
    pub aggregate_id: Uuid,
    pub event_type: String,
    pub event_data: serde_json::Value,
    pub created_at: DateTime<Utc>,
    pub processed_at: Option<DateTime<Utc>>,
    pub status: String,
}

pub struct OrderService {
    pool: PgPool,
}

impl OrderService {
    pub async fn create_order(
        &self,
        user_id: Uuid,
        amount: f64,
    ) -> Result<Order, sqlx::Error> {
        let mut tx = self.pool.begin().await?;
        
        // 1. 创建订单
        let order_id = Uuid::new_v4();
        let order = sqlx::query_as!(
            Order,
            r#"
            INSERT INTO orders (id, user_id, amount, status)
            VALUES ($1, $2, $3, 'pending')
            RETURNING id, user_id, amount, status, created_at
            "#,
            order_id,
            user_id,
            amount
        )
        .fetch_one(&mut *tx)
        .await?;
        
        // 2. 创建Outbox事件
        let event = OrderCreatedEvent {
            order_id,
            user_id,
            amount,
            created_at: Utc::now(),
        };
        
        sqlx::query!(
            r#"
            INSERT INTO outbox_events (id, aggregate_id, event_type, event_data)
            VALUES ($1, $2, $3, $4)
            "#,
            Uuid::new_v4(),
            order_id,
            "OrderCreated",
            serde_json::to_value(&event)?
        )
        .execute(&mut *tx)
        .await?;
        
        // 3. 提交事务
        tx.commit().await?;
        
        Ok(order)
    }
}
```

### 2. Saga模式

#### 2.1 模式概述

Saga模式通过将长事务分解为多个本地事务，每个本地事务都有对应的补偿操作。

```rust
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize)]
pub enum SagaStep {
    ReserveInventory { product_id: Uuid, quantity: i32 },
    ProcessPayment { order_id: Uuid, amount: f64 },
    CreateOrder { user_id: Uuid, items: Vec<OrderItem> },
    SendNotification { user_id: Uuid, message: String },
}

#[derive(Debug, Serialize, Deserialize)]
pub enum CompensatingAction {
    ReleaseInventory { product_id: Uuid, quantity: i32 },
    RefundPayment { order_id: Uuid, amount: f64 },
    CancelOrder { order_id: Uuid },
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OrderItem {
    pub product_id: Uuid,
    pub quantity: i32,
    pub price: f64,
}

pub struct SagaOrchestrator {
    pool: PgPool,
}

impl SagaOrchestrator {
    pub async fn create_order_saga(
        &self,
        user_id: Uuid,
        items: Vec<OrderItem>,
    ) -> Result<Uuid, Box<dyn std::error::Error>> {
        let saga_id = Uuid::new_v4();
        let order_id = Uuid::new_v4();
        
        // 计算总金额
        let total_amount: f64 = items.iter()
            .map(|item| item.price * item.quantity as f64)
            .sum();
        
        // 创建Saga步骤
        let steps = vec![
            SagaStep::ReserveInventory {
                product_id: items[0].product_id,
                quantity: items[0].quantity,
            },
            SagaStep::ProcessPayment {
                order_id,
                amount: total_amount,
            },
            SagaStep::CreateOrder {
                user_id,
                items: items.clone(),
            },
            SagaStep::SendNotification {
                user_id,
                message: format!("Order {} created successfully", order_id),
            },
        ];
        
        // 创建补偿操作
        let compensating_actions = vec![
            CompensatingAction::ReleaseInventory {
                product_id: items[0].product_id,
                quantity: items[0].quantity,
            },
            CompensatingAction::RefundPayment {
                order_id,
                amount: total_amount,
            },
            CompensatingAction::CancelOrder { order_id },
        ];
        
        // 执行Saga
        self.execute_saga(&steps, &compensating_actions).await?;
        
        Ok(saga_id)
    }
    
    async fn execute_saga(
        &self,
        steps: &[SagaStep],
        compensating_actions: &[CompensatingAction],
    ) -> Result<(), Box<dyn std::error::Error>> {
        for (i, step) in steps.iter().enumerate() {
            match self.execute_step(step).await {
                Ok(()) => {
                    // 步骤执行成功，继续下一步
                }
                Err(e) => {
                    eprintln!("Step {} failed: {}", i, e);
                    // 开始补偿
                    self.compensate_saga(compensating_actions, i).await?;
                    return Err(e);
                }
            }
        }
        Ok(())
    }
    
    async fn execute_step(&self, step: &SagaStep) -> Result<(), Box<dyn std::error::Error>> {
        match step {
            SagaStep::ReserveInventory { product_id, quantity } => {
                self.reserve_inventory(*product_id, *quantity).await?;
            }
            SagaStep::ProcessPayment { order_id, amount } => {
                self.process_payment(*order_id, *amount).await?;
            }
            SagaStep::CreateOrder { user_id, items } => {
                self.create_order(*user_id, items.clone()).await?;
            }
            SagaStep::SendNotification { user_id, message } => {
                self.send_notification(*user_id, message.clone()).await?;
            }
        }
        Ok(())
    }
    
    async fn compensate_saga(
        &self,
        compensating_actions: &[CompensatingAction],
        failed_step: usize,
    ) -> Result<(), Box<dyn std::error::Error>> {
        // 从失败步骤的前一步开始补偿
        for i in (0..failed_step).rev() {
            if let Some(compensating_action) = compensating_actions.get(i) {
                match self.execute_compensating_action(compensating_action).await {
                    Ok(()) => {
                        eprintln!("Compensated step {}", i);
                    }
                    Err(e) => {
                        eprintln!("Failed to compensate step {}: {}", i, e);
                        // 记录补偿失败，需要人工干预
                    }
                }
            }
        }
        Ok(())
    }
    
    // 具体的业务方法实现
    async fn reserve_inventory(&self, product_id: Uuid, quantity: i32) -> Result<(), sqlx::Error> {
        sqlx::query!(
            r#"
            UPDATE inventory
            SET reserved_quantity = reserved_quantity + $2
            WHERE product_id = $1 AND available_quantity >= $2
            "#,
            product_id,
            quantity
        )
        .execute(&self.pool)
        .await?;
        Ok(())
    }
    
    async fn process_payment(&self, order_id: Uuid, amount: f64) -> Result<(), sqlx::Error> {
        sqlx::query!(
            r#"
            INSERT INTO payments (id, order_id, amount, status, created_at)
            VALUES ($1, $2, $3, 'completed', NOW())
            "#,
            Uuid::new_v4(),
            order_id,
            amount
        )
        .execute(&self.pool)
        .await?;
        Ok(())
    }
    
    async fn create_order(&self, user_id: Uuid, items: Vec<OrderItem>) -> Result<(), sqlx::Error> {
        let order_id = Uuid::new_v4();
        sqlx::query!(
            r#"
            INSERT INTO orders (id, user_id, status, created_at)
            VALUES ($1, $2, 'created', NOW())
            "#,
            order_id,
            user_id
        )
        .execute(&self.pool)
        .await?;
        
        for item in items {
            sqlx::query!(
                r#"
                INSERT INTO order_items (id, order_id, product_id, quantity, price)
                VALUES ($1, $2, $3, $4, $5)
                "#,
                Uuid::new_v4(),
                order_id,
                item.product_id,
                item.quantity,
                item.price
            )
            .execute(&self.pool)
            .await?;
        }
        Ok(())
    }
    
    async fn send_notification(&self, user_id: Uuid, message: String) -> Result<(), sqlx::Error> {
        // 模拟发送通知
        println!("Sending notification to user {}: {}", user_id, message);
        Ok(())
    }
    
    async fn execute_compensating_action(
        &self,
        action: &CompensatingAction,
    ) -> Result<(), Box<dyn std::error::Error>> {
        match action {
            CompensatingAction::ReleaseInventory { product_id, quantity } => {
                self.release_inventory(*product_id, *quantity).await?;
            }
            CompensatingAction::RefundPayment { order_id, amount } => {
                self.refund_payment(*order_id, *amount).await?;
            }
            CompensatingAction::CancelOrder { order_id } => {
                self.cancel_order(*order_id).await?;
            }
        }
        Ok(())
    }
    
    async fn release_inventory(&self, product_id: Uuid, quantity: i32) -> Result<(), sqlx::Error> {
        sqlx::query!(
            r#"
            UPDATE inventory
            SET reserved_quantity = reserved_quantity - $2
            WHERE product_id = $1
            "#,
            product_id,
            quantity
        )
        .execute(&self.pool)
        .await?;
        Ok(())
    }
    
    async fn refund_payment(&self, order_id: Uuid, amount: f64) -> Result<(), sqlx::Error> {
        sqlx::query!(
            r#"
            UPDATE payments
            SET status = 'refunded', refunded_at = NOW()
            WHERE order_id = $1
            "#,
            order_id
        )
        .execute(&self.pool)
        .await?;
        Ok(())
    }
    
    async fn cancel_order(&self, order_id: Uuid) -> Result<(), sqlx::Error> {
        sqlx::query!(
            r#"
            UPDATE orders
            SET status = 'cancelled', cancelled_at = NOW()
            WHERE id = $1
            "#,
            order_id
        )
        .execute(&self.pool)
        .await?;
        Ok(())
    }
}
```

## 📊 性能对比分析

### 1. 性能指标对比

| 模式 | 延迟 | 吞吐量 | 资源使用 | 复杂度 | 适用场景 |
|------|------|--------|----------|--------|----------|
| Outbox | 低 | 高 | 中等 | 低 | 最终一致性 |
| Saga | 中等 | 中等 | 高 | 高 | 强一致性 |
| 事件回放 | 高 | 低 | 高 | 高 | 审计和恢复 |
| 2PC | 高 | 低 | 中等 | 中等 | 强一致性 |

## 🚀 最佳实践总结

### 1. 模式选择原则

- ✅ **强一致性需求**：选择Saga模式
- ✅ **最终一致性可接受**：选择Outbox模式
- ✅ **审计和恢复需求**：选择事件回放模式
- ✅ **简单场景**：选择Outbox模式
- ✅ **复杂业务流程**：选择Saga模式

### 2. 实现最佳实践

- ✅ **幂等性**：所有操作都要支持幂等性
- ✅ **超时处理**：设置合理的超时时间
- ✅ **重试机制**：实现指数退避重试
- ✅ **监控告警**：监控关键指标和异常
- ✅ **日志记录**：详细记录操作日志

### 3. 性能优化建议

- ✅ **批量处理**：批量处理事件和操作
- ✅ **异步处理**：使用异步处理提高性能
- ✅ **连接池**：使用数据库连接池
- ✅ **缓存策略**：合理使用缓存减少数据库访问
- ✅ **分片策略**：对大数据量进行分片处理

## 🔗 相关文档

- [微服务架构设计模式](./12.1_微服务架构设计模式.md)
- [错误处理与容错机制](./12.2_错误处理与容错机制.md)
- [数据一致性策略](./12.3_数据一致性策略.md)
- [形式化验证TLA+入门](./11_性能优化与测试/11.5_形式化验证_TLA+_入门.md)
- [消息队列与事件驱动](./07_消息队列与事件驱动/7.4_事件驱动架构模式.md)

## 📝 更新日志

- **2025-01-XX**: 初始版本创建
- **2025-01-XX**: 添加Rust 1.90最新实践
- **2025-01-XX**: 完善实现示例
- **2025-01-XX**: 增加性能对比分析

---

**注意**：本文档基于Rust 1.90和2025年最新技术栈，建议定期更新以保持时效性。
