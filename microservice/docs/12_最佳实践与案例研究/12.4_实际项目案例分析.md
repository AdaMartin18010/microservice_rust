# å®é™…é¡¹ç›®æ¡ˆä¾‹åˆ†æ

> åŸºäº Rust 1.90 çš„å¾®æœåŠ¡é¡¹ç›®å®æˆ˜ç²¾é€‰ï¼Œæ¶µç›–ç”µå•†è®¢å•ä¸å®æ—¶æ—¥å¿—ä¸¤ç±»é«˜é¢‘åœºæ™¯

## ğŸ“‹ æ¦‚è¿°

æœ¬ç« èŠ‚ä»¥ä¸¤ä¸ªå…·æœ‰ä»£è¡¨æ€§çš„ç”Ÿäº§çº§æ¡ˆä¾‹ä¸ºè½½ä½“ï¼Œç³»ç»Ÿå±•ç¤ºä»æ¶æ„è®¾è®¡ã€æŠ€æœ¯é€‰å‹ã€æ ¸å¿ƒå®ç°åˆ°è¿ç»´æ²»ç†ä¸å¯è§‚æµ‹æ€§çš„ä¸€ä½“åŒ–è½åœ°è·¯å¾„ã€‚è¯»è€…å¯å°†å…¶ä½œä¸ºæ¨¡æ¿ï¼Œå¿«é€Ÿå¤åˆ¶åˆ°è‡ªæœ‰ä¸šåŠ¡ä¸­ã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

- æŒæ¡ç”µå•†è®¢å•åŸŸçš„ Outbox + Saga ä¸€è‡´æ€§è½åœ°æ–¹æ³•
- å­¦ä¼šåœ¨é«˜ååæ—¥å¿—é‡‡é›†ä¸­å®æ–½æ‰¹é‡ã€å‹ç¼©ã€èƒŒå‹ä¸åˆ†å±‚ç¼“å­˜
- å»ºç«‹ä»¥ RED/USE ä¸ºæ ¸å¿ƒçš„å¯è§‚æµ‹æ€§æŒ‡æ ‡ä½“ç³»ä¸å‘Šè­¦ç­–ç•¥
- å½¢æˆâ€œä»ä»£ç åˆ°è¿ç»´â€çš„ç«¯åˆ°ç«¯å·¥ç¨‹åŒ–è§†è§’

## ğŸ“š å†…å®¹å¤§çº²

- [å®é™…é¡¹ç›®æ¡ˆä¾‹åˆ†æ](#å®é™…é¡¹ç›®æ¡ˆä¾‹åˆ†æ)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [ğŸ“š å†…å®¹å¤§çº²](#-å†…å®¹å¤§çº²)
  - [ğŸ›’ æ¡ˆä¾‹Aï¼šç”µå•†è®¢å•å¾®æœåŠ¡](#-æ¡ˆä¾‹aç”µå•†è®¢å•å¾®æœåŠ¡)
    - [èƒŒæ™¯ä¸ç›®æ ‡](#èƒŒæ™¯ä¸ç›®æ ‡)
    - [æŠ€æœ¯æ ˆä¸é¡¹ç›®éª¨æ¶](#æŠ€æœ¯æ ˆä¸é¡¹ç›®éª¨æ¶)
    - [é¢†åŸŸå»ºæ¨¡ä¸çŠ¶æ€æœºï¼ˆç¤ºä¾‹ï¼‰](#é¢†åŸŸå»ºæ¨¡ä¸çŠ¶æ€æœºç¤ºä¾‹)
    - [ä¸€è‡´æ€§ï¼šOutbox + Saga å®æˆ˜ï¼ˆè¦ç‚¹ï¼‰](#ä¸€è‡´æ€§outbox--saga-å®æˆ˜è¦ç‚¹)
    - [API è®¾è®¡ä¸è·¯ç”±ï¼ˆAxum ç‰‡æ®µï¼‰](#api-è®¾è®¡ä¸è·¯ç”±axum-ç‰‡æ®µ)
    - [æ²»ç†ï¼šé™æµ/ç†”æ–­/ç°åº¦ï¼ˆç­–ç•¥ï¼‰](#æ²»ç†é™æµç†”æ–­ç°åº¦ç­–ç•¥)
    - [å¯è§‚æµ‹æ€§ä¸ SLO](#å¯è§‚æµ‹æ€§ä¸-slo)
  - [ğŸ“ˆ æ¡ˆä¾‹Bï¼šå®æ—¶æ—¥å¿—é‡‡é›†ä¸åˆ†æ](#-æ¡ˆä¾‹bå®æ—¶æ—¥å¿—é‡‡é›†ä¸åˆ†æ)
    - [èƒŒæ™¯ä¸ç›®æ ‡B](#èƒŒæ™¯ä¸ç›®æ ‡b)
    - [æŠ€æœ¯æ ˆä¸é«˜æ€§èƒ½ I/O](#æŠ€æœ¯æ ˆä¸é«˜æ€§èƒ½-io)
    - [æ‰¹é‡/å‹ç¼©/èƒŒå‹ï¼ˆè¦ç‚¹ï¼‰](#æ‰¹é‡å‹ç¼©èƒŒå‹è¦ç‚¹)
    - [ClickHouse å†™å…¥ï¼ˆå»ºè®®ï¼‰](#clickhouse-å†™å…¥å»ºè®®)
    - [ç›‘æ§ä¸å®¹é‡è§„åˆ’](#ç›‘æ§ä¸å®¹é‡è§„åˆ’)
  - [ğŸ§­ ç»éªŒæ€»ç»“ä¸å¯å¤ç”¨æ¸…å•](#-ç»éªŒæ€»ç»“ä¸å¯å¤ç”¨æ¸…å•)

---

## ğŸ›’ æ¡ˆä¾‹Aï¼šç”µå•†è®¢å•å¾®æœåŠ¡

### èƒŒæ™¯ä¸ç›®æ ‡

åœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹å®ç°å¯é çš„ä¸‹å•â†’æ”¯ä»˜â†’åº“å­˜â†’å‘è´§æµç¨‹ï¼Œè¦æ±‚ï¼š

- è®¢å•çŠ¶æ€å¯å›æ”¾ã€å¯å®¡è®¡ï¼›
- è·¨æœåŠ¡ä¸€è‡´æ€§ä¿éšœï¼ˆæœ€ç»ˆä¸€è‡´ï¼‰ï¼›
- æ”¯æ’‘ç°åº¦ä¸å¼¹æ€§æ²»ç†ï¼›
- å®Œæ•´çš„è¿½è¸ªä¸æŒ‡æ ‡å¯è§‚æµ‹æ€§ã€‚

### æŠ€æœ¯æ ˆä¸é¡¹ç›®éª¨æ¶

- Web/APIï¼šAxum
- RPCï¼šTonic (gRPC)
- æ•°æ®åº“ï¼šPostgreSQL + SQLx
- æ¶ˆæ¯ï¼šKafkaï¼ˆäº‹ä»¶æ€»çº¿ï¼‰
- è¿½è¸ªï¼šOpenTelemetry + Jaeger
- æŒ‡æ ‡ï¼šPrometheusï¼ˆRED/USEï¼‰

é¡¹ç›®ç»“æ„å»ºè®®ï¼š

```text
order-service/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ api/                 # HTTP & gRPC æ¥å£
â”‚   â”œâ”€â”€ domain/              # é¢†åŸŸæ¨¡å‹ä¸çŠ¶æ€æœº
â”‚   â”œâ”€â”€ consistency/         # outbox/äº‹ä»¶/äº‹åŠ¡
â”‚   â”œâ”€â”€ saga/                # Saga å®šä¹‰ä¸æ‰§è¡Œå™¨
â”‚   â”œâ”€â”€ governance/          # é™æµ/ç†”æ–­/ç°åº¦
â”‚   â”œâ”€â”€ observability/       # tracing/metrics/healthz
â”‚   â””â”€â”€ infra/               # SQLxã€Kafkaã€é…ç½®
â”œâ”€â”€ migrations/              # æ•°æ®åº“è¿ç§»
â””â”€â”€ Cargo.toml
```

### é¢†åŸŸå»ºæ¨¡ä¸çŠ¶æ€æœºï¼ˆç¤ºä¾‹ï¼‰

```rust
// ç‰‡æ®µï¼šé¢†åŸŸçŠ¶æ€ä¸æ ¡éªŒ
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq)]
pub enum OrderStatus { Pending, Confirmed, Paid, Shipped, Delivered, Cancelled, Refunded }

impl OrderStatus {
    pub fn can_transit_to(&self, next: &OrderStatus) -> bool {
        use OrderStatus::*;
        matches!((self, next),
            (Pending, Confirmed) |
            (Confirmed, Paid) |
            (Paid, Shipped) |
            (Shipped, Delivered) |
            // å…è®¸ä» Pending/Confirmed/Paid è¿›å…¥ Cancelled
            (Pending, Cancelled) | (Confirmed, Cancelled) | (Paid, Cancelled) |
            // æ”¯ä»˜åå…è®¸é€€æ¬¾
            (Paid, Refunded)
        )
    }
}
```

### ä¸€è‡´æ€§ï¼šOutbox + Saga å®æˆ˜ï¼ˆè¦ç‚¹ï¼‰

- åŒä¸€äº‹åŠ¡å†…å†™ä¸šåŠ¡è¡¨ä¸ `outbox_events`ï¼›
- åå°å‡ºç«™å™¨è½®è¯¢ `outbox_events` å‘å¸ƒ Kafkaï¼›
- Saga å°†è®¢å•æ ¡éªŒã€æ‰£æ¬¾ã€é¢„ç•™åº“å­˜ä¸²æˆç¼–æ’æµï¼Œå¤±è´¥å³è¡¥å¿ï¼›
- å¹‚ç­‰é”®ï¼šä»¥ä¸šåŠ¡å”¯ä¸€é”®é˜²æ­¢é‡å¤æ‰§è¡Œï¼›
- è¯»ä¸€è‡´ï¼šæŸ¥è¯¢æ—¶ä¼˜å…ˆæœ¬åœ°å†™åè¯»ç­–ç•¥æˆ–åŸºäºäº‹ä»¶çš„è¯»æ¨¡å‹åˆ·æ–°ã€‚

```rust
// ç‰‡æ®µï¼šOutbox äº‹ä»¶å®šä¹‰ä¸å‡ºç«™å¤„ç†ç¤ºä¾‹
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct OutboxEvent {
    pub id: uuid::Uuid,
    pub aggregate_id: String,
    pub event_type: String,
    pub event_data: serde_json::Value,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub processed: bool,
}

pub struct OutboxStore { pub pool: sqlx::PgPool }

impl OutboxStore {
    pub async fn append(&self, e: &OutboxEvent, tx: &mut sqlx::Transaction<'_, sqlx::Postgres>) -> Result<(), sqlx::Error> {
        sqlx::query(
            "INSERT INTO outbox_events(id,aggregate_id,event_type,event_data,created_at,processed) VALUES($1,$2,$3,$4,$5,$6)"
        )
        .bind(e.id)
        .bind(&e.aggregate_id)
        .bind(&e.event_type)
        .bind(&e.event_data)
        .bind(e.created_at)
        .bind(e.processed)
        .execute(&mut **tx).await?;
        Ok(())
    }

    pub async fn fetch_unprocessed(&self, limit: i64) -> Result<Vec<OutboxEvent>, sqlx::Error> {
        let rows = sqlx::query(
            "SELECT id,aggregate_id,event_type,event_data,created_at,processed FROM outbox_events WHERE processed=false ORDER BY created_at LIMIT $1"
        ).bind(limit).fetch_all(&self.pool).await?;
        Ok(rows.into_iter().map(|r| OutboxEvent{
            id: r.get("id"), aggregate_id: r.get("aggregate_id"), event_type: r.get("event_type"),
            event_data: r.get("event_data"), created_at: r.get("created_at"), processed: r.get("processed")
        }).collect())
    }

    pub async fn mark_processed(&self, id: uuid::Uuid) -> Result<(), sqlx::Error> {
        sqlx::query("UPDATE outbox_events SET processed=true WHERE id=$1").bind(id).execute(&self.pool).await?; Ok(())
    }
}

pub struct EventPublisher { pub kafka: KafkaProducer, pub outbox: OutboxStore }

impl EventPublisher {
    pub async fn pump(&self) -> anyhow::Result<()> {
        for e in self.outbox.fetch_unprocessed(200).await? {
            self.kafka.send("order-events", &e.event_data).await?;
            self.outbox.mark_processed(e.id).await?;
        }
        Ok(())
    }
}
```

### API è®¾è®¡ä¸è·¯ç”±ï¼ˆAxum ç‰‡æ®µï¼‰

```rust
pub fn routes(state: AppState) -> axum::Router {
    use axum::{routing::{get, post}, Router};
    Router::new()
        .route("/orders", post(create_order))
        .route("/orders/:id", get(get_order))
        .with_state(state)
}

// å¤„ç†å™¨ä¸é”™è¯¯æ¨¡å‹éª¨æ¶
#[derive(thiserror::Error, Debug)]
pub enum ApiError {
    #[error("bad request: {0}")] BadRequest(String),
    #[error("not found")] NotFound,
    #[error("internal error")] Internal,
}

impl axum::response::IntoResponse for ApiError {
    fn into_response(self) -> axum::response::Response {
        use axum::{http::StatusCode, Json};
        let (code,msg) = match self {
            ApiError::BadRequest(m) => (StatusCode::BAD_REQUEST, m),
            ApiError::NotFound => (StatusCode::NOT_FOUND, "not found".into()),
            ApiError::Internal => (StatusCode::INTERNAL_SERVER_ERROR, "internal".into()),
        };
        (code, Json(serde_json::json!({"error": msg}))).into_response()
    }
}

pub async fn create_order(
    axum::extract::State(svc): axum::extract::State<OrderService>,
    axum::Json(req): axum::Json<CreateOrderRequest>,
) -> Result<axum::Json<Order>, ApiError> {
    let order = svc.create_order(req).await.map_err(|e| {
        tracing::error!(?e, "create_order failed"); ApiError::Internal
    })?;
    Ok(axum::Json(order))
}

pub async fn get_order(
    axum::extract::State(svc): axum::extract::State<OrderService>,
    axum::extract::Path(id): axum::extract::Path<uuid::Uuid>,
) -> Result<axum::Json<Order>, ApiError> {
    match svc.get_order(id).await.map_err(|_| ApiError::Internal)? {
        Some(o) => Ok(axum::Json(o)),
        None => Err(ApiError::NotFound)
    }
}
```

### æ²»ç†ï¼šé™æµ/ç†”æ–­/ç°åº¦ï¼ˆç­–ç•¥ï¼‰

- å…¥å£é™æµï¼šä»¤ç‰Œæ¡¶åŸºäºç§Ÿæˆ·/ç”¨æˆ·/è·¯å¾„ç»´åº¦ï¼›
- å®¢æˆ·ç«¯ç†”æ–­ï¼šå¯¹æ”¯ä»˜ã€åº“å­˜ç­‰å¤–éƒ¨è°ƒç”¨è®¾ç½®ç†”æ–­+é€€é¿ï¼›
- ç°åº¦ï¼šåŸºäºæ ‡å¤´/ç”¨æˆ·åˆ†ç¾¤/ç™¾åˆ†æ¯”è·¯ç”±ï¼Œæ”¯æŒå¿«é€Ÿå›æ»šã€‚

### å¯è§‚æµ‹æ€§ä¸ SLO

- è¿½è¸ªï¼šä¸‹å•-æ”¯ä»˜-åº“å­˜-å‘è´§é“¾è·¯è´¯é€šï¼›
- RED æŒ‡æ ‡ï¼šè¯·æ±‚é€Ÿç‡(R)ã€é”™è¯¯ç‡(E)ã€å»¶è¿Ÿ(D)ï¼›
- SLO ç¤ºä¾‹ï¼šP99 å»¶è¿Ÿ < 150msï¼Œé”™è¯¯ç‡ < 0.1%ï¼Œå¯ç”¨æ€§ 99.9%ã€‚

---

## ğŸ“ˆ æ¡ˆä¾‹Bï¼šå®æ—¶æ—¥å¿—é‡‡é›†ä¸åˆ†æ

### èƒŒæ™¯ä¸ç›®æ ‡B

é¢å‘ TB çº§æ—¥å¿—é‡çš„å®æ—¶é‡‡é›†ã€ä¼ è¾“ä¸å…¥åº“åˆ†æï¼Œå¼ºè°ƒååã€æˆæœ¬ä¸å¯æ‰©å±•æ€§ï¼š

- å…¥å£æŠ—å‹ï¼šè¾¹ç¼˜èŠ‚ç‚¹èšåˆ/é¢„å¤„ç†ï¼›
- ä¼ è¾“é«˜æ•ˆï¼šå‹ç¼©+æ‰¹é‡+èƒŒå‹ï¼›
- å†·çƒ­åˆ†å±‚ï¼šè¿‘å®æ—¶æŸ¥è¯¢ä¸å†å²å½’æ¡£åˆ†å±‚ã€‚

### æŠ€æœ¯æ ˆä¸é«˜æ€§èƒ½ I/O

- è¾¹ç¼˜å…¥å£ï¼šActix Webï¼ˆå¤šæ ¸åˆ©ç”¨ï¼‰
- æ¶ˆæ¯ä¸­é—´ä»¶ï¼šNATS JetStream / Kafkaï¼ˆäºŒé€‰ä¸€æˆ–å¹¶ç”¨ï¼‰
- å­˜å‚¨ï¼šClickHouseï¼ˆåˆ—å­˜ + MergeTreeï¼‰
- å‹ç¼©ï¼šLZ4/Deflateï¼›æ‰¹é‡åˆ·ç›˜ï¼šå®šæ—¶ + é˜ˆå€¼

### æ‰¹é‡/å‹ç¼©/èƒŒå‹ï¼ˆè¦ç‚¹ï¼‰

- æ‰¹é‡é˜ˆå€¼ï¼šæ¡æ•°é˜ˆå€¼æˆ–æ—¶é—´çª—å£äºŒè€…æ‹©ä¸€å…ˆåˆ°å³åˆ·ï¼›
- å‹ç¼©ï¼šæ‰¹é‡ JSON â†’ LZ4 block å‹ç¼©åå…¥é˜Ÿï¼›
- èƒŒå‹ï¼šé˜Ÿåˆ—æ°´ä½å‘Šè­¦ + é™æµ/ä¸¢å¼ƒç­–ç•¥ï¼ˆå¯é…ç½®ï¼‰ã€‚

```rust
// NATS å‘å¸ƒä¸ ClickHouse æ‰¹é‡å†™å…¥æç®€ç¤ºä¾‹
pub async fn publish_nats(nc: &nats::asynk::Connection, subject: &str, batch: &[serde_json::Value]) -> anyhow::Result<()> {
    let payload = serde_json::to_vec(batch)?;
    let compressed = lz4::block::compress(&payload, None, lz4::block::CompressionMode::DEFAULT)?;
    nc.publish(subject, compressed).await?; Ok(())
}

pub async fn write_clickhouse(pool: &clickhouse_rs::Pool, batch: &[LogEntry]) -> Result<(), clickhouse_rs::errors::Error> {
    let mut handle = pool.get_handle().await?;
    let mut insert = handle.prepare("INSERT INTO logs (id,timestamp,level,message,source,tags) VALUES (?,?,?,?,?,?)").await?;
    for e in batch {
        insert.bind(&e.id).bind(&e.timestamp).bind(&e.level).bind(&e.message).bind(&e.source)
              .bind(&serde_json::to_string(&e.tags).unwrap()).execute().await?;
    }
    Ok(())
}
```

### ClickHouse å†™å…¥ï¼ˆå»ºè®®ï¼‰

- è¡¨è®¾è®¡ï¼šå®½è¡¨ + å¸¸ç”¨æŸ¥è¯¢å­—æ®µå»ºç«‹ç´¢å¼•ï¼›
- æ‰¹å†™ï¼šåˆ©ç”¨ `insert_many`/æ‰¹é‡ pipelineï¼›
- èµ„æºï¼šæ ¹æ®ç£ç›˜ IOPS ä¸ CPU é…é¢è®¾ç½®åˆå¹¶ç­–ç•¥ä¸å¹¶å‘åº¦ã€‚

### ç›‘æ§ä¸å®¹é‡è§„åˆ’

- æŒ‡æ ‡ï¼šå…¥å£ QPSã€æ‰¹é‡å¤§å°ã€å‹ç¼©æ¯”ã€å…¥åº“è€—æ—¶ã€ä¸¢å¼ƒç‡ï¼›
- é¢„æ¡ˆï¼šå­˜å‚¨æ°´ä½ > 80% è§¦å‘å†·çƒ­åˆ†å±‚ä¸å½’æ¡£ï¼›
- å‹æµ‹ï¼šæŒç»­å‹æµ‹æ ¡å‡†æ‰¹é‡ä¸å¹¶å‘å‚æ•°ã€‚

---

## ğŸ§­ ç»éªŒæ€»ç»“ä¸å¯å¤ç”¨æ¸…å•

- ç»Ÿä¸€åŸºçº¿ï¼šé”™è¯¯æ¨¡å‹ã€è¿½è¸ªä¸Šä¸‹æ–‡ã€æŒ‡æ ‡ç»´åº¦ç»Ÿä¸€ï¼›
- ä¸€è‡´æ€§ä¼˜å…ˆçº§ï¼šå…ˆæ˜ç¡®å®šä¹‰ä¸šåŠ¡ä¸€è‡´æ€§ SLAï¼Œå†é€‰æŠ€æœ¯æ–¹æ¡ˆï¼›
- é¢„ç•™å¼€å…³ï¼šç°åº¦/é™æµ/é™çº§çš†éœ€â€œå¼€å…³å³ç”¨ï¼Œå›æ»šå³æ’¤â€ï¼›
- è‡ªåŠ¨åŒ–ï¼šCI/CD + ç­–ç•¥åŒ–å›æ»šï¼Œé…åˆåˆæˆæµé‡åšå›å½’ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¶é—´**: 2025-09-29  
**æ›´æ–°æ—¶é—´**: 2025-09-29
