# æ•°æ®ä¸€è‡´æ€§ç­–ç•¥

> åŸºäºRust 1.90çš„å¾®æœåŠ¡æ•°æ®ä¸€è‡´æ€§ç­–ç•¥å®Œæ•´æŒ‡å—

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£æ·±å…¥æ¢è®¨å¾®æœåŠ¡æ¶æ„ä¸­çš„æ•°æ®ä¸€è‡´æ€§ç­–ç•¥ï¼ŒåŒ…æ‹¬æœ€ç»ˆä¸€è‡´æ€§ã€è·¨æœåŠ¡äº‹åŠ¡ã€è¯»ä¸€è‡´æ€§ã€å¹‚ç­‰æ€§å’ŒSchemaæ¼”è¿›ç­‰å…³é”®æ¦‚å¿µã€‚é€šè¿‡å®é™…ä»£ç ç¤ºä¾‹å’Œæœ€ä½³å®è·µï¼Œå±•ç¤ºå¦‚ä½•åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ä¿è¯æ•°æ®çš„ä¸€è‡´æ€§ã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

- ç†è§£å¾®æœåŠ¡æ¶æ„ä¸­çš„æ•°æ®ä¸€è‡´æ€§æŒ‘æˆ˜
- æŒæ¡å„ç§ä¸€è‡´æ€§ç­–ç•¥çš„å®ç°æ–¹æ³•
- äº†è§£è·¨æœåŠ¡äº‹åŠ¡çš„å¤„ç†æ¨¡å¼
- å­¦ä¹ å¦‚ä½•è®¾è®¡å¹‚ç­‰æ€§å’ŒSchemaæ¼”è¿›ç­–ç•¥

## ğŸ“š å†…å®¹å¤§çº²

- [æ•°æ®ä¸€è‡´æ€§ç­–ç•¥](#æ•°æ®ä¸€è‡´æ€§ç­–ç•¥)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [ğŸ“š å†…å®¹å¤§çº²](#-å†…å®¹å¤§çº²)
  - [ğŸ”„ æœ€ç»ˆä¸€è‡´æ€§](#-æœ€ç»ˆä¸€è‡´æ€§)
    - [Outboxæ¨¡å¼](#outboxæ¨¡å¼)
  - [ğŸ”„ è·¨æœåŠ¡äº‹åŠ¡](#-è·¨æœåŠ¡äº‹åŠ¡)
    - [Sagaæ¨¡å¼](#sagaæ¨¡å¼)
  - [ğŸ“– æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [1. ä¸€è‡´æ€§ç­–ç•¥é€‰æ‹©](#1-ä¸€è‡´æ€§ç­–ç•¥é€‰æ‹©)
    - [2. äº‹åŠ¡è®¾è®¡åŸåˆ™](#2-äº‹åŠ¡è®¾è®¡åŸåˆ™)
    - [3. å¹‚ç­‰æ€§è®¾è®¡](#3-å¹‚ç­‰æ€§è®¾è®¡)
  - [ğŸ”š æ€»ç»“](#-æ€»ç»“)
    - [å…³é”®è¦ç‚¹](#å…³é”®è¦ç‚¹)

## ğŸ”„ æœ€ç»ˆä¸€è‡´æ€§

### Outboxæ¨¡å¼

```rust
// src/outbox.rs
use serde::{Deserialize, Serialize};
use sqlx::{PgPool, Row};
use uuid::Uuid;
use chrono::{DateTime, Utc};

// Outboxäº‹ä»¶
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OutboxEvent {
    pub id: Uuid,
    pub aggregate_id: String,
    pub event_type: String,
    pub event_data: serde_json::Value,
    pub created_at: DateTime<Utc>,
    pub processed: bool,
    pub processed_at: Option<DateTime<Utc>>,
}

// Outboxå­˜å‚¨
pub struct OutboxStore {
    pub pool: PgPool,
}

impl OutboxStore {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
    
    // åœ¨åŒä¸€ä¸ªäº‹åŠ¡ä¸­ä¿å­˜ä¸šåŠ¡æ•°æ®å’Œäº‹ä»¶
    pub async fn save_with_event<T>(
        &self,
        business_data: T,
        event: OutboxEvent,
    ) -> Result<(), sqlx::Error>
    where
        T: Serialize,
    {
        let mut tx = self.pool.begin().await?;
        
        // ä¿å­˜ä¸šåŠ¡æ•°æ®
        // è¿™é‡Œéœ€è¦æ ¹æ®å…·ä½“çš„ä¸šåŠ¡é€»è¾‘æ¥å®ç°
        // ä¾‹å¦‚ï¼šä¿å­˜ç”¨æˆ·æ•°æ®ã€è®¢å•æ•°æ®ç­‰
        
        // ä¿å­˜Outboxäº‹ä»¶
        sqlx::query(
            "INSERT INTO outbox_events (id, aggregate_id, event_type, event_data, created_at, processed) 
             VALUES ($1, $2, $3, $4, $5, $6)"
        )
        .bind(event.id)
        .bind(&event.aggregate_id)
        .bind(&event.event_type)
        .bind(&event.event_data)
        .bind(event.created_at)
        .bind(event.processed)
        .execute(&mut *tx)
        .await?;
        
        tx.commit().await?;
        Ok(())
    }
    
    // è·å–æœªå¤„ç†çš„äº‹ä»¶
    pub async fn get_unprocessed_events(&self, limit: i64) -> Result<Vec<OutboxEvent>, sqlx::Error> {
        let rows = sqlx::query(
            "SELECT id, aggregate_id, event_type, event_data, created_at, processed, processed_at 
             FROM outbox_events 
             WHERE processed = false 
             ORDER BY created_at 
             LIMIT $1"
        )
        .bind(limit)
        .fetch_all(&self.pool)
        .await?;
        
        let events = rows.into_iter().map(|row| OutboxEvent {
            id: row.get("id"),
            aggregate_id: row.get("aggregate_id"),
            event_type: row.get("event_type"),
            event_data: row.get("event_data"),
            created_at: row.get("created_at"),
            processed: row.get("processed"),
            processed_at: row.get("processed_at"),
        }).collect();
        
        Ok(events)
    }
    
    // æ ‡è®°äº‹ä»¶ä¸ºå·²å¤„ç†
    pub async fn mark_as_processed(&self, event_id: Uuid) -> Result<(), sqlx::Error> {
        sqlx::query(
            "UPDATE outbox_events SET processed = true, processed_at = $1 WHERE id = $2"
        )
        .bind(Utc::now())
        .bind(event_id)
        .execute(&self.pool)
        .await?;
        
        Ok(())
    }
}
```

## ğŸ”„ è·¨æœåŠ¡äº‹åŠ¡

### Sagaæ¨¡å¼

```rust
// src/saga.rs
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use uuid::Uuid;

// Sagaæ­¥éª¤
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SagaStep {
    pub id: String,
    pub action: String,
    pub compensation: String,
    pub status: SagaStepStatus,
    pub data: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SagaStepStatus {
    Pending,
    InProgress,
    Completed,
    Failed,
    Compensated,
}

// Sagaæ‰§è¡Œå™¨
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Saga {
    pub id: Uuid,
    pub steps: Vec<SagaStep>,
    pub status: SagaStatus,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SagaStatus {
    Started,
    InProgress,
    Completed,
    Failed,
    Compensating,
    Compensated,
}

// Sagaç®¡ç†å™¨
pub struct SagaManager {
    pub sagas: HashMap<Uuid, Saga>,
}

impl SagaManager {
    pub fn new() -> Self {
        Self {
            sagas: HashMap::new(),
        }
    }
    
    // åˆ›å»ºSaga
    pub fn create_saga(&mut self, steps: Vec<SagaStep>) -> Uuid {
        let saga_id = Uuid::new_v4();
        let saga = Saga {
            id: saga_id,
            steps,
            status: SagaStatus::Started,
            created_at: Utc::now(),
            updated_at: Utc::now(),
        };
        
        self.sagas.insert(saga_id, saga);
        saga_id
    }
    
    // æ‰§è¡ŒSaga
    pub async fn execute_saga(&mut self, saga_id: Uuid) -> Result<(), Box<dyn std::error::Error>> {
        let saga = self.sagas.get_mut(&saga_id)
            .ok_or("Saga not found")?;
        
        saga.status = SagaStatus::InProgress;
        saga.updated_at = Utc::now();
        
        for step in &mut saga.steps {
            step.status = SagaStepStatus::InProgress;
            
            // æ‰§è¡Œæ­¥éª¤
            match self.execute_step(step).await {
                Ok(_) => {
                    step.status = SagaStepStatus::Completed;
                }
                Err(e) => {
                    step.status = SagaStepStatus::Failed;
                    saga.status = SagaStatus::Failed;
                    saga.updated_at = Utc::now();
                    
                    // æ‰§è¡Œè¡¥å¿
                    self.compensate_saga(saga_id).await?;
                    return Err(e);
                }
            }
        }
        
        saga.status = SagaStatus::Completed;
        saga.updated_at = Utc::now();
        Ok(())
    }
    
    // æ‰§è¡Œå•ä¸ªæ­¥éª¤
    async fn execute_step(&self, step: &SagaStep) -> Result<(), Box<dyn std::error::Error>> {
        // æ ¹æ®æ­¥éª¤ç±»å‹æ‰§è¡Œç›¸åº”çš„æ“ä½œ
        match step.action.as_str() {
            "create_user" => {
                self.create_user(&step.data).await?;
            }
            "create_order" => {
                self.create_order(&step.data).await?;
            }
            "reserve_inventory" => {
                self.reserve_inventory(&step.data).await?;
            }
            "process_payment" => {
                self.process_payment(&step.data).await?;
            }
            _ => {
                return Err(format!("Unknown action: {}", step.action).into());
            }
        }
        
        Ok(())
    }
    
    // è¡¥å¿Saga
    async fn compensate_saga(&mut self, saga_id: Uuid) -> Result<(), Box<dyn std::error::Error>> {
        let saga = self.sagas.get_mut(&saga_id)
            .ok_or("Saga not found")?;
        
        saga.status = SagaStatus::Compensating;
        saga.updated_at = Utc::now();
        
        // é€†åºæ‰§è¡Œè¡¥å¿
        for step in saga.steps.iter_mut().rev() {
            if step.status == SagaStepStatus::Completed {
                match self.execute_compensation(step).await {
                    Ok(_) => {
                        step.status = SagaStepStatus::Compensated;
                    }
                    Err(e) => {
                        eprintln!("Compensation failed for step {}: {}", step.id, e);
                        // ç»§ç»­æ‰§è¡Œå…¶ä»–è¡¥å¿
                    }
                }
            }
        }
        
        saga.status = SagaStatus::Compensated;
        saga.updated_at = Utc::now();
        Ok(())
    }
    
    // æ‰§è¡Œè¡¥å¿æ“ä½œ
    async fn execute_compensation(&self, step: &SagaStep) -> Result<(), Box<dyn std::error::Error>> {
        match step.compensation.as_str() {
            "delete_user" => {
                self.delete_user(&step.data).await?;
            }
            "cancel_order" => {
                self.cancel_order(&step.data).await?;
            }
            "release_inventory" => {
                self.release_inventory(&step.data).await?;
            }
            "refund_payment" => {
                self.refund_payment(&step.data).await?;
            }
            _ => {
                return Err(format!("Unknown compensation: {}", step.compensation).into());
            }
        }
        
        Ok(())
    }
    
    // ä¸šåŠ¡æ“ä½œå®ç°
    async fn create_user(&self, data: &serde_json::Value) -> Result<(), Box<dyn std::error::Error>> {
        println!("Creating user: {:?}", data);
        Ok(())
    }
    
    async fn create_order(&self, data: &serde_json::Value) -> Result<(), Box<dyn std::error::Error>> {
        println!("Creating order: {:?}", data);
        Ok(())
    }
    
    async fn reserve_inventory(&self, data: &serde_json::Value) -> Result<(), Box<dyn std::error::Error>> {
        println!("Reserving inventory: {:?}", data);
        Ok(())
    }
    
    async fn process_payment(&self, data: &serde_json::Value) -> Result<(), Box<dyn std::error::Error>> {
        println!("Processing payment: {:?}", data);
        Ok(())
    }
    
    async fn delete_user(&self, data: &serde_json::Value) -> Result<(), Box<dyn std::error::Error>> {
        println!("Deleting user: {:?}", data);
        Ok(())
    }
    
    async fn cancel_order(&self, data: &serde_json::Value) -> Result<(), Box<dyn std::error::Error>> {
        println!("Canceling order: {:?}", data);
        Ok(())
    }
    
    async fn release_inventory(&self, data: &serde_json::Value) -> Result<(), Box<dyn std::error::Error>> {
        println!("Releasing inventory: {:?}", data);
        Ok(())
    }
    
    async fn refund_payment(&self, data: &serde_json::Value) -> Result<(), Box<dyn std::error::Error>> {
        println!("Refunding payment: {:?}", data);
        Ok(())
    }
}
```

## ğŸ“– æœ€ä½³å®è·µ

### 1. ä¸€è‡´æ€§ç­–ç•¥é€‰æ‹©

- **å¼ºä¸€è‡´æ€§**: é€‚ç”¨äºå¯¹æ•°æ®ä¸€è‡´æ€§è¦æ±‚æé«˜çš„åœºæ™¯
- **æœ€ç»ˆä¸€è‡´æ€§**: é€‚ç”¨äºå¤§å¤šæ•°å¾®æœåŠ¡åœºæ™¯ï¼Œé€šè¿‡äº‹ä»¶é©±åŠ¨å®ç°
- **å¼±ä¸€è‡´æ€§**: é€‚ç”¨äºå¯¹æ€§èƒ½è¦æ±‚æé«˜çš„åœºæ™¯

### 2. äº‹åŠ¡è®¾è®¡åŸåˆ™

- **æœ€å°åŒ–äº‹åŠ¡èŒƒå›´**: å‡å°‘äº‹åŠ¡çš„æŒç»­æ—¶é—´å’Œå½±å“èŒƒå›´
- **é¿å…é•¿äº‹åŠ¡**: é•¿äº‹åŠ¡å®¹æ˜“å¯¼è‡´æ­»é”å’Œæ€§èƒ½é—®é¢˜
- **åˆç†ä½¿ç”¨è¡¥å¿**: è®¾è®¡åˆç†çš„è¡¥å¿æœºåˆ¶å¤„ç†å¤±è´¥æƒ…å†µ

### 3. å¹‚ç­‰æ€§è®¾è®¡

- **å¹‚ç­‰é”®**: ä¸ºæ¯ä¸ªæ“ä½œç”Ÿæˆå”¯ä¸€çš„å¹‚ç­‰é”®
- **çŠ¶æ€æ£€æŸ¥**: åœ¨æ‰§è¡Œæ“ä½œå‰æ£€æŸ¥æ“ä½œçŠ¶æ€
- **é‡å¤æ£€æµ‹**: æ£€æµ‹å’Œå¤„ç†é‡å¤çš„è¯·æ±‚

## ğŸ”š æ€»ç»“

æ•°æ®ä¸€è‡´æ€§æ˜¯å¾®æœåŠ¡æ¶æ„ä¸­çš„æ ¸å¿ƒæŒ‘æˆ˜ä¹‹ä¸€ã€‚é€šè¿‡åˆç†é€‰æ‹©ä¸€è‡´æ€§ç­–ç•¥ã€è®¾è®¡å®Œå–„çš„äº‹åŠ¡å¤„ç†æœºåˆ¶å’Œå®ç°å¯é çš„å¹‚ç­‰æ€§ï¼Œå¯ä»¥æ„å»ºå‡ºé«˜å¯ç”¨ã€é«˜ä¸€è‡´æ€§çš„å¾®æœåŠ¡ç³»ç»Ÿã€‚

### å…³é”®è¦ç‚¹

- **ç­–ç•¥é€‰æ‹©**: æ ¹æ®ä¸šåŠ¡éœ€æ±‚é€‰æ‹©åˆé€‚çš„ä¸€è‡´æ€§ç­–ç•¥
- **äº‹ä»¶é©±åŠ¨**: ä½¿ç”¨äº‹ä»¶é©±åŠ¨æ¶æ„å®ç°æœ€ç»ˆä¸€è‡´æ€§
- **äº‹åŠ¡ç®¡ç†**: åˆç†è®¾è®¡è·¨æœåŠ¡äº‹åŠ¡å¤„ç†æœºåˆ¶
- **å¹‚ç­‰æ€§**: ç¡®ä¿æ“ä½œçš„å¹‚ç­‰æ€§ï¼Œé¿å…é‡å¤æ‰§è¡Œ

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¶é—´**: 2025-09-27  
**æ›´æ–°æ—¶é—´**: 2025-09-27
