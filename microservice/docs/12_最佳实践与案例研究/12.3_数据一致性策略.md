# 数据一致性策略

> 基于Rust 1.90的微服务数据一致性策略完整指南

## 📋 概述

本文档深入探讨微服务架构中的数据一致性策略，包括最终一致性、跨服务事务、读一致性、幂等性和Schema演进等关键概念。通过实际代码示例和最佳实践，展示如何在分布式系统中保证数据的一致性。

## 🎯 学习目标

- 理解微服务架构中的数据一致性挑战
- 掌握各种一致性策略的实现方法
- 了解跨服务事务的处理模式
- 学习如何设计幂等性和Schema演进策略

## 📚 内容大纲

- [数据一致性策略](#数据一致性策略)
  - [📋 概述](#-概述)
  - [🎯 学习目标](#-学习目标)
  - [📚 内容大纲](#-内容大纲)
  - [🔄 最终一致性](#-最终一致性)
    - [Outbox模式](#outbox模式)
  - [🔄 跨服务事务](#-跨服务事务)
    - [Saga模式](#saga模式)
  - [📖 最佳实践](#-最佳实践)
    - [1. 一致性策略选择](#1-一致性策略选择)
    - [2. 事务设计原则](#2-事务设计原则)
    - [3. 幂等性设计](#3-幂等性设计)
  - [🔚 总结](#-总结)
    - [关键要点](#关键要点)

## 🔄 最终一致性

### Outbox模式

```rust
// src/outbox.rs
use serde::{Deserialize, Serialize};
use sqlx::{PgPool, Row};
use uuid::Uuid;
use chrono::{DateTime, Utc};

// Outbox事件
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OutboxEvent {
    pub id: Uuid,
    pub aggregate_id: String,
    pub event_type: String,
    pub event_data: serde_json::Value,
    pub created_at: DateTime<Utc>,
    pub processed: bool,
    pub processed_at: Option<DateTime<Utc>>,
}

// Outbox存储
pub struct OutboxStore {
    pub pool: PgPool,
}

impl OutboxStore {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
    
    // 在同一个事务中保存业务数据和事件
    pub async fn save_with_event<T>(
        &self,
        business_data: T,
        event: OutboxEvent,
    ) -> Result<(), sqlx::Error>
    where
        T: Serialize,
    {
        let mut tx = self.pool.begin().await?;
        
        // 保存业务数据
        // 这里需要根据具体的业务逻辑来实现
        // 例如：保存用户数据、订单数据等
        
        // 保存Outbox事件
        sqlx::query(
            "INSERT INTO outbox_events (id, aggregate_id, event_type, event_data, created_at, processed) 
             VALUES ($1, $2, $3, $4, $5, $6)"
        )
        .bind(event.id)
        .bind(&event.aggregate_id)
        .bind(&event.event_type)
        .bind(&event.event_data)
        .bind(event.created_at)
        .bind(event.processed)
        .execute(&mut *tx)
        .await?;
        
        tx.commit().await?;
        Ok(())
    }
    
    // 获取未处理的事件
    pub async fn get_unprocessed_events(&self, limit: i64) -> Result<Vec<OutboxEvent>, sqlx::Error> {
        let rows = sqlx::query(
            "SELECT id, aggregate_id, event_type, event_data, created_at, processed, processed_at 
             FROM outbox_events 
             WHERE processed = false 
             ORDER BY created_at 
             LIMIT $1"
        )
        .bind(limit)
        .fetch_all(&self.pool)
        .await?;
        
        let events = rows.into_iter().map(|row| OutboxEvent {
            id: row.get("id"),
            aggregate_id: row.get("aggregate_id"),
            event_type: row.get("event_type"),
            event_data: row.get("event_data"),
            created_at: row.get("created_at"),
            processed: row.get("processed"),
            processed_at: row.get("processed_at"),
        }).collect();
        
        Ok(events)
    }
    
    // 标记事件为已处理
    pub async fn mark_as_processed(&self, event_id: Uuid) -> Result<(), sqlx::Error> {
        sqlx::query(
            "UPDATE outbox_events SET processed = true, processed_at = $1 WHERE id = $2"
        )
        .bind(Utc::now())
        .bind(event_id)
        .execute(&self.pool)
        .await?;
        
        Ok(())
    }
}
```

## 🔄 跨服务事务

### Saga模式

```rust
// src/saga.rs
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use uuid::Uuid;

// Saga步骤
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SagaStep {
    pub id: String,
    pub action: String,
    pub compensation: String,
    pub status: SagaStepStatus,
    pub data: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SagaStepStatus {
    Pending,
    InProgress,
    Completed,
    Failed,
    Compensated,
}

// Saga执行器
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Saga {
    pub id: Uuid,
    pub steps: Vec<SagaStep>,
    pub status: SagaStatus,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SagaStatus {
    Started,
    InProgress,
    Completed,
    Failed,
    Compensating,
    Compensated,
}

// Saga管理器
pub struct SagaManager {
    pub sagas: HashMap<Uuid, Saga>,
}

impl SagaManager {
    pub fn new() -> Self {
        Self {
            sagas: HashMap::new(),
        }
    }
    
    // 创建Saga
    pub fn create_saga(&mut self, steps: Vec<SagaStep>) -> Uuid {
        let saga_id = Uuid::new_v4();
        let saga = Saga {
            id: saga_id,
            steps,
            status: SagaStatus::Started,
            created_at: Utc::now(),
            updated_at: Utc::now(),
        };
        
        self.sagas.insert(saga_id, saga);
        saga_id
    }
    
    // 执行Saga
    pub async fn execute_saga(&mut self, saga_id: Uuid) -> Result<(), Box<dyn std::error::Error>> {
        let saga = self.sagas.get_mut(&saga_id)
            .ok_or("Saga not found")?;
        
        saga.status = SagaStatus::InProgress;
        saga.updated_at = Utc::now();
        
        for step in &mut saga.steps {
            step.status = SagaStepStatus::InProgress;
            
            // 执行步骤
            match self.execute_step(step).await {
                Ok(_) => {
                    step.status = SagaStepStatus::Completed;
                }
                Err(e) => {
                    step.status = SagaStepStatus::Failed;
                    saga.status = SagaStatus::Failed;
                    saga.updated_at = Utc::now();
                    
                    // 执行补偿
                    self.compensate_saga(saga_id).await?;
                    return Err(e);
                }
            }
        }
        
        saga.status = SagaStatus::Completed;
        saga.updated_at = Utc::now();
        Ok(())
    }
    
    // 执行单个步骤
    async fn execute_step(&self, step: &SagaStep) -> Result<(), Box<dyn std::error::Error>> {
        // 根据步骤类型执行相应的操作
        match step.action.as_str() {
            "create_user" => {
                self.create_user(&step.data).await?;
            }
            "create_order" => {
                self.create_order(&step.data).await?;
            }
            "reserve_inventory" => {
                self.reserve_inventory(&step.data).await?;
            }
            "process_payment" => {
                self.process_payment(&step.data).await?;
            }
            _ => {
                return Err(format!("Unknown action: {}", step.action).into());
            }
        }
        
        Ok(())
    }
    
    // 补偿Saga
    async fn compensate_saga(&mut self, saga_id: Uuid) -> Result<(), Box<dyn std::error::Error>> {
        let saga = self.sagas.get_mut(&saga_id)
            .ok_or("Saga not found")?;
        
        saga.status = SagaStatus::Compensating;
        saga.updated_at = Utc::now();
        
        // 逆序执行补偿
        for step in saga.steps.iter_mut().rev() {
            if step.status == SagaStepStatus::Completed {
                match self.execute_compensation(step).await {
                    Ok(_) => {
                        step.status = SagaStepStatus::Compensated;
                    }
                    Err(e) => {
                        eprintln!("Compensation failed for step {}: {}", step.id, e);
                        // 继续执行其他补偿
                    }
                }
            }
        }
        
        saga.status = SagaStatus::Compensated;
        saga.updated_at = Utc::now();
        Ok(())
    }
    
    // 执行补偿操作
    async fn execute_compensation(&self, step: &SagaStep) -> Result<(), Box<dyn std::error::Error>> {
        match step.compensation.as_str() {
            "delete_user" => {
                self.delete_user(&step.data).await?;
            }
            "cancel_order" => {
                self.cancel_order(&step.data).await?;
            }
            "release_inventory" => {
                self.release_inventory(&step.data).await?;
            }
            "refund_payment" => {
                self.refund_payment(&step.data).await?;
            }
            _ => {
                return Err(format!("Unknown compensation: {}", step.compensation).into());
            }
        }
        
        Ok(())
    }
    
    // 业务操作实现
    async fn create_user(&self, data: &serde_json::Value) -> Result<(), Box<dyn std::error::Error>> {
        println!("Creating user: {:?}", data);
        Ok(())
    }
    
    async fn create_order(&self, data: &serde_json::Value) -> Result<(), Box<dyn std::error::Error>> {
        println!("Creating order: {:?}", data);
        Ok(())
    }
    
    async fn reserve_inventory(&self, data: &serde_json::Value) -> Result<(), Box<dyn std::error::Error>> {
        println!("Reserving inventory: {:?}", data);
        Ok(())
    }
    
    async fn process_payment(&self, data: &serde_json::Value) -> Result<(), Box<dyn std::error::Error>> {
        println!("Processing payment: {:?}", data);
        Ok(())
    }
    
    async fn delete_user(&self, data: &serde_json::Value) -> Result<(), Box<dyn std::error::Error>> {
        println!("Deleting user: {:?}", data);
        Ok(())
    }
    
    async fn cancel_order(&self, data: &serde_json::Value) -> Result<(), Box<dyn std::error::Error>> {
        println!("Canceling order: {:?}", data);
        Ok(())
    }
    
    async fn release_inventory(&self, data: &serde_json::Value) -> Result<(), Box<dyn std::error::Error>> {
        println!("Releasing inventory: {:?}", data);
        Ok(())
    }
    
    async fn refund_payment(&self, data: &serde_json::Value) -> Result<(), Box<dyn std::error::Error>> {
        println!("Refunding payment: {:?}", data);
        Ok(())
    }
}
```

## 📖 最佳实践

### 1. 一致性策略选择

- **强一致性**: 适用于对数据一致性要求极高的场景
- **最终一致性**: 适用于大多数微服务场景，通过事件驱动实现
- **弱一致性**: 适用于对性能要求极高的场景

### 2. 事务设计原则

- **最小化事务范围**: 减少事务的持续时间和影响范围
- **避免长事务**: 长事务容易导致死锁和性能问题
- **合理使用补偿**: 设计合理的补偿机制处理失败情况

### 3. 幂等性设计

- **幂等键**: 为每个操作生成唯一的幂等键
- **状态检查**: 在执行操作前检查操作状态
- **重复检测**: 检测和处理重复的请求

## 🔚 总结

数据一致性是微服务架构中的核心挑战之一。通过合理选择一致性策略、设计完善的事务处理机制和实现可靠的幂等性，可以构建出高可用、高一致性的微服务系统。

### 关键要点

- **策略选择**: 根据业务需求选择合适的一致性策略
- **事件驱动**: 使用事件驱动架构实现最终一致性
- **事务管理**: 合理设计跨服务事务处理机制
- **幂等性**: 确保操作的幂等性，避免重复执行

---

**文档版本**: v1.0  
**创建时间**: 2025-09-27  
**更新时间**: 2025-09-27
