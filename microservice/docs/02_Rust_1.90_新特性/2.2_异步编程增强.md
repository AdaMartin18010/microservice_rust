# 2.2 异步编程增强（Rust 1.90）

## 📋 目录

- [2.2 异步编程增强（Rust 1.90）](#22-异步编程增强rust-190)
  - [📋 目录](#-目录)
  - [2.2.1 稳定异步 trait 与对象安全](#221-稳定异步-trait-与对象安全)
  - [2.2.2 GAT 驱动的异步迭代器](#222-gat-驱动的异步迭代器)
  - [2.2.3 TAIT 替代策略](#223-tait-替代策略)
  - [2.2.4 可靠性模式（异步）](#224-可靠性模式异步)
  - [2.2.5 与 Tokio/axum/tonic 的协同](#225-与-tokioaxumtonic-的协同)
  - [2.2.6 工程化建议](#226-工程化建议)
  - [2.2.7 与架构蓝图对齐](#227-与架构蓝图对齐)

本章聚焦 Rust 1.90 在异步编程生态的关键增强，并结合本项目 `microservice/src/rust_190_features.rs` 的实现给出可复用范式：稳定异步 trait 用法、GAT 驱动的异步迭代器、基于 `Pin<Box<dyn Future>>` 的 TAIT 替代策略、可靠性模式（重试/熔断/负载均衡）的异步实现建议。

## 2.2.1 稳定异步 trait 与对象安全

- 在 1.90 生态中，使用 `async-trait` 宏为 trait 方法提供 `async fn` 语义，同时确保 `dyn Trait` 对象可用。
- 典型接口：`AsyncService`，包含 `process_request/health_check/get_service_info/shutdown` 等异步方法，支持 `Arc<dyn AsyncService + Send + Sync>` 注册与发现。

关键片段（简化示意）：

```rust
#[async_trait]
pub trait AsyncService {
    async fn process_request(&self, req: ServiceRequest) -> Result<ServiceResponse>;
    async fn health_check(&self) -> Result<HealthStatus>;
}
```

实践要点：

- 使用 `anyhow::Result` 或自定义错误枚举以统一错误边界。
- 面向接口编程：通过注册中心在运行时调度 `Arc<dyn AsyncService>`，实现解耦。

## 2.2.2 GAT 驱动的异步迭代器

借助 GAT（泛型关联类型）表达“与借用同生命周期的返回类型”，实现零拷贝异步遍历的接口设计：

```rust
pub trait AsyncIterator {
    type Item<'a> where Self: 'a;
    type Future<'a>: Future<Output = Option<Self::Item<'a>>> where Self: 'a;
    fn next<'a>(&'a mut self) -> Self::Future<'a>;
}
```

实践要点：

- 对外提供 `map/filter` 组合器形成可读的异步管道。
- 在高吞吐微服务中用于批量拉取、流式聚合、日志/指标消费等场景。

## 2.2.3 TAIT 替代策略

在 stable 环境中，使用 `Pin<Box<dyn Future<Output=T> + Send>>` 作为 TAIT 的兼容替代：

```rust
pub type ServiceResult<T> = Pin<Box<dyn Future<Output = Result<T, ServiceError>> + Send>>;
```

实践要点：

- 将复杂的 Future 类型隐藏在类型别名后，减少签名复杂度。
- 和 `RetryPolicy`、`CircuitBreaker` 等可靠性组件组合以统一返回类型。

## 2.2.4 可靠性模式（异步）

- 重试：指数退避、最大重试次数、抖动（jitter）。
- 熔断：`Closed/HalfOpen/Open` 状态机与超时窗口。
- 负载均衡：`RoundRobin/LeastConnections/Random/ConsistentHash` 策略。

建议：

- 将策略参数化，支持按服务与端点维度覆盖。
- 指标打点（成功/失败/延迟分布）与追踪埋点贯穿执行路径。

## 2.2.5 与 Tokio/axum/tonic 的协同

- Tokio：使用多 worker runtime，区分 CPU 密集型与 IO 任务（`spawn_blocking`）。
- axum：将 `AsyncService` 适配为 handler 层服务编排；统一错误转换为 `IntoResponse`。
- tonic：在 gRPC Service 实现中直接复用 `AsyncService` 能力，减少重复逻辑。

## 2.2.6 工程化建议

- 明确 `Send + Sync` 边界；在共享状态上优先使用 `Arc<RwLock<...>>` 或无锁结构。
- 在 trait 边界定义清晰的数据模型（请求/响应/错误/健康），以便跨传输协议重用。
- 以特性标志（feature flags）切分实现（HTTP/gRPC/消息消费）。

## 2.2.7 与架构蓝图对齐

- 14.1 互联网 API：异步提取器 + 背压/限流中间件；零拷贝 Bytes。
- 14.2 企业内部 RPC：`AsyncService` 复用到 gRPC/Volo 层，减少重复实现。
- 14.3 事件驱动：GAT 异步流消费批处理；超时/重试/抖动策略。
- 14.4 边缘高吞吐：`spawn_blocking` 隔离 CPU 密集；连接池调优。
- 14.5/14.6：与 Mesh/多租户的策略注入（中间件特性开关）。
