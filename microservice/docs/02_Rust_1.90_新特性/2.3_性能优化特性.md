# 2.3 æ€§èƒ½ä¼˜åŒ–ç‰¹æ€§ï¼ˆRust 1.90ï¼‰

## ğŸ“‹ ç›®å½•

- [2.3 æ€§èƒ½ä¼˜åŒ–ç‰¹æ€§ï¼ˆRust 1.90ï¼‰](#23-æ€§èƒ½ä¼˜åŒ–ç‰¹æ€§rust-190)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [2.3.1 ç¼–è¯‘ä¸äº§ç‰©](#231-ç¼–è¯‘ä¸äº§ç‰©)
  - [2.3.2 å†…å­˜ä¸æ•°æ®æ¨¡å‹](#232-å†…å­˜ä¸æ•°æ®æ¨¡å‹)
  - [2.3.3 å¹¶å‘ä¸è°ƒåº¦](#233-å¹¶å‘ä¸è°ƒåº¦)
  - [2.3.4 ç½‘ç»œ IO](#234-ç½‘ç»œ-io)
  - [2.3.5 åºåˆ—åŒ–/ååºåˆ—åŒ–](#235-åºåˆ—åŒ–ååºåˆ—åŒ–)
  - [2.3.6 åŸºå‡†ä¸å‰–æ](#236-åŸºå‡†ä¸å‰–æ)
  - [2.3.7 ä¸æœ¬ä»“ç¤ºä¾‹çš„ç»“åˆ](#237-ä¸æœ¬ä»“ç¤ºä¾‹çš„ç»“åˆ)
  - [2.3.8 ä¸è“å›¾çš„æ€§èƒ½å¯¹é½](#238-ä¸è“å›¾çš„æ€§èƒ½å¯¹é½)
  - [2.3.9 ç½‘ç»œä¸ hyper è°ƒä¼˜ï¼ˆç‰‡æ®µï¼‰](#239-ç½‘ç»œä¸-hyper-è°ƒä¼˜ç‰‡æ®µ)
  - [2.3.10 JSON æ€§èƒ½ï¼šserde\_json vs simd-jsonï¼ˆç‰‡æ®µï¼‰](#2310-json-æ€§èƒ½serde_json-vs-simd-jsonç‰‡æ®µ)
  - [2.3.11 å¾®åŸºå‡†ï¼šcriterion æ¨¡æ¿](#2311-å¾®åŸºå‡†criterion-æ¨¡æ¿)
  - [2.3.12 å¼‚æ­¥å¯è§‚æµ‹ï¼štokio-console](#2312-å¼‚æ­¥å¯è§‚æµ‹tokio-console)
  - [2.3.13 ç”Ÿäº§å‰–æï¼špprof ç«ç„°å›¾](#2313-ç”Ÿäº§å‰–æpprof-ç«ç„°å›¾)
  - [2.3.14 å‹æµ‹æ¨¡æ¿ï¼šwrk/hey/k6/ghz](#2314-å‹æµ‹æ¨¡æ¿wrkheyk6ghz)

æœ¬ç« ä»ç¼–è¯‘äº§ç‰©ã€å†…å­˜å¸ƒå±€ã€å¹¶å‘è°ƒåº¦ã€ç½‘ç»œ IOã€åºåˆ—åŒ–/ååºåˆ—åŒ–ã€åŸºå‡†æµ‹è¯•å…­ä¸ªç»´åº¦æ¢³ç† Rust 1.90 ç”Ÿæ€åœ¨å¾®æœåŠ¡çš„æ€§èƒ½ç­–ç•¥ã€‚

## 2.3.1 ç¼–è¯‘ä¸äº§ç‰©

- LTO/ThinLTOã€`codegen-units=1`ã€`opt-level=z/s`ï¼ˆå‡½æ•°ä½“å°/å†·è·¯å¾„ï¼‰ä¸ `opt-level=3`ï¼ˆçƒ­è·¯å¾„äºŒè¿›åˆ¶ï¼‰åˆ†æƒ…æ™¯é…ç½®ã€‚
- `panic = 'abort'` é€‚ç”¨äº sidecar/å·¥å…·å‹è¿›ç¨‹ï¼›æœåŠ¡ä¸»è¿›ç¨‹ä¿æŒ `unwind` ä¾¿äºé”™è¯¯è¾¹ç•Œã€‚

ç¤ºä¾‹ `Cargo.toml` ç‰‡æ®µï¼š

```toml
[profile.release]
codegen-units = 1
lto = "thin"
opt-level = 3
panic = "unwind"
strip = true
```

## 2.3.2 å†…å­˜ä¸æ•°æ®æ¨¡å‹

- ä½¿ç”¨ `SmallVec`, `bytes::Bytes`, `ahash` ä¼˜åŒ–å°å®¹å™¨ä¸å“ˆå¸Œè¡¨çƒ­ç‚¹ã€‚
- é¿å…ä¸å¿…è¦çš„ `clone`ï¼›åˆ©ç”¨ `Cow`ã€`Arc<str>` é™ä½æ‹·è´æˆæœ¬ã€‚
- ç´§å‡‘ç»“æ„ä½“å¸ƒå±€ï¼Œå…³æ³¨å¯¹é½ä¸å¡«å……ï¼›ä¸ºçƒ­è·¯å¾„å­—æ®µé å‰å¸ƒå±€ï¼ˆcache localityï¼‰ã€‚

## 2.3.3 å¹¶å‘ä¸è°ƒåº¦

- åŒºåˆ† CPU å¯†é›†ï¼ˆ`spawn_blocking` æˆ– rayonï¼‰ä¸ IO å¯†é›†ï¼ˆTokioï¼‰ä»»åŠ¡æ± ã€‚
- èƒŒå‹ï¼šé™æµä¸­é—´ä»¶ï¼ˆå¹¶å‘æ•°ã€ä»¤ç‰Œæ¡¶ï¼‰ã€è¶…æ—¶ã€é˜Ÿåˆ—é•¿åº¦ä¸ä¸¢å¼ƒç­–ç•¥ã€‚
- é›¶æ‹·è´ï¼š`hyper`/`axum` ç»“åˆ `Bytes` ä¸ `http-body` ç‰¹æ€§ã€‚

## 2.3.4 ç½‘ç»œ IO

- HTTP/1.1 ä¸ HTTP/2 å¤ç”¨ï¼›gRPCï¼ˆHTTP/2ï¼‰åœ¨æµå¼ä¸ä½å»¶è¿Ÿåœºæ™¯æ›´ä¼˜ã€‚
- è¿æ¥æ± ï¼šé‡ç”¨ä¸ä¸Šé™ï¼›DNS è§£æç¼“å­˜ï¼›TLS ä¼šè¯å¤ç”¨ã€‚
- Keep-Aliveã€`tcp_nodelay`ã€æ‹¥å¡æ§åˆ¶å‚æ•°æŒ‰ç¯å¢ƒè°ƒä¼˜ã€‚

## 2.3.5 åºåˆ—åŒ–/ååºåˆ—åŒ–

- `serde_json`ï¼ˆé€šç”¨ï¼‰ã€`simd-json`ï¼ˆx86 SIMD åŠ é€Ÿï¼‰ã€`rmp-serde`ï¼ˆäºŒè¿›åˆ¶ï¼‰ã€`bincode`ï¼ˆå†…éƒ¨ RPCï¼‰ã€‚
- å®šä¹‰ç¨³å®šçš„ API æ¨¡å‹ï¼›å¯¹å¤–ä¿å®ˆï¼Œå¯¹å†…å¯ç”¨æ›´è‡´å¯†æ ¼å¼ã€‚

## 2.3.6 åŸºå‡†ä¸å‰–æ

- ä½¿ç”¨ `criterion` å¾®åŸºå‡†ï¼›`tokio-console` è§‚æµ‹å¼‚æ­¥ä»»åŠ¡ï¼›`pprof` ç«ç„°å›¾ã€‚
- æ ‡å‡†åŒ–ç«¯åˆ°ç«¯å‹æµ‹ï¼ˆwrk/hey/ghz/k6ï¼‰å¹¶çº³å…¥ CI é˜ˆå€¼ã€‚

## 2.3.7 ä¸æœ¬ä»“ç¤ºä¾‹çš„ç»“åˆ

- ç»“åˆ `ServiceMonitor` ç»Ÿä¸€è®°å½•æˆåŠŸç‡ä¸ P50/P95/P99 å»¶è¿Ÿï¼ˆå¯æ‰©å±•ç›´æ–¹å›¾ï¼‰ã€‚
- å°†è´Ÿè½½å‡è¡¡ç­–ç•¥å‚æ•°åŒ–ï¼Œé€šè¿‡é…ç½®ä¸­å¿ƒçƒ­æ›´æ–°ã€‚
- åœ¨ retry/circuitbreaker çš„çƒ­è·¯å¾„ä¸Šé¿å…åŠ¨æ€åˆ†é…ï¼Œé‡ç”¨ç¼“å†²åŒºã€‚

## 2.3.8 ä¸è“å›¾çš„æ€§èƒ½å¯¹é½

- 14.1ï¼šHTTP å±‚é›¶æ‹·è´ã€è¿æ¥æ± ã€simd-json é€‰æ‹©ï¼›N+1 æŸ¥è¯¢æ¶ˆé™¤ã€‚
- 14.2ï¼šgRPC/HTTP2 å¤šè·¯å¤ç”¨ä¸è¿æ¥å¤ç”¨ï¼›DNS ç¼“å­˜ä¸ keepaliveã€‚
- 14.3ï¼šKafka æ‰¹æ¬¡/å‹ç¼©ï¼›æ¶ˆè´¹è€…å¹¶å‘ä¸å†å‡è¡¡ç›‘æ§ï¼›pprof ç«ç„°å›¾ã€‚
- 14.4ï¼šActix/axum çš„ Bytes + æ‰¹å¤„ç†ï¼›ç½‘ç»œå‚æ•°ä¸é™æµç­–ç•¥è”åŠ¨ã€‚
- 14.5/14.6ï¼šMesh ä¸‹å‡å°‘é‡å¤é‡è¯•ï¼›è·¨åŒºåŸŸå»¶è¿Ÿé¢„ç®—ä¸è¶…æ—¶åˆ†è§£ã€‚

## 2.3.9 ç½‘ç»œä¸ hyper è°ƒä¼˜ï¼ˆç‰‡æ®µï¼‰

```rust
use axum::{Router, routing::get};
use hyper::server::conn::http1;
use hyper_util::rt::TokioIo;
use tokio::net::TcpListener;
use std::time::Duration;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let app = Router::new().route("/health", get(|| async { "OK" }));

    let listener = TcpListener::bind("0.0.0.0:3000").await?;
    loop {
        let (stream, _) = listener.accept().await?;
        stream.set_nodelay(true)?; // tcp_nodelay
        stream.set_keepalive(Some(Duration::from_secs(60)))?; // keepalive
        let io = TokioIo::new(stream);
        let svc = app.clone().into_make_service_with_connect_info::<std::net::SocketAddr>();
        tokio::spawn(async move {
            if let Err(err) = http1::Builder::new().preserve_header_case(true).serve_connection(io, svc).await {
                eprintln!("server error: {err}");
            }
        });
    }
}
```

- è¦ç‚¹ï¼š`set_nodelay/keepalive`ã€è¿æ¥ä¸Šé™ã€HTTP/2 æ—¶å…³æ³¨å¤šè·¯å¤ç”¨ä¸çª—å£å¤§å°ã€‚

## 2.3.10 JSON æ€§èƒ½ï¼šserde_json vs simd-jsonï¼ˆç‰‡æ®µï¼‰

```toml
# Cargo.toml
[dependencies]
serde = { version = "1", features = ["derive"] }
serde_json = "1"
simd-json = { version = "0.13", features = ["serde_impl"] }
```

```rust
#[cfg(all(target_arch = "x86_64", feature = "simd"))]
use simd_json as json;
#[cfg(not(all(target_arch = "x86_64", feature = "simd")))]
use serde_json as json;

#[derive(serde::Deserialize, serde::Serialize)]
struct Payload { id: u64, name: String, data: Vec<u8> }

fn parse(buf: &mut [u8]) -> anyhow::Result<Payload> {
    // simd-json éœ€è¦å¯å˜åˆ‡ç‰‡ï¼Œä»¥å°±åœ°è§£æ
    Ok(json::from_slice(buf)?)
}
```

- å»ºè®®ï¼šå¯¹å¤– API ç”¨ serde_json ä¿å®ˆï¼›å†…éƒ¨çƒ­è·¯å¾„å¯é€‰æ‹© simd-jsonï¼ˆå—ç›®æ ‡å¹³å°é™åˆ¶ï¼‰ã€‚

## 2.3.11 å¾®åŸºå‡†ï¼šcriterion æ¨¡æ¿

```toml
# Cargo.toml
[dev-dependencies]
criterion = { version = "0.5", features = ["html_reports"] }

[[bench]]
name = "comprehensive_benchmark"
harness = false
```

```rust
// benches/comprehensive_benchmark.rs
use criterion::{criterion_group, criterion_main, Criterion, black_box};

fn bench_json(c: &mut Criterion) {
    c.bench_function("serde_json_parse", |b| {
        let input = br#"{\"id\":1,\"name\":\"a\",\"data\":[1,2,3]}"#.to_vec();
        b.iter(|| {
            let mut buf = input.clone();
            let v: serde_json::Value = serde_json::from_slice(&buf).unwrap();
            black_box(v);
        })
    });
}

criterion_group!(benches, bench_json);
criterion_main!(benches);
```

- è¾“å‡º HTML æŠ¥å‘Šå¯¹æ¯”ä¸åŒå®ç°å·®å¼‚ï¼›çº³å…¥ CI åšå›å½’ç›‘æ§ã€‚

## 2.3.12 å¼‚æ­¥å¯è§‚æµ‹ï¼štokio-console

```toml
# Cargo.tomlï¼ˆå¼€å‘ç¯å¢ƒï¼‰
[dependencies]
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["fmt", "registry"] }
console-subscriber = "0.2"
```

```rust
#[tokio::main]
async fn main() {
    console_subscriber::init();
    // ... app
}
```

- åœ¨å¼€å‘/å‹æµ‹ç¯å¢ƒè§‚å¯Ÿä»»åŠ¡æ’é˜Ÿã€Wakerã€èµ„æºå ç”¨ï¼Œå®šä½é˜»å¡ç‚¹ã€‚

## 2.3.13 ç”Ÿäº§å‰–æï¼špprof ç«ç„°å›¾

```toml
[dependencies]
pprof = { version = "0.13", features = ["flamegraph", "frame-pointer"] }
```

```rust
use pprof::protos::Message;
use pprof::ProfilerGuard;

fn profile() {
    let guard = ProfilerGuard::new(100).unwrap();
    // è¿è¡Œè´Ÿè½½...
    if let Ok(report) = guard.report().build() {
        let mut file = std::fs::File::create("flame.svg").unwrap();
        report.flamegraph(&mut file).unwrap();
    }
}
```

- æ³¨æ„ï¼šä»…åœ¨å‡†ç”Ÿäº§æˆ–å—æ§ç¯å¢ƒå¼€å¯ï¼›ç»“åˆé‡‡æ ·ä¸ç™½åå•æ§åˆ¶ã€‚

## 2.3.14 å‹æµ‹æ¨¡æ¿ï¼šwrk/hey/k6/ghz

```bash
# HTTP: wrk
wrk -t4 -c256 -d30s --latency http://localhost:3000/api

# HTTP: hey
hey -z 30s -c 200 -q 100 http://localhost:3000/api

# gRPC: ghz
ghz --insecure --call user.UserService/GetUser -d '{"id":1}' 0.0.0.0:50051

# k6ï¼ˆHTTPï¼‰
cat <<'EOF' > k6.js
import http from 'k6/http';
import { sleep } from 'k6';
export const options = { vus: 200, duration: '30s' };
export default function () { http.get('http://localhost:3000/api'); sleep(0.1); }
EOF
k6 run k6.js
```

- åœ¨ CI ä¸­è®¾å®š P95/P99 ä¸é”™è¯¯ç‡é˜ˆå€¼ï¼Œå¤±è´¥å³çº¢çº¿ã€‚
