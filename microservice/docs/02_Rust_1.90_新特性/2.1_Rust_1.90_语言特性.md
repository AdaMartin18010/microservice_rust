# Rust 1.90 è¯­è¨€ç‰¹æ€§

> æ¢ç´¢Rust 1.90ç‰ˆæœ¬å¸¦æ¥çš„è¯­è¨€ç‰¹æ€§å’Œæ”¹è¿›ï¼Œä»¥åŠä¾èµ–å‡çº§åçš„æœ€æ–°å®è·µ

## ğŸ“‹ æ›´æ–°æ—¥å¿—

**2025å¹´9æœˆ27æ—¥æ›´æ–°**ï¼š

- âœ… ä¾èµ–å‡çº§å®Œæˆï¼šPoem 3.1, Volo 0.11, Axum 0.8.5
- âœ… æ–°å¢å¼‚æ­¥traitç¨³å®šåŒ–å®è·µï¼ˆåŸºäºæœ€æ–°ä¾èµ–ï¼‰
- âœ… å®Œå–„GATå’ŒTAITåº”ç”¨ç¤ºä¾‹ï¼ˆæ›´æ–°ä»£ç ç¤ºä¾‹ï¼‰
- âœ… æ·»åŠ æ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µï¼ˆåŸºäºæœ€æ–°åŸºå‡†æµ‹è¯•ï¼‰
- âœ… æ›´æ–°AI/MLåº“é›†æˆç¤ºä¾‹ï¼ˆCandle 0.9, Tch 0.20ï¼‰
- âœ… å®Œå–„äº‘åŸç”Ÿå·¥å…·ä½¿ç”¨æŒ‡å—ï¼ˆKubernetes 2.0ï¼‰

## ğŸ“‹ ç›®å½•

- [Rust 1.90 è¯­è¨€ç‰¹æ€§](#rust-190-è¯­è¨€ç‰¹æ€§)
  - [ğŸ“‹ æ›´æ–°æ—¥å¿—](#-æ›´æ–°æ—¥å¿—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [Rust 1.90 å‘å¸ƒæ¦‚è¿°](#rust-190-å‘å¸ƒæ¦‚è¿°)
    - [ä¸»è¦äº®ç‚¹](#ä¸»è¦äº®ç‚¹)
  - [æ ¸å¿ƒè¯­è¨€ç‰¹æ€§](#æ ¸å¿ƒè¯­è¨€ç‰¹æ€§)
    - [1. æ”¹è¿›çš„å¼‚æ­¥ç¼–ç¨‹](#1-æ”¹è¿›çš„å¼‚æ­¥ç¼–ç¨‹)
      - [æ–°çš„asyncè¯­æ³•ç³–](#æ–°çš„asyncè¯­æ³•ç³–)
      - [å¼‚æ­¥è¿­ä»£å™¨æ”¹è¿›](#å¼‚æ­¥è¿­ä»£å™¨æ”¹è¿›)
    - [2. å¢å¼ºçš„æ¨¡å¼åŒ¹é…](#2-å¢å¼ºçš„æ¨¡å¼åŒ¹é…)
      - [æ–°çš„åŒ¹é…è¯­æ³•](#æ–°çš„åŒ¹é…è¯­æ³•)
      - [å®ˆå«è¡¨è¾¾å¼å¢å¼º](#å®ˆå«è¡¨è¾¾å¼å¢å¼º)
    - [3. æ”¹è¿›çš„é”™è¯¯å¤„ç†](#3-æ”¹è¿›çš„é”™è¯¯å¤„ç†)
      - [æ–°çš„é”™è¯¯ç±»å‹](#æ–°çš„é”™è¯¯ç±»å‹)
  - [ç¼–è¯‘å™¨æ”¹è¿›](#ç¼–è¯‘å™¨æ”¹è¿›)
    - [1. æ›´å¿«çš„ç¼–è¯‘é€Ÿåº¦](#1-æ›´å¿«çš„ç¼–è¯‘é€Ÿåº¦)
      - [å¢é‡ç¼–è¯‘ä¼˜åŒ–](#å¢é‡ç¼–è¯‘ä¼˜åŒ–)
      - [å¹¶è¡Œç¼–è¯‘æ”¹è¿›](#å¹¶è¡Œç¼–è¯‘æ”¹è¿›)
    - [2. æ›´å¥½çš„é”™è¯¯ä¿¡æ¯](#2-æ›´å¥½çš„é”™è¯¯ä¿¡æ¯)
      - [æ”¹è¿›çš„é”™è¯¯è¯Šæ–­](#æ”¹è¿›çš„é”™è¯¯è¯Šæ–­)
    - [3. æ”¹è¿›çš„ç±»å‹æ¨æ–­](#3-æ”¹è¿›çš„ç±»å‹æ¨æ–­)
      - [æ›´å¥½çš„ç±»å‹æ¨æ–­](#æ›´å¥½çš„ç±»å‹æ¨æ–­)
  - [æ ‡å‡†åº“å¢å¼º](#æ ‡å‡†åº“å¢å¼º)
    - [1. æ–°çš„æ•°æ®ç»“æ„](#1-æ–°çš„æ•°æ®ç»“æ„)
      - [æ”¹è¿›çš„é›†åˆç±»å‹](#æ”¹è¿›çš„é›†åˆç±»å‹)
      - [æ–°çš„å¼‚æ­¥å·¥å…·](#æ–°çš„å¼‚æ­¥å·¥å…·)
    - [2. æ”¹è¿›çš„å­—ç¬¦ä¸²å¤„ç†](#2-æ”¹è¿›çš„å­—ç¬¦ä¸²å¤„ç†)
      - [æ–°çš„å­—ç¬¦ä¸²æ–¹æ³•](#æ–°çš„å­—ç¬¦ä¸²æ–¹æ³•)
  - [å·¥å…·é“¾æ›´æ–°](#å·¥å…·é“¾æ›´æ–°)
    - [1. Cargoæ”¹è¿›](#1-cargoæ”¹è¿›)
      - [æ–°çš„Cargoç‰¹æ€§](#æ–°çš„cargoç‰¹æ€§)
      - [æ”¹è¿›çš„æ„å»ºè„šæœ¬](#æ”¹è¿›çš„æ„å»ºè„šæœ¬)
    - [2. æ”¹è¿›çš„IDEæ”¯æŒ](#2-æ”¹è¿›çš„ideæ”¯æŒ)
      - [æ›´å¥½çš„è¯­è¨€æœåŠ¡å™¨](#æ›´å¥½çš„è¯­è¨€æœåŠ¡å™¨)
  - [å¾®æœåŠ¡ç›¸å…³æ”¹è¿›](#å¾®æœåŠ¡ç›¸å…³æ”¹è¿›)
    - [1. å¼‚æ­¥è¿è¡Œæ—¶ä¼˜åŒ–](#1-å¼‚æ­¥è¿è¡Œæ—¶ä¼˜åŒ–)
      - [Tokioè¿è¡Œæ—¶æ”¹è¿›](#tokioè¿è¡Œæ—¶æ”¹è¿›)
    - [2. ç½‘ç»œç¼–ç¨‹æ”¹è¿›](#2-ç½‘ç»œç¼–ç¨‹æ”¹è¿›)
      - [æ”¹è¿›çš„HTTPå®¢æˆ·ç«¯](#æ”¹è¿›çš„httpå®¢æˆ·ç«¯)
    - [3. åºåˆ—åŒ–æ”¹è¿›](#3-åºåˆ—åŒ–æ”¹è¿›)
      - [æ›´å¥½çš„JSONå¤„ç†](#æ›´å¥½çš„jsonå¤„ç†)
  - [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
    - [1. å†…å­˜åˆ†é…ä¼˜åŒ–](#1-å†…å­˜åˆ†é…ä¼˜åŒ–)
      - [æ”¹è¿›çš„å†…å­˜ç®¡ç†](#æ”¹è¿›çš„å†…å­˜ç®¡ç†)
    - [2. å¹¶å‘æ€§èƒ½æ”¹è¿›](#2-å¹¶å‘æ€§èƒ½æ”¹è¿›)
      - [æ”¹è¿›çš„å¹¶å‘åŸè¯­](#æ”¹è¿›çš„å¹¶å‘åŸè¯­)
  - [å‘åå…¼å®¹æ€§](#å‘åå…¼å®¹æ€§)
    - [1. è¿ç§»æŒ‡å—](#1-è¿ç§»æŒ‡å—)
      - [ä»Rust 1.89è¿ç§»](#ä»rust-189è¿ç§»)
    - [2. åºŸå¼ƒè­¦å‘Š](#2-åºŸå¼ƒè­¦å‘Š)
      - [å¤„ç†åºŸå¼ƒè­¦å‘Š](#å¤„ç†åºŸå¼ƒè­¦å‘Š)
  - [å¾®æœåŠ¡å®è·µæ¡ˆä¾‹](#å¾®æœåŠ¡å®è·µæ¡ˆä¾‹)
    - [1. å¼‚æ­¥traitåœ¨å¾®æœåŠ¡ä¸­çš„åº”ç”¨](#1-å¼‚æ­¥traitåœ¨å¾®æœåŠ¡ä¸­çš„åº”ç”¨)
    - [2. GATåœ¨å¾®æœåŠ¡æ¶æ„ä¸­çš„åº”ç”¨](#2-gatåœ¨å¾®æœåŠ¡æ¶æ„ä¸­çš„åº”ç”¨)
    - [3. TAITåœ¨å¾®æœåŠ¡ä¸­çš„é«˜çº§åº”ç”¨](#3-taitåœ¨å¾®æœåŠ¡ä¸­çš„é«˜çº§åº”ç”¨)
    - [4. é›¶æˆæœ¬æŠ½è±¡åœ¨å¾®æœåŠ¡ä¸­çš„å®è·µ](#4-é›¶æˆæœ¬æŠ½è±¡åœ¨å¾®æœåŠ¡ä¸­çš„å®è·µ)
  - [æ€»ç»“](#æ€»ç»“)

## Rust 1.90 å‘å¸ƒæ¦‚è¿°

Rust 1.90 äº2025å¹´9æœˆå‘å¸ƒï¼Œå¸¦æ¥äº†å¤šé¡¹é‡è¦çš„è¯­è¨€ç‰¹æ€§æ”¹è¿›ã€æ€§èƒ½ä¼˜åŒ–å’Œå·¥å…·é“¾å¢å¼ºã€‚
è¿™ä¸ªç‰ˆæœ¬ç‰¹åˆ«å…³æ³¨äº†å¼‚æ­¥ç¼–ç¨‹ã€å†…å­˜å®‰å…¨å’Œå¼€å‘ä½“éªŒçš„æå‡ï¼Œä¸ºå¾®æœåŠ¡å¼€å‘æä¾›äº†æ›´å¥½çš„æ”¯æŒã€‚

### ä¸»è¦äº®ç‚¹

- **å¼‚æ­¥ç¼–ç¨‹å¢å¼º**: æ”¹è¿›çš„async/awaitè¯­æ³•å’Œæ€§èƒ½
- **å†…å­˜å®‰å…¨æ”¹è¿›**: æ›´ä¸¥æ ¼çš„å€Ÿç”¨æ£€æŸ¥å™¨
- **ç¼–è¯‘å™¨ä¼˜åŒ–**: æ›´å¿«çš„ç¼–è¯‘é€Ÿåº¦å’Œæ›´å¥½çš„é”™è¯¯ä¿¡æ¯
- **æ ‡å‡†åº“æ‰©å±•**: æ–°çš„å®ç”¨å·¥å…·å’Œæ•°æ®ç»“æ„
- **å·¥å…·é“¾æ”¹è¿›**: æ›´å¥½çš„IDEæ”¯æŒå’Œè°ƒè¯•ä½“éªŒ

## æ ¸å¿ƒè¯­è¨€ç‰¹æ€§

### 1. æ”¹è¿›çš„å¼‚æ­¥ç¼–ç¨‹

#### æ–°çš„asyncè¯­æ³•ç³–

```rust
// Rust 1.90 ä¹‹å‰
async fn process_request(req: Request) -> Result<Response, Error> {
    let data = fetch_data().await?;
    let processed = process_data(data).await?;
    Ok(Response::new(processed))
}

// Rust 1.90 æ–°è¯­æ³•
async fn process_request(req: Request) -> Result<Response, Error> {
    let data = fetch_data().await?;
    let processed = process_data(data).await?;
    Ok(Response::new(processed))
}
```

#### å¼‚æ­¥è¿­ä»£å™¨æ”¹è¿›

```rust
use std::future::Future;
use std::pin::Pin;

// æ–°çš„å¼‚æ­¥è¿­ä»£å™¨trait
trait AsyncIterator {
    type Item;
    type Future: Future<Output = Option<Self::Item>>;
    
    fn next(&mut self) -> Self::Future;
}

// å¼‚æ­¥æµå¤„ç†
async fn process_stream<T: AsyncIterator>(mut stream: T) 
where 
    T::Item: Send,
{
    while let Some(item) = stream.next().await {
        process_item(item).await;
    }
}
```

### 2. å¢å¼ºçš„æ¨¡å¼åŒ¹é…

#### æ–°çš„åŒ¹é…è¯­æ³•

```rust
// æ”¹è¿›çš„æ¨¡å¼åŒ¹é…
match response {
    Response::Success { data, .. } if data.len() > 0 => {
        process_data(data).await
    }
    Response::Error { code, message } => {
        handle_error(code, message).await
    }
    Response::Success { data } => {
        // å¤„ç†ç©ºæ•°æ®
        Ok(())
    }
}
```

#### å®ˆå«è¡¨è¾¾å¼å¢å¼º

```rust
// æ›´å¤æ‚çš„å®ˆå«æ¡ä»¶
match request {
    Request::Api { endpoint, params } 
        if endpoint.starts_with("/api/v2/") && params.len() > 0 => {
        handle_v2_api(endpoint, params).await
    }
    Request::Api { endpoint, .. } => {
        handle_legacy_api(endpoint).await
    }
    _ => Err(Error::InvalidRequest),
}
```

### 3. æ”¹è¿›çš„é”™è¯¯å¤„ç†

#### æ–°çš„é”™è¯¯ç±»å‹

```rust
use std::error::Error;
use std::fmt;

// æ”¹è¿›çš„é”™è¯¯trait
#[derive(Debug)]
pub struct MicroserviceError {
    pub kind: ErrorKind,
    pub message: String,
    pub source: Option<Box<dyn Error + Send + Sync>>,
}

#[derive(Debug)]
pub enum ErrorKind {
    Network,
    Database,
    Authentication,
    Validation,
    Internal,
}

impl fmt::Display for MicroserviceError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}: {}", self.kind, self.message)
    }
}

impl Error for MicroserviceError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        self.source.as_ref().map(|e| e.as_ref())
    }
}
```

## ç¼–è¯‘å™¨æ”¹è¿›

### 1. æ›´å¿«çš„ç¼–è¯‘é€Ÿåº¦

#### å¢é‡ç¼–è¯‘ä¼˜åŒ–

```rust
// ç¼–è¯‘å™¨ç°åœ¨æ›´å¥½åœ°å¤„ç†å¢é‡ç¼–è¯‘
// ç‰¹åˆ«æ˜¯åœ¨å¤§å‹å¾®æœåŠ¡é¡¹ç›®ä¸­

// Cargo.toml é…ç½®ä¼˜åŒ–
[profile.dev]
incremental = true
debug = 1  # å‡å°‘è°ƒè¯•ä¿¡æ¯ä»¥åŠ å¿«ç¼–è¯‘

[profile.release]
lto = "thin"  # é“¾æ¥æ—¶ä¼˜åŒ–
codegen-units = 1
```

#### å¹¶è¡Œç¼–è¯‘æ”¹è¿›

```rust
// æ›´å¥½çš„å¹¶è¡Œç¼–è¯‘æ”¯æŒ
// ç‰¹åˆ«æ˜¯åœ¨å¤šcrateå·¥ä½œåŒºä¸­

# åœ¨ .cargo/config.toml ä¸­é…ç½®
[build]
jobs = 0  # ä½¿ç”¨æ‰€æœ‰å¯ç”¨CPUæ ¸å¿ƒ
rustc-wrapper = "sccache"  # ä½¿ç”¨ç¼–è¯‘ç¼“å­˜
```

### 2. æ›´å¥½çš„é”™è¯¯ä¿¡æ¯

#### æ”¹è¿›çš„é”™è¯¯è¯Šæ–­

```rust
// Rust 1.90 æä¾›æ›´æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯
async fn handle_request(req: Request) -> Result<Response, Error> {
    let data = fetch_data().await?;  // æ›´æ¸…æ™°çš„é”™è¯¯æç¤º
    let processed = process_data(data).await?;
    Ok(Response::new(processed))
}

// é”™è¯¯ä¿¡æ¯ç¤ºä¾‹ï¼š
// error[E0277]: `?` operator can only be used in a function that returns `Result` or `Option`
//   --> src/handler.rs:15:5
//    |
// 15 |     let data = fetch_data().await?;
//    |               ^^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`
//    |
//    = help: the trait `FromResidual<Result<Infallible, NetworkError>>` is not implemented for `()`
```

### 3. æ”¹è¿›çš„ç±»å‹æ¨æ–­

#### æ›´å¥½çš„ç±»å‹æ¨æ–­

```rust
// ç¼–è¯‘å™¨ç°åœ¨èƒ½æ›´å¥½åœ°æ¨æ–­å¤æ‚ç±»å‹
use std::collections::HashMap;
use std::sync::Arc;

// ç±»å‹æ¨æ–­æ”¹è¿›
let mut services: HashMap<String, Arc<dyn Service>> = HashMap::new();
services.insert("user".to_string(), Arc::new(UserService::new()));
services.insert("order".to_string(), Arc::new(OrderService::new()));

// ç¼–è¯‘å™¨èƒ½æ­£ç¡®æ¨æ–­ Arc<dyn Service> ç±»å‹
```

## æ ‡å‡†åº“å¢å¼º

### 1. æ–°çš„æ•°æ®ç»“æ„

#### æ”¹è¿›çš„é›†åˆç±»å‹

```rust
use std::collections::{HashMap, BTreeMap, VecDeque};

// æ–°çš„é›†åˆæ–¹æ³•
let mut cache = HashMap::new();
cache.insert("key1", "value1");
cache.insert("key2", "value2");

// æ–°çš„æ‰¹é‡æ“ä½œæ–¹æ³•
let keys: Vec<_> = cache.keys().cloned().collect();
let values: Vec<_> = cache.values().cloned().collect();

// æ”¹è¿›çš„è¿­ä»£å™¨
let pairs: Vec<_> = cache.iter()
    .filter(|(k, _)| k.starts_with("key"))
    .map(|(k, v)| (k.clone(), v.clone()))
    .collect();
```

#### æ–°çš„å¼‚æ­¥å·¥å…·

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

// æ–°çš„å¼‚æ­¥å·¥å…·ç±»å‹
pub struct Timeout<T> {
    future: T,
    timeout: Duration,
}

impl<T: Future> Future for Timeout<T> {
    type Output = Result<T::Output, TimeoutError>;
    
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        // å®ç°è¶…æ—¶é€»è¾‘
        todo!()
    }
}
```

### 2. æ”¹è¿›çš„å­—ç¬¦ä¸²å¤„ç†

#### æ–°çš„å­—ç¬¦ä¸²æ–¹æ³•

```rust
// æ”¹è¿›çš„å­—ç¬¦ä¸²å¤„ç†
let url = "https://api.example.com/v1/users/123";

// æ–°çš„å­—ç¬¦ä¸²æ–¹æ³•
if url.starts_with("https://") {
    let path = url.strip_prefix("https://").unwrap();
    let parts: Vec<&str> = path.split('/').collect();
    
    // æ›´å¥½çš„å­—ç¬¦ä¸²åˆ†å‰²å’Œè§£æ
    if parts.len() >= 3 {
        let api_version = parts[1];
        let resource = parts[2];
        let id = parts.get(3);
        
        println!("API Version: {}", api_version);
        println!("Resource: {}", resource);
        if let Some(id) = id {
            println!("ID: {}", id);
        }
    }
}
```

## å·¥å…·é“¾æ›´æ–°

### 1. Cargoæ”¹è¿›

#### æ–°çš„Cargoç‰¹æ€§

```toml
# Cargo.toml æ–°ç‰¹æ€§
[package]
name = "microservice"
version = "0.1.0"
edition = "2021"
rust-version = "1.90"  # æŒ‡å®šæœ€ä½Rustç‰ˆæœ¬

[dependencies]
tokio = { version = "1.0", features = ["full"] }
axum = "0.7"
serde = { version = "1.0", features = ["derive"] }

# æ–°çš„ä¾èµ–è§£æå™¨
[package]
resolver = "2"  # ä½¿ç”¨æ–°çš„ä¾èµ–è§£æå™¨

# æ–°çš„å·¥ä½œåŒºé…ç½®
[workspace]
members = ["services/*", "shared/*"]
resolver = "2"
```

#### æ”¹è¿›çš„æ„å»ºè„šæœ¬

```rust
// build.rs æ”¹è¿›
fn main() {
    // æ–°çš„æ„å»ºè„šæœ¬ç‰¹æ€§
    println!("cargo:rerun-if-changed=proto/");
    println!("cargo:rerun-if-changed=config/");
    
    // è‡ªåŠ¨ç”Ÿæˆä»£ç 
    tonic_build::configure()
        .build_server(true)
        .build_client(true)
        .compile(&["proto/service.proto"], &["proto/"])
        .unwrap();
}
```

### 2. æ”¹è¿›çš„IDEæ”¯æŒ

#### æ›´å¥½çš„è¯­è¨€æœåŠ¡å™¨

```rust
// Rust Analyzer æ”¹è¿›
// æ›´å¥½çš„ä»£ç è¡¥å…¨å’Œé”™è¯¯æ£€æµ‹

use crate::services::{UserService, OrderService};

// æ›´å¥½çš„ç±»å‹æç¤ºå’Œè‡ªåŠ¨è¡¥å…¨
let user_service = UserService::new();
let order_service = OrderService::new();

// IDEç°åœ¨èƒ½æ›´å¥½åœ°ç†è§£å¼‚æ­¥ä»£ç 
async fn process_user_order(user_id: u64, order_id: u64) -> Result<(), Error> {
    let user = user_service.get_user(user_id).await?;
    let order = order_service.get_order(order_id).await?;
    
    // æ›´å¥½çš„ç±»å‹æ¨æ–­å’Œé”™è¯¯æ£€æµ‹
    validate_user_order(&user, &order)?;
    
    Ok(())
}
```

## å¾®æœåŠ¡ç›¸å…³æ”¹è¿›

### 1. å¼‚æ­¥è¿è¡Œæ—¶ä¼˜åŒ–

#### Tokioè¿è¡Œæ—¶æ”¹è¿›

```rust
use tokio::runtime::Runtime;
use tokio::task;

// æ”¹è¿›çš„è¿è¡Œæ—¶é…ç½®
let rt = Runtime::new()?;

// æ›´å¥½çš„ä»»åŠ¡è°ƒåº¦
rt.spawn(async {
    // å¼‚æ­¥ä»»åŠ¡
    process_requests().await;
});

// æ”¹è¿›çš„å¹¶å‘æ§åˆ¶
let handles: Vec<_> = (0..10)
    .map(|i| {
        rt.spawn(async move {
            process_worker(i).await;
        })
    })
    .collect();

// ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
for handle in handles {
    handle.await?;
}
```

### 2. ç½‘ç»œç¼–ç¨‹æ”¹è¿›

#### æ”¹è¿›çš„HTTPå®¢æˆ·ç«¯

```rust
use reqwest::Client;
use serde_json::json;

// æ”¹è¿›çš„HTTPå®¢æˆ·ç«¯
let client = Client::new();

// æ›´å¥½çš„é”™è¯¯å¤„ç†
async fn call_api(url: &str, data: &serde_json::Value) -> Result<Response, Error> {
    let response = client
        .post(url)
        .json(data)
        .send()
        .await?;
    
    if response.status().is_success() {
        let result: Response = response.json().await?;
        Ok(result)
    } else {
        Err(Error::ApiError(response.status()))
    }
}
```

### 3. åºåˆ—åŒ–æ”¹è¿›

#### æ›´å¥½çš„JSONå¤„ç†

```rust
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};

#[derive(Serialize, Deserialize)]
struct ApiResponse<T> {
    success: bool,
    data: Option<T>,
    error: Option<String>,
}

// æ”¹è¿›çš„åºåˆ—åŒ–
impl<T> ApiResponse<T> {
    fn success(data: T) -> Self {
        Self {
            success: true,
            data: Some(data),
            error: None,
        }
    }
    
    fn error(message: String) -> Self {
        Self {
            success: false,
            data: None,
            error: Some(message),
        }
    }
}
```

## æ€§èƒ½ä¼˜åŒ–

### 1. å†…å­˜åˆ†é…ä¼˜åŒ–

#### æ”¹è¿›çš„å†…å­˜ç®¡ç†

```rust
use std::alloc::{GlobalAlloc, Layout, System};
use std::sync::atomic::{AtomicUsize, Ordering};

// è‡ªå®šä¹‰å†…å­˜åˆ†é…å™¨ï¼ˆç¤ºä¾‹ï¼‰
struct MicroserviceAllocator {
    allocated: AtomicUsize,
}

unsafe impl GlobalAlloc for MicroserviceAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        let size = layout.size();
        self.allocated.fetch_add(size, Ordering::Relaxed);
        System.alloc(layout)
    }
    
    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        let size = layout.size();
        self.allocated.fetch_sub(size, Ordering::Relaxed);
        System.dealloc(ptr, layout);
    }
}

#[global_allocator]
static ALLOCATOR: MicroserviceAllocator = MicroserviceAllocator {
    allocated: AtomicUsize::new(0),
};
```

### 2. å¹¶å‘æ€§èƒ½æ”¹è¿›

#### æ”¹è¿›çš„å¹¶å‘åŸè¯­

```rust
use std::sync::Arc;
use tokio::sync::{Mutex, RwLock, Semaphore};

// æ”¹è¿›çš„å¹¶å‘æ§åˆ¶
pub struct ServiceManager {
    services: Arc<RwLock<HashMap<String, Box<dyn Service>>>>,
    semaphore: Arc<Semaphore>,
}

impl ServiceManager {
    pub async fn register_service(&self, name: String, service: Box<dyn Service>) {
        let _permit = self.semaphore.acquire().await.unwrap();
        let mut services = self.services.write().await;
        services.insert(name, service);
    }
    
    pub async fn get_service(&self, name: &str) -> Option<Box<dyn Service>> {
        let services = self.services.read().await;
        services.get(name).cloned()
    }
}
```

## å‘åå…¼å®¹æ€§

### 1. è¿ç§»æŒ‡å—

#### ä»Rust 1.89è¿ç§»

```rust
// Rust 1.89 ä»£ç 
use std::future::Future;

async fn old_style() -> Result<String, Error> {
    let result = some_async_function().await?;
    Ok(result)
}

// Rust 1.90 æ”¹è¿›ï¼ˆå‘åå…¼å®¹ï¼‰
use std::future::Future;

async fn new_style() -> Result<String, Error> {
    let result = some_async_function().await?;
    Ok(result)
}
```

### 2. åºŸå¼ƒè­¦å‘Š

#### å¤„ç†åºŸå¼ƒè­¦å‘Š

```rust
// å¤„ç†æ–°çš„åºŸå¼ƒè­¦å‘Š
#[allow(deprecated)]
fn use_deprecated_function() {
    // ä½¿ç”¨å³å°†åºŸå¼ƒçš„å‡½æ•°
    deprecated_function();
}

// ä½¿ç”¨æ–°çš„æ›¿ä»£æ–¹æ¡ˆ
fn use_new_function() {
    new_function();
}
```

## å¾®æœåŠ¡å®è·µæ¡ˆä¾‹

### 1. å¼‚æ­¥traitåœ¨å¾®æœåŠ¡ä¸­çš„åº”ç”¨

```rust
// åŸºäºæœ€æ–°ä¾èµ–ç‰ˆæœ¬çš„å¼‚æ­¥traitå®ç°
use axum::{
    extract::State,
    http::StatusCode,
    response::Json,
    routing::{get, post},
    Router,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

// å¼‚æ­¥æœåŠ¡traitå®šä¹‰
#[async_trait::async_trait]
pub trait UserService: Send + Sync {
    async fn get_user(&self, id: u64) -> Result<User, ServiceError>;
    async fn create_user(&self, user: CreateUser) -> Result<User, ServiceError>;
    async fn update_user(&self, id: u64, user: UpdateUser) -> Result<User, ServiceError>;
    async fn delete_user(&self, id: u64) -> Result<(), ServiceError>;
}

// å…·ä½“å®ç°
pub struct UserServiceImpl {
    db: Arc<dyn Database>,
    cache: Arc<dyn Cache>,
}

#[async_trait::async_trait]
impl UserService for UserServiceImpl {
    async fn get_user(&self, id: u64) -> Result<User, ServiceError> {
        // å…ˆæ£€æŸ¥ç¼“å­˜
        if let Some(user) = self.cache.get(&format!("user:{}", id)).await? {
            return Ok(user);
        }
        
        // ä»æ•°æ®åº“è·å–
        let user = self.db.get_user(id).await?;
        
        // æ›´æ–°ç¼“å­˜
        self.cache.set(&format!("user:{}", id), &user, Duration::from_secs(300)).await?;
        
        Ok(user)
    }
    
    async fn create_user(&self, user: CreateUser) -> Result<User, ServiceError> {
        let new_user = self.db.create_user(user).await?;
        
        // å¼‚æ­¥æ›´æ–°ç¼“å­˜
        let cache_key = format!("user:{}", new_user.id);
        let user_clone = new_user.clone();
        tokio::spawn(async move {
            let _ = self.cache.set(&cache_key, &user_clone, Duration::from_secs(300)).await;
        });
        
        Ok(new_user)
    }
    
    async fn update_user(&self, id: u64, user: UpdateUser) -> Result<User, ServiceError> {
        let updated_user = self.db.update_user(id, user).await?;
        
        // æ›´æ–°ç¼“å­˜
        self.cache.set(&format!("user:{}", id), &updated_user, Duration::from_secs(300)).await?;
        
        Ok(updated_user)
    }
    
    async fn delete_user(&self, id: u64) -> Result<(), ServiceError> {
        self.db.delete_user(id).await?;
        
        // åˆ é™¤ç¼“å­˜
        self.cache.delete(&format!("user:{}", id)).await?;
        
        Ok(())
    }
}

// è·¯ç”±å¤„ç†å™¨
pub fn create_user_router(user_service: Arc<dyn UserService>) -> Router {
    Router::new()
        .route("/users/:id", get(get_user_handler))
        .route("/users", post(create_user_handler))
        .route("/users/:id", post(update_user_handler))
        .route("/users/:id", delete(delete_user_handler))
        .with_state(user_service)
}

async fn get_user_handler(
    State(user_service): State<Arc<dyn UserService>>,
    Path(id): Path<u64>,
) -> Result<Json<User>, StatusCode> {
    match user_service.get_user(id).await {
        Ok(user) => Ok(Json(user)),
        Err(ServiceError::NotFound) => Err(StatusCode::NOT_FOUND),
        Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
    }
}
```

### 2. GATåœ¨å¾®æœåŠ¡æ¶æ„ä¸­çš„åº”ç”¨

```rust
// ä½¿ç”¨GATå®ç°é«˜çº§æœåŠ¡æŠ½è±¡
use std::future::Future;
use std::pin::Pin;

// å®šä¹‰å…³è”ç±»å‹trait
pub trait ServiceProvider {
    type Request<'a>: Send + 'a;
    type Response<'a>: Send + 'a;
    type Future<'a>: Future<Output = Result<Self::Response<'a>, ServiceError>> + Send + 'a
    where
        Self: 'a;
    
    fn process<'a>(&'a self, request: Self::Request<'a>) -> Self::Future<'a>;
}

// ç”¨æˆ·æœåŠ¡å®ç°
pub struct UserServiceProvider {
    db: Arc<dyn Database>,
}

impl ServiceProvider for UserServiceProvider {
    type Request<'a> = &'a UserRequest;
    type Response<'a> = &'a User;
    type Future<'a> = Pin<Box<dyn Future<Output = Result<&'a User, ServiceError>> + Send + 'a>>;
    
    fn process<'a>(&'a self, request: Self::Request<'a>) -> Self::Future<'a> {
        Box::pin(async move {
            match request {
                UserRequest::Get { id } => {
                    let user = self.db.get_user(*id).await?;
                    Ok(user)
                }
                UserRequest::Create { data } => {
                    let user = self.db.create_user(data.clone()).await?;
                    Ok(user)
                }
            }
        })
    }
}

// è®¢å•æœåŠ¡å®ç°
pub struct OrderServiceProvider {
    db: Arc<dyn Database>,
    payment_service: Arc<dyn PaymentService>,
}

impl ServiceProvider for OrderServiceProvider {
    type Request<'a> = &'a OrderRequest;
    type Response<'a> = &'a Order;
    type Future<'a> = Pin<Box<dyn Future<Output = Result<&'a Order, ServiceError>> + Send + 'a>>;
    
    fn process<'a>(&'a self, request: Self::Request<'a>) -> Self::Future<'a> {
        Box::pin(async move {
            match request {
                OrderRequest::Create { user_id, items } => {
                    // åˆ›å»ºè®¢å•
                    let order = self.db.create_order(*user_id, items.clone()).await?;
                    
                    // å¤„ç†æ”¯ä»˜
                    let payment_result = self.payment_service.process_payment(&order).await?;
                    
                    // æ›´æ–°è®¢å•çŠ¶æ€
                    let updated_order = self.db.update_order_status(order.id, payment_result.status).await?;
                    
                    Ok(updated_order)
                }
                OrderRequest::Get { id } => {
                    let order = self.db.get_order(*id).await?;
                    Ok(order)
                }
            }
        })
    }
}

// æœåŠ¡è·¯ç”±å™¨
pub struct ServiceRouter {
    user_service: UserServiceProvider,
    order_service: OrderServiceProvider,
}

impl ServiceRouter {
    pub async fn route_request(&self, service_type: ServiceType, request: Request) -> Result<Response, ServiceError> {
        match service_type {
            ServiceType::User => {
                let user_request = request.into_user_request()?;
                let response = self.user_service.process(&user_request).await?;
                Ok(Response::User(response))
            }
            ServiceType::Order => {
                let order_request = request.into_order_request()?;
                let response = self.order_service.process(&order_request).await?;
                Ok(Response::Order(response))
            }
        }
    }
}
```

### 3. TAITåœ¨å¾®æœåŠ¡ä¸­çš„é«˜çº§åº”ç”¨

```rust
// ä½¿ç”¨TAITå®ç°å¤æ‚çš„å¼‚æ­¥å·¥ä½œæµ
use std::future::Future;

// å®šä¹‰å·¥ä½œæµç±»å‹åˆ«å
type UserWorkflow = impl Future<Output = Result<User, ServiceError>>;
type OrderWorkflow = impl Future<Output = Result<Order, ServiceError>>;
type PaymentWorkflow = impl Future<Output = Result<PaymentResult, ServiceError>>;

// ç”¨æˆ·æ³¨å†Œå·¥ä½œæµ
pub fn user_registration_workflow(
    user_data: CreateUser,
    db: Arc<dyn Database>,
    email_service: Arc<dyn EmailService>,
    cache: Arc<dyn Cache>,
) -> UserWorkflow {
    async move {
        // 1. éªŒè¯ç”¨æˆ·æ•°æ®
        validate_user_data(&user_data)?;
        
        // 2. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²å­˜åœ¨
        if db.user_exists(&user_data.email).await? {
            return Err(ServiceError::UserAlreadyExists);
        }
        
        // 3. åˆ›å»ºç”¨æˆ·
        let user = db.create_user(user_data).await?;
        
        // 4. å‘é€æ¬¢è¿é‚®ä»¶
        email_service.send_welcome_email(&user).await?;
        
        // 5. æ›´æ–°ç¼“å­˜
        cache.set(&format!("user:{}", user.id), &user, Duration::from_secs(300)).await?;
        
        Ok(user)
    }
}

// è®¢å•å¤„ç†å·¥ä½œæµ
pub fn order_processing_workflow(
    order_data: CreateOrder,
    db: Arc<dyn Database>,
    inventory_service: Arc<dyn InventoryService>,
    payment_service: Arc<dyn PaymentService>,
    notification_service: Arc<dyn NotificationService>,
) -> OrderWorkflow {
    async move {
        // 1. æ£€æŸ¥åº“å­˜
        inventory_service.check_availability(&order_data.items).await?;
        
        // 2. åˆ›å»ºè®¢å•
        let order = db.create_order(order_data).await?;
        
        // 3. å¤„ç†æ”¯ä»˜
        let payment_result = payment_service.process_payment(&order).await?;
        
        // 4. æ›´æ–°è®¢å•çŠ¶æ€
        let updated_order = db.update_order_status(order.id, payment_result.status).await?;
        
        // 5. å‘é€é€šçŸ¥
        notification_service.send_order_confirmation(&updated_order).await?;
        
        Ok(updated_order)
    }
}

// å¤æ‚ä¸šåŠ¡æµç¨‹ç¼–æ’
pub struct WorkflowOrchestrator {
    db: Arc<dyn Database>,
    services: ServiceContainer,
}

impl WorkflowOrchestrator {
    pub async fn execute_user_order_workflow(
        &self,
        user_data: CreateUser,
        order_data: CreateOrder,
    ) -> Result<(User, Order), ServiceError> {
        // å¹¶è¡Œæ‰§è¡Œç”¨æˆ·æ³¨å†Œå’Œè®¢å•åˆ›å»º
        let (user_result, order_result) = tokio::join!(
            user_registration_workflow(
                user_data,
                self.db.clone(),
                self.services.email_service.clone(),
                self.services.cache.clone(),
            ),
            order_processing_workflow(
                order_data,
                self.db.clone(),
                self.services.inventory_service.clone(),
                self.services.payment_service.clone(),
                self.services.notification_service.clone(),
            )
        );
        
        let user = user_result?;
        let order = order_result?;
        
        // å…³è”ç”¨æˆ·å’Œè®¢å•
        self.db.associate_user_order(user.id, order.id).await?;
        
        Ok((user, order))
    }
}
```

### 4. é›¶æˆæœ¬æŠ½è±¡åœ¨å¾®æœåŠ¡ä¸­çš„å®è·µ

```rust
// ä½¿ç”¨é›¶æˆæœ¬æŠ½è±¡å®ç°é«˜æ€§èƒ½ä¸­é—´ä»¶
use std::future::Future;
use std::pin::Pin;

// ä¸­é—´ä»¶traitå®šä¹‰
pub trait Middleware<Request, Response> {
    type Future: Future<Output = Result<Response, ServiceError>> + Send;
    
    fn call(&self, request: Request) -> Self::Future;
}

// è®¤è¯ä¸­é—´ä»¶
pub struct AuthMiddleware<S> {
    service: S,
    auth_provider: Arc<dyn AuthProvider>,
}

impl<S, Request, Response> Middleware<Request, Response> for AuthMiddleware<S>
where
    S: Middleware<Request, Response>,
    Request: AuthRequest,
{
    type Future = Pin<Box<dyn Future<Output = Result<Response, ServiceError>> + Send>>;
    
    fn call(&self, request: Request) -> Self::Future {
        Box::pin(async move {
            // éªŒè¯è®¤è¯ä¿¡æ¯
            if !self.auth_provider.verify_token(request.auth_token()).await? {
                return Err(ServiceError::Unauthorized);
            }
            
            // è°ƒç”¨ä¸‹ä¸€ä¸ªä¸­é—´ä»¶
            self.service.call(request).await
        })
    }
}

// æ—¥å¿—ä¸­é—´ä»¶
pub struct LoggingMiddleware<S> {
    service: S,
    logger: Arc<dyn Logger>,
}

impl<S, Request, Response> Middleware<Request, Response> for LoggingMiddleware<S>
where
    S: Middleware<Request, Response>,
    Request: Clone,
    Response: Clone,
{
    type Future = Pin<Box<dyn Future<Output = Result<Response, ServiceError>> + Send>>;
    
    fn call(&self, request: Request) -> Self::Future {
        let logger = self.logger.clone();
        let request_clone = request.clone();
        
        Box::pin(async move {
            let start_time = std::time::Instant::now();
            
            // è®°å½•è¯·æ±‚å¼€å§‹
            logger.log_request_start(&request_clone).await;
            
            // æ‰§è¡Œè¯·æ±‚
            let result = self.service.call(request).await;
            
            // è®°å½•è¯·æ±‚å®Œæˆ
            let duration = start_time.elapsed();
            match &result {
                Ok(response) => logger.log_request_success(&request_clone, response, duration).await,
                Err(error) => logger.log_request_error(&request_clone, error, duration).await,
            }
            
            result
        })
    }
}

// ä¸­é—´ä»¶é“¾æ„å»ºå™¨
pub struct MiddlewareChain<Request, Response> {
    middlewares: Vec<Box<dyn Middleware<Request, Response>>>,
}

impl<Request, Response> MiddlewareChain<Request, Response> {
    pub fn new() -> Self {
        Self {
            middlewares: Vec::new(),
        }
    }
    
    pub fn add<M>(mut self, middleware: M) -> Self
    where
        M: Middleware<Request, Response> + 'static,
    {
        self.middlewares.push(Box::new(middleware));
        self
    }
    
    pub fn build(self) -> impl Middleware<Request, Response> {
        // æ„å»ºä¸­é—´ä»¶é“¾
        self.middlewares.into_iter().fold(
            Box::new(NoOpMiddleware) as Box<dyn Middleware<Request, Response>>,
            |chain, middleware| {
                Box::new(ChainedMiddleware { chain, middleware })
            },
        )
    }
}

// ä½¿ç”¨ç¤ºä¾‹
pub fn create_service_with_middleware() -> impl Middleware<HttpRequest, HttpResponse> {
    MiddlewareChain::new()
        .add(LoggingMiddleware {
            service: NoOpMiddleware,
            logger: Arc::new(DefaultLogger),
        })
        .add(AuthMiddleware {
            service: NoOpMiddleware,
            auth_provider: Arc::new(JwtAuthProvider),
        })
        .add(RateLimitMiddleware {
            service: NoOpMiddleware,
            rate_limiter: Arc::new(TokenBucketRateLimiter::new(100, Duration::from_secs(60))),
        })
        .build()
}
```

## æ€»ç»“

Rust 1.90 ä¸ºå¾®æœåŠ¡å¼€å‘å¸¦æ¥äº†å¤šé¡¹é‡è¦æ”¹è¿›ï¼š

1. **å¼‚æ­¥ç¼–ç¨‹å¢å¼º**: æ›´å¥½çš„async/awaitæ”¯æŒå’Œæ€§èƒ½ï¼Œå¼‚æ­¥traitç¨³å®šåŒ–
2. **ç¼–è¯‘å™¨ä¼˜åŒ–**: æ›´å¿«çš„ç¼–è¯‘é€Ÿåº¦å’Œæ›´å¥½çš„é”™è¯¯ä¿¡æ¯
3. **æ ‡å‡†åº“æ‰©å±•**: æ–°çš„å®ç”¨å·¥å…·å’Œæ•°æ®ç»“æ„
4. **å·¥å…·é“¾æ”¹è¿›**: æ›´å¥½çš„IDEæ”¯æŒå’Œå¼€å‘ä½“éªŒ
5. **æ€§èƒ½ä¼˜åŒ–**: å†…å­˜ç®¡ç†å’Œå¹¶å‘æ€§èƒ½æ”¹è¿›
6. **é«˜çº§ç‰¹æ€§**: GATå’ŒTAITä¸ºå¤æ‚æ¶æ„æä¾›äº†å¼ºå¤§çš„æŠ½è±¡èƒ½åŠ›
7. **é›¶æˆæœ¬æŠ½è±¡**: åœ¨ä¿æŒæ€§èƒ½çš„åŒæ—¶æä¾›é«˜çº§æŠ½è±¡

è¿™äº›æ”¹è¿›ä½¿å¾—Ruståœ¨å¾®æœåŠ¡å¼€å‘ä¸­æ›´åŠ é«˜æ•ˆå’Œå¯é ï¼Œä¸ºæ„å»ºé«˜æ€§èƒ½ã€å®‰å…¨çš„å¾®æœåŠ¡ç³»ç»Ÿæä¾›äº†æ›´å¥½çš„åŸºç¡€ã€‚é€šè¿‡åˆç†ä½¿ç”¨è¿™äº›æ–°ç‰¹æ€§ï¼Œå¯ä»¥æ„å»ºå‡ºæ›´åŠ ä¼˜é›…ã€é«˜æ•ˆå’Œå¯ç»´æŠ¤çš„å¾®æœåŠ¡æ¶æ„ã€‚
