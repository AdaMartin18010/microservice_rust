# 零信任架构实现

> 基于Rust 1.90的微服务零信任安全架构设计与实现

## 📋 概述

零信任架构是一种安全模型，它假设网络内外都不存在可信任的边界，要求对所有访问请求进行验证和授权。本指南将介绍如何在Rust微服务中实现零信任架构，包括身份验证、授权、加密、监控等核心安全组件。

## 🎯 学习目标

- 理解零信任架构的核心原则和设计理念
- 掌握微服务环境下的身份认证和授权机制
- 学会实现服务间通信的安全加密
- 了解安全监控和威胁检测的实现方法

## 📚 内容大纲

## 🔧 基础概念

### 零信任架构模型

```text
┌─────────────────────────────────────┐
│        零信任架构层次                │
├─────────────────────────────────────┤
│ 身份层 (Identity Layer)             │
│  ├─ 多因素认证 (MFA)                │
│  ├─ 单点登录 (SSO)                  │
│  └─ 身份提供者 (IdP)                │
├─────────────────────────────────────┤
│ 设备层 (Device Layer)               │
│  ├─ 设备认证                        │
│  ├─ 设备合规检查                    │
│  └─ 设备信任评估                    │
├─────────────────────────────────────┤
│ 网络层 (Network Layer)              │
│  ├─ 网络分段                        │
│  ├─ 微隔离                          │
│  └─ 流量加密                        │
├─────────────────────────────────────┤
│ 应用层 (Application Layer)          │
│  ├─ 应用认证                        │
│  ├─ API安全                         │
│  └─ 数据保护                        │
├─────────────────────────────────────┤
│ 数据层 (Data Layer)                 │
│  ├─ 数据分类                        │
│  ├─ 数据加密                        │
│  └─ 数据访问控制                    │
└─────────────────────────────────────┘
```

### 核心原则

1. **永不信任，始终验证** (Never Trust, Always Verify)
2. **最小权限原则** (Principle of Least Privilege)
3. **假设违规** (Assume Breach)
4. **持续监控** (Continuous Monitoring)
5. **动态访问控制** (Dynamic Access Control)

## 🛠️ 零信任原则

### 1. 身份验证系统

```rust
// src/identity/authentication.rs
use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: String,        // 用户ID
    pub iss: String,        // 发行者
    pub aud: String,        // 受众
    pub exp: usize,         // 过期时间
    pub iat: usize,         // 签发时间
    pub nbf: usize,         // 生效时间
    pub jti: String,        // JWT ID
    pub roles: Vec<String>, // 用户角色
    pub permissions: Vec<String>, // 用户权限
    pub device_id: String,  // 设备ID
    pub session_id: String, // 会话ID
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AuthenticationRequest {
    pub username: String,
    pub password: String,
    pub device_id: String,
    pub mfa_code: Option<String>,
    pub biometric_data: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AuthenticationResponse {
    pub access_token: String,
    pub refresh_token: String,
    pub token_type: String,
    pub expires_in: u64,
    pub scope: Vec<String>,
}

pub struct AuthenticationService {
    encoding_key: EncodingKey,
    decoding_key: DecodingKey,
    validation: Validation,
    secret: String,
}

impl AuthenticationService {
    pub fn new(secret: String) -> Self {
        let encoding_key = EncodingKey::from_secret(secret.as_ref());
        let decoding_key = DecodingKey::from_secret(secret.as_ref());
        
        let mut validation = Validation::new(Algorithm::HS256);
        validation.set_issuer(&["microservice-auth"]);
        validation.set_audience(&["microservice-api"]);
        
        Self {
            encoding_key,
            decoding_key,
            validation,
            secret,
        }
    }
    
    pub async fn authenticate(&self, request: AuthenticationRequest) -> Result<AuthenticationResponse, AuthError> {
        // 1. 验证用户名和密码
        let user = self.verify_credentials(&request.username, &request.password).await?;
        
        // 2. 验证设备
        self.verify_device(&request.device_id, &user.id).await?;
        
        // 3. 多因素认证
        if let Some(mfa_code) = request.mfa_code {
            self.verify_mfa(&user.id, &mfa_code).await?;
        }
        
        // 4. 生物识别验证
        if let Some(biometric) = request.biometric_data {
            self.verify_biometric(&user.id, &biometric).await?;
        }
        
        // 5. 生成访问令牌
        let access_token = self.generate_access_token(&user).await?;
        let refresh_token = self.generate_refresh_token(&user).await?;
        
        Ok(AuthenticationResponse {
            access_token,
            refresh_token,
            token_type: "Bearer".to_string(),
            expires_in: 3600, // 1小时
            scope: user.permissions.clone(),
        })
    }
    
    async fn verify_credentials(&self, username: &str, password: &str) -> Result<User, AuthError> {
        // 实现密码验证逻辑
        // 包括密码哈希验证、账户锁定检查等
        todo!()
    }
    
    async fn verify_device(&self, device_id: &str, user_id: &str) -> Result<(), AuthError> {
        // 实现设备验证逻辑
        // 包括设备注册检查、设备合规性验证等
        todo!()
    }
    
    async fn verify_mfa(&self, user_id: &str, mfa_code: &str) -> Result<(), AuthError> {
        // 实现多因素认证验证
        // 支持TOTP、SMS、邮件等多种方式
        todo!()
    }
    
    async fn verify_biometric(&self, user_id: &str, biometric_data: &str) -> Result<(), AuthError> {
        // 实现生物识别验证
        // 包括指纹、面部识别等
        todo!()
    }
    
    async fn generate_access_token(&self, user: &User) -> Result<String, AuthError> {
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as usize;
        
        let claims = Claims {
            sub: user.id.clone(),
            iss: "microservice-auth".to_string(),
            aud: "microservice-api".to_string(),
            exp: now + 3600, // 1小时后过期
            iat: now,
            nbf: now,
            jti: Uuid::new_v4().to_string(),
            roles: user.roles.clone(),
            permissions: user.permissions.clone(),
            device_id: user.device_id.clone(),
            session_id: Uuid::new_v4().to_string(),
        };
        
        encode(&Header::new(Algorithm::HS256), &claims, &self.encoding_key)
            .map_err(|e| AuthError::TokenGeneration(e.to_string()))
    }
    
    async fn generate_refresh_token(&self, user: &User) -> Result<String, AuthError> {
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as usize;
        
        let claims = Claims {
            sub: user.id.clone(),
            iss: "microservice-auth".to_string(),
            aud: "microservice-api".to_string(),
            exp: now + 86400 * 7, // 7天后过期
            iat: now,
            nbf: now,
            jti: Uuid::new_v4().to_string(),
            roles: user.roles.clone(),
            permissions: user.permissions.clone(),
            device_id: user.device_id.clone(),
            session_id: Uuid::new_v4().to_string(),
        };
        
        encode(&Header::new(Algorithm::HS256), &claims, &self.encoding_key)
            .map_err(|e| AuthError::TokenGeneration(e.to_string()))
    }
    
    pub fn validate_token(&self, token: &str) -> Result<Claims, AuthError> {
        decode::<Claims>(token, &self.decoding_key, &self.validation)
            .map(|data| data.claims)
            .map_err(|e| AuthError::TokenValidation(e.to_string()))
    }
}

#[derive(Debug)]
pub struct User {
    pub id: String,
    pub username: String,
    pub email: String,
    pub roles: Vec<String>,
    pub permissions: Vec<String>,
    pub device_id: String,
    pub is_active: bool,
    pub last_login: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, thiserror::Error)]
pub enum AuthError {
    #[error("Invalid credentials")]
    InvalidCredentials,
    #[error("Account locked")]
    AccountLocked,
    #[error("Device not registered")]
    DeviceNotRegistered,
    #[error("MFA verification failed")]
    MfaVerificationFailed,
    #[error("Biometric verification failed")]
    BiometricVerificationFailed,
    #[error("Token generation failed: {0}")]
    TokenGeneration(String),
    #[error("Token validation failed: {0}")]
    TokenValidation(String),
}
```

### 2. 授权与访问控制

```rust
// src/authorization/access_control.rs
use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use tracing::{info, warn, error};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Policy {
    pub id: String,
    pub name: String,
    pub description: String,
    pub rules: Vec<Rule>,
    pub conditions: Vec<Condition>,
    pub effect: Effect,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Rule {
    pub id: String,
    pub resource: String,
    pub action: String,
    pub conditions: Vec<Condition>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Condition {
    pub attribute: String,
    pub operator: Operator,
    pub value: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Operator {
    Equals,
    NotEquals,
    In,
    NotIn,
    GreaterThan,
    LessThan,
    Contains,
    StartsWith,
    EndsWith,
    Regex,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Effect {
    Allow,
    Deny,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AccessRequest {
    pub subject: String,      // 用户ID
    pub resource: String,     // 资源
    pub action: String,       // 操作
    pub context: HashMap<String, serde_json::Value>, // 上下文信息
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AccessDecision {
    pub decision: Effect,
    pub reason: String,
    pub policies: Vec<String>,
    pub conditions_met: Vec<String>,
    pub conditions_failed: Vec<String>,
}

pub struct AccessControlService {
    policies: HashMap<String, Policy>,
    policy_engine: PolicyEngine,
}

impl AccessControlService {
    pub fn new() -> Self {
        Self {
            policies: HashMap::new(),
            policy_engine: PolicyEngine::new(),
        }
    }
    
    pub fn add_policy(&mut self, policy: Policy) {
        self.policies.insert(policy.id.clone(), policy);
    }
    
    pub async fn authorize(&self, request: AccessRequest) -> Result<AccessDecision, AuthError> {
        info!("处理访问请求: {:?}", request);
        
        // 1. 获取适用的策略
        let applicable_policies = self.get_applicable_policies(&request).await;
        
        if applicable_policies.is_empty() {
            return Ok(AccessDecision {
                decision: Effect::Deny,
                reason: "No applicable policies found".to_string(),
                policies: vec![],
                conditions_met: vec![],
                conditions_failed: vec![],
            });
        }
        
        // 2. 评估策略
        let mut decision = AccessDecision {
            decision: Effect::Deny,
            reason: "Default deny".to_string(),
            policies: vec![],
            conditions_met: vec![],
            conditions_failed: vec![],
        };
        
        for policy in applicable_policies {
            let policy_decision = self.policy_engine.evaluate_policy(&policy, &request).await;
            
            match policy_decision.decision {
                Effect::Allow => {
                    decision.decision = Effect::Allow;
                    decision.reason = format!("Policy {} allows access", policy.name);
                    decision.policies.push(policy.id.clone());
                    decision.conditions_met.extend(policy_decision.conditions_met);
                    break; // 第一个Allow策略生效
                }
                Effect::Deny => {
                    decision.decision = Effect::Deny;
                    decision.reason = format!("Policy {} denies access", policy.name);
                    decision.policies.push(policy.id.clone());
                    decision.conditions_failed.extend(policy_decision.conditions_failed);
                    break; // 第一个Deny策略生效
                }
            }
        }
        
        info!("访问决策: {:?}", decision);
        Ok(decision)
    }
    
    async fn get_applicable_policies(&self, request: &AccessRequest) -> Vec<&Policy> {
        self.policies
            .values()
            .filter(|policy| self.is_policy_applicable(policy, request))
            .collect()
    }
    
    fn is_policy_applicable(&self, policy: &Policy, request: &AccessRequest) -> bool {
        // 检查策略是否适用于当前请求
        policy.rules.iter().any(|rule| {
            self.matches_resource(rule, &request.resource) &&
            self.matches_action(rule, &request.action)
        })
    }
    
    fn matches_resource(&self, rule: &Rule, resource: &str) -> bool {
        // 实现资源匹配逻辑
        // 支持通配符、正则表达式等
        rule.resource == resource || 
        rule.resource.ends_with("*") && resource.starts_with(&rule.resource[..rule.resource.len()-1])
    }
    
    fn matches_action(&self, rule: &Rule, action: &str) -> bool {
        // 实现操作匹配逻辑
        rule.action == action || rule.action == "*"
    }
}

pub struct PolicyEngine {
    condition_evaluator: ConditionEvaluator,
}

impl PolicyEngine {
    pub fn new() -> Self {
        Self {
            condition_evaluator: ConditionEvaluator::new(),
        }
    }
    
    pub async fn evaluate_policy(&self, policy: &Policy, request: &AccessRequest) -> AccessDecision {
        let mut conditions_met = Vec::new();
        let mut conditions_failed = Vec::new();
        
        // 评估策略条件
        for condition in &policy.conditions {
            if self.condition_evaluator.evaluate(condition, &request.context).await {
                conditions_met.push(condition.attribute.clone());
            } else {
                conditions_failed.push(condition.attribute.clone());
            }
        }
        
        // 评估规则
        for rule in &policy.rules {
            let rule_conditions_met = self.evaluate_rule_conditions(rule, &request.context).await;
            if rule_conditions_met.is_empty() {
                continue;
            }
            
            conditions_met.extend(rule_conditions_met);
        }
        
        AccessDecision {
            decision: policy.effect.clone(),
            reason: format!("Policy {} evaluated", policy.name),
            policies: vec![policy.id.clone()],
            conditions_met,
            conditions_failed,
        }
    }
    
    async fn evaluate_rule_conditions(&self, rule: &Rule, context: &HashMap<String, serde_json::Value>) -> Vec<String> {
        let mut conditions_met = Vec::new();
        
        for condition in &rule.conditions {
            if self.condition_evaluator.evaluate(condition, context).await {
                conditions_met.push(condition.attribute.clone());
            }
        }
        
        conditions_met
    }
}

pub struct ConditionEvaluator;

impl ConditionEvaluator {
    pub fn new() -> Self {
        Self
    }
    
    pub async fn evaluate(&self, condition: &Condition, context: &HashMap<String, serde_json::Value>) -> bool {
        let attribute_value = context.get(&condition.attribute);
        
        match attribute_value {
            Some(value) => self.compare_values(value, &condition.operator, &condition.value),
            None => false,
        }
    }
    
    fn compare_values(&self, actual: &serde_json::Value, operator: &Operator, expected: &serde_json::Value) -> bool {
        match operator {
            Operator::Equals => actual == expected,
            Operator::NotEquals => actual != expected,
            Operator::In => {
                if let Some(array) = expected.as_array() {
                    array.contains(actual)
                } else {
                    false
                }
            }
            Operator::NotIn => {
                if let Some(array) = expected.as_array() {
                    !array.contains(actual)
                } else {
                    true
                }
            }
            Operator::GreaterThan => {
                if let (Some(a), Some(e)) = (actual.as_f64(), expected.as_f64()) {
                    a > e
                } else {
                    false
                }
            }
            Operator::LessThan => {
                if let (Some(a), Some(e)) = (actual.as_f64(), expected.as_f64()) {
                    a < e
                } else {
                    false
                }
            }
            Operator::Contains => {
                if let (Some(a), Some(e)) = (actual.as_str(), expected.as_str()) {
                    a.contains(e)
                } else {
                    false
                }
            }
            Operator::StartsWith => {
                if let (Some(a), Some(e)) = (actual.as_str(), expected.as_str()) {
                    a.starts_with(e)
                } else {
                    false
                }
            }
            Operator::EndsWith => {
                if let (Some(a), Some(e)) = (actual.as_str(), expected.as_str()) {
                    a.ends_with(e)
                } else {
                    false
                }
            }
            Operator::Regex => {
                if let (Some(a), Some(e)) = (actual.as_str(), expected.as_str()) {
                    regex::Regex::new(e).map_or(false, |re| re.is_match(a))
                } else {
                    false
                }
            }
        }
    }
}
```

### 3. 服务间通信安全

```rust
// src/security/service_communication.rs
use std::collections::HashMap;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Deserialize, Serialize};
use ring::{digest, hmac, rand};
use base64::{Engine as _, engine::general_purpose};

#[derive(Debug, Serialize, Deserialize)]
pub struct ServiceToken {
    pub service_id: String,
    pub target_service: String,
    pub permissions: Vec<String>,
    pub expires_at: u64,
    pub issued_at: u64,
    pub nonce: String,
    pub signature: String,
}

pub struct ServiceCommunicationSecurity {
    service_key: hmac::Key,
    token_cache: HashMap<String, ServiceToken>,
}

impl ServiceCommunicationSecurity {
    pub fn new(service_key: &[u8]) -> Self {
        Self {
            service_key: hmac::Key::new(hmac::HMAC_SHA256, service_key),
            token_cache: HashMap::new(),
        }
    }
    
    pub fn generate_service_token(
        &self,
        service_id: &str,
        target_service: &str,
        permissions: Vec<String>,
        ttl_seconds: u64,
    ) -> Result<ServiceToken, SecurityError> {
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
        let expires_at = now + ttl_seconds;
        
        // 生成随机nonce
        let mut nonce_bytes = [0u8; 16];
        rand::SystemRandom::new().fill(&mut nonce_bytes).unwrap();
        let nonce = general_purpose::STANDARD.encode(nonce_bytes);
        
        let token = ServiceToken {
            service_id: service_id.to_string(),
            target_service: target_service.to_string(),
            permissions,
            expires_at,
            issued_at: now,
            nonce,
            signature: String::new(), // 将在下面计算
        };
        
        // 计算签名
        let signature = self.sign_token(&token)?;
        
        Ok(ServiceToken {
            signature,
            ..token
        })
    }
    
    pub fn verify_service_token(&self, token: &ServiceToken) -> Result<bool, SecurityError> {
        // 1. 检查过期时间
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
        if token.expires_at < now {
            return Ok(false);
        }
        
        // 2. 验证签名
        let expected_signature = self.sign_token(token)?;
        if token.signature != expected_signature {
            return Ok(false);
        }
        
        // 3. 检查nonce是否已使用（防重放攻击）
        if self.token_cache.contains_key(&token.nonce) {
            return Ok(false);
        }
        
        // 4. 缓存token（防重放）
        self.token_cache.insert(token.nonce.clone(), token.clone());
        
        Ok(true)
    }
    
    fn sign_token(&self, token: &ServiceToken) -> Result<String, SecurityError> {
        // 创建待签名的数据
        let mut data = Vec::new();
        data.extend_from_slice(token.service_id.as_bytes());
        data.extend_from_slice(token.target_service.as_bytes());
        data.extend_from_slice(&token.expires_at.to_be_bytes());
        data.extend_from_slice(&token.issued_at.to_be_bytes());
        data.extend_from_slice(token.nonce.as_bytes());
        
        // 添加权限
        for permission in &token.permissions {
            data.extend_from_slice(permission.as_bytes());
        }
        
        // 计算HMAC签名
        let signature = hmac::sign(&self.service_key, &data);
        Ok(general_purpose::STANDARD.encode(signature.as_ref()))
    }
    
    pub fn encrypt_message(&self, message: &[u8], key: &[u8]) -> Result<Vec<u8>, SecurityError> {
        use aes_gcm::{Aes256Gcm, Key, Nonce};
        use aes_gcm::aead::{Aead, NewAead};
        
        let cipher = Aes256Gcm::new(Key::from_slice(key));
        let nonce = Nonce::from_slice(&[0u8; 12]); // 实际应用中应使用随机nonce
        
        cipher.encrypt(nonce, message)
            .map_err(|e| SecurityError::EncryptionError(e.to_string()))
    }
    
    pub fn decrypt_message(&self, encrypted: &[u8], key: &[u8]) -> Result<Vec<u8>, SecurityError> {
        use aes_gcm::{Aes256Gcm, Key, Nonce};
        use aes_gcm::aead::{Aead, NewAead};
        
        let cipher = Aes256Gcm::new(Key::from_slice(key));
        let nonce = Nonce::from_slice(&[0u8; 12]); // 实际应用中应使用随机nonce
        
        cipher.decrypt(nonce, encrypted)
            .map_err(|e| SecurityError::DecryptionError(e.to_string()))
    }
}

#[derive(Debug, thiserror::Error)]
pub enum SecurityError {
    #[error("Encryption error: {0}")]
    EncryptionError(String),
    #[error("Decryption error: {0}")]
    DecryptionError(String),
    #[error("Signature verification failed")]
    SignatureVerificationFailed,
    #[error("Token expired")]
    TokenExpired,
    #[error("Invalid token format")]
    InvalidTokenFormat,
}
```

### 4. 数据加密与保护

```rust
// src/security/data_protection.rs
use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use ring::{digest, pbkdf2, rand};
use aes_gcm::{Aes256Gcm, Key, Nonce};
use aes_gcm::aead::{Aead, NewAead};

#[derive(Debug, Serialize, Deserialize)]
pub struct EncryptedData {
    pub ciphertext: String,
    pub nonce: String,
    pub salt: String,
    pub key_id: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DataClassification {
    pub level: ClassificationLevel,
    pub categories: Vec<String>,
    pub retention_period: Option<u64>,
    pub encryption_required: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum ClassificationLevel {
    Public,
    Internal,
    Confidential,
    Restricted,
}

pub struct DataProtectionService {
    encryption_keys: HashMap<String, Vec<u8>>,
    classification_rules: HashMap<String, DataClassification>,
}

impl DataProtectionService {
    pub fn new() -> Self {
        Self {
            encryption_keys: HashMap::new(),
            classification_rules: HashMap::new(),
        }
    }
    
    pub fn add_encryption_key(&mut self, key_id: String, key: Vec<u8>) {
        self.encryption_keys.insert(key_id, key);
    }
    
    pub fn add_classification_rule(&mut self, pattern: String, classification: DataClassification) {
        self.classification_rules.insert(pattern, classification);
    }
    
    pub fn encrypt_data(&self, data: &[u8], key_id: &str) -> Result<EncryptedData, SecurityError> {
        let key = self.encryption_keys.get(key_id)
            .ok_or_else(|| SecurityError::KeyNotFound(key_id.to_string()))?;
        
        // 生成随机salt
        let mut salt = [0u8; 16];
        rand::SystemRandom::new().fill(&mut salt).unwrap();
        
        // 生成随机nonce
        let mut nonce_bytes = [0u8; 12];
        rand::SystemRandom::new().fill(&mut nonce_bytes).unwrap();
        
        // 创建加密器
        let cipher = Aes256Gcm::new(Key::from_slice(key));
        let nonce = Nonce::from_slice(&nonce_bytes);
        
        // 加密数据
        let ciphertext = cipher.encrypt(nonce, data)
            .map_err(|e| SecurityError::EncryptionError(e.to_string()))?;
        
        Ok(EncryptedData {
            ciphertext: base64::encode(ciphertext),
            nonce: base64::encode(nonce_bytes),
            salt: base64::encode(salt),
            key_id: key_id.to_string(),
        })
    }
    
    pub fn decrypt_data(&self, encrypted_data: &EncryptedData) -> Result<Vec<u8>, SecurityError> {
        let key = self.encryption_keys.get(&encrypted_data.key_id)
            .ok_or_else(|| SecurityError::KeyNotFound(encrypted_data.key_id.clone()))?;
        
        // 解码数据
        let ciphertext = base64::decode(&encrypted_data.ciphertext)
            .map_err(|e| SecurityError::DecodingError(e.to_string()))?;
        
        let nonce_bytes = base64::decode(&encrypted_data.nonce)
            .map_err(|e| SecurityError::DecodingError(e.to_string()))?;
        
        // 创建解密器
        let cipher = Aes256Gcm::new(Key::from_slice(key));
        let nonce = Nonce::from_slice(&nonce_bytes);
        
        // 解密数据
        cipher.decrypt(nonce, &ciphertext)
            .map_err(|e| SecurityError::DecryptionError(e.to_string()))
    }
    
    pub fn classify_data(&self, data: &str) -> DataClassification {
        // 根据分类规则对数据进行分类
        for (pattern, classification) in &self.classification_rules {
            if data.contains(pattern) {
                return classification.clone();
            }
        }
        
        // 默认分类
        DataClassification {
            level: ClassificationLevel::Internal,
            categories: vec!["general".to_string()],
            retention_period: Some(365 * 24 * 60 * 60), // 1年
            encryption_required: true,
        }
    }
    
    pub fn hash_sensitive_data(&self, data: &str) -> String {
        use ring::digest;
        
        let hash = digest::digest(&digest::SHA256, data.as_bytes());
        hex::encode(hash.as_ref())
    }
    
    pub fn mask_sensitive_data(&self, data: &str, mask_char: char) -> String {
        if data.len() <= 4 {
            return mask_char.to_string().repeat(data.len());
        }
        
        let visible_chars = 2;
        let masked_chars = data.len() - visible_chars;
        
        format!("{}{}", 
            &data[..visible_chars],
            mask_char.to_string().repeat(masked_chars)
        )
    }
}

#[derive(Debug, thiserror::Error)]
pub enum SecurityError {
    #[error("Key not found: {0}")]
    KeyNotFound(String),
    #[error("Encryption error: {0}")]
    EncryptionError(String),
    #[error("Decryption error: {0}")]
    DecryptionError(String),
    #[error("Decoding error: {0}")]
    DecodingError(String),
}
```

## 📖 最佳实践

### 1. 安全配置管理

```rust
// src/security/config.rs
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize)]
pub struct SecurityConfig {
    pub authentication: AuthenticationConfig,
    pub authorization: AuthorizationConfig,
    pub encryption: EncryptionConfig,
    pub monitoring: MonitoringConfig,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AuthenticationConfig {
    pub jwt_secret: String,
    pub token_expiry: u64,
    pub refresh_token_expiry: u64,
    pub mfa_required: bool,
    pub password_policy: PasswordPolicy,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PasswordPolicy {
    pub min_length: usize,
    pub require_uppercase: bool,
    pub require_lowercase: bool,
    pub require_numbers: bool,
    pub require_special_chars: bool,
    pub max_age_days: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AuthorizationConfig {
    pub rbac_enabled: bool,
    pub abac_enabled: bool,
    pub policy_cache_ttl: u64,
    pub default_deny: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct EncryptionConfig {
    pub algorithm: String,
    pub key_size: usize,
    pub key_rotation_days: u64,
    pub encryption_at_rest: bool,
    pub encryption_in_transit: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MonitoringConfig {
    pub audit_logging: bool,
    pub threat_detection: bool,
    pub anomaly_detection: bool,
    pub alert_thresholds: HashMap<String, f64>,
}

impl SecurityConfig {
    pub fn from_env() -> Result<Self, ConfigError> {
        // 从环境变量加载安全配置
        Ok(SecurityConfig {
            authentication: AuthenticationConfig {
                jwt_secret: std::env::var("JWT_SECRET")?,
                token_expiry: std::env::var("TOKEN_EXPIRY")?.parse()?,
                refresh_token_expiry: std::env::var("REFRESH_TOKEN_EXPIRY")?.parse()?,
                mfa_required: std::env::var("MFA_REQUIRED")?.parse()?,
                password_policy: PasswordPolicy {
                    min_length: std::env::var("PASSWORD_MIN_LENGTH")?.parse()?,
                    require_uppercase: std::env::var("PASSWORD_REQUIRE_UPPERCASE")?.parse()?,
                    require_lowercase: std::env::var("PASSWORD_REQUIRE_LOWERCASE")?.parse()?,
                    require_numbers: std::env::var("PASSWORD_REQUIRE_NUMBERS")?.parse()?,
                    require_special_chars: std::env::var("PASSWORD_REQUIRE_SPECIAL")?.parse()?,
                    max_age_days: std::env::var("PASSWORD_MAX_AGE")?.parse()?,
                },
            },
            authorization: AuthorizationConfig {
                rbac_enabled: std::env::var("RBAC_ENABLED")?.parse()?,
                abac_enabled: std::env::var("ABAC_ENABLED")?.parse()?,
                policy_cache_ttl: std::env::var("POLICY_CACHE_TTL")?.parse()?,
                default_deny: std::env::var("DEFAULT_DENY")?.parse()?,
            },
            encryption: EncryptionConfig {
                algorithm: std::env::var("ENCRYPTION_ALGORITHM")?,
                key_size: std::env::var("ENCRYPTION_KEY_SIZE")?.parse()?,
                key_rotation_days: std::env::var("KEY_ROTATION_DAYS")?.parse()?,
                encryption_at_rest: std::env::var("ENCRYPTION_AT_REST")?.parse()?,
                encryption_in_transit: std::env::var("ENCRYPTION_IN_TRANSIT")?.parse()?,
            },
            monitoring: MonitoringConfig {
                audit_logging: std::env::var("AUDIT_LOGGING")?.parse()?,
                threat_detection: std::env::var("THREAT_DETECTION")?.parse()?,
                anomaly_detection: std::env::var("ANOMALY_DETECTION")?.parse()?,
                alert_thresholds: HashMap::new(), // 从配置文件加载
            },
        })
    }
}

#[derive(Debug, thiserror::Error)]
pub enum ConfigError {
    #[error("Environment variable not found: {0}")]
    EnvVarNotFound(String),
    #[error("Invalid configuration value: {0}")]
    InvalidValue(String),
}
```

### 2. 安全中间件

```rust
// src/security/middleware.rs
use axum::{
    extract::{Request, State},
    middleware::Next,
    response::Response,
    http::{StatusCode, HeaderMap},
};
use std::sync::Arc;
use tracing::{info, warn, error};

pub struct SecurityMiddleware {
    auth_service: Arc<AuthenticationService>,
    access_control: Arc<AccessControlService>,
    audit_logger: Arc<AuditLogger>,
}

impl SecurityMiddleware {
    pub fn new(
        auth_service: Arc<AuthenticationService>,
        access_control: Arc<AccessControlService>,
        audit_logger: Arc<AuditLogger>,
    ) -> Self {
        Self {
            auth_service,
            access_control,
            audit_logger,
        }
    }
    
    pub async fn authenticate_and_authorize(
        State(security): State<Arc<SecurityMiddleware>>,
        headers: HeaderMap,
        request: Request,
        next: Next,
    ) -> Result<Response, StatusCode> {
        let start_time = std::time::Instant::now();
        
        // 1. 提取和验证令牌
        let token = security.extract_token(&headers)?;
        let claims = security.auth_service.validate_token(&token)
            .map_err(|_| StatusCode::UNAUTHORIZED)?;
        
        // 2. 构建访问请求
        let access_request = AccessRequest {
            subject: claims.sub,
            resource: request.uri().path().to_string(),
            action: request.method().to_string(),
            context: security.build_context(&claims, &headers, &request),
        };
        
        // 3. 执行授权检查
        let decision = security.access_control.authorize(access_request).await
            .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
        
        if matches!(decision.decision, Effect::Deny) {
            security.audit_logger.log_access_denied(&decision).await;
            return Err(StatusCode::FORBIDDEN);
        }
        
        // 4. 记录访问日志
        security.audit_logger.log_access_granted(&decision).await;
        
        // 5. 继续处理请求
        let response = next.run(request).await;
        
        // 6. 记录响应时间
        let duration = start_time.elapsed();
        security.audit_logger.log_response_time(duration).await;
        
        Ok(response)
    }
    
    fn extract_token(&self, headers: &HeaderMap) -> Result<String, StatusCode> {
        let auth_header = headers.get("Authorization")
            .ok_or(StatusCode::UNAUTHORIZED)?
            .to_str()
            .map_err(|_| StatusCode::UNAUTHORIZED)?;
        
        if !auth_header.starts_with("Bearer ") {
            return Err(StatusCode::UNAUTHORIZED);
        }
        
        Ok(auth_header[7..].to_string())
    }
    
    fn build_context(
        &self,
        claims: &Claims,
        headers: &HeaderMap,
        request: &Request,
    ) -> HashMap<String, serde_json::Value> {
        let mut context = HashMap::new();
        
        context.insert("user_id".to_string(), serde_json::Value::String(claims.sub.clone()));
        context.insert("roles".to_string(), serde_json::to_value(&claims.roles).unwrap());
        context.insert("permissions".to_string(), serde_json::to_value(&claims.permissions).unwrap());
        context.insert("device_id".to_string(), serde_json::Value::String(claims.device_id.clone()));
        context.insert("session_id".to_string(), serde_json::Value::String(claims.session_id.clone()));
        
        // 添加请求上下文
        if let Some(ip) = headers.get("X-Forwarded-For") {
            context.insert("client_ip".to_string(), serde_json::Value::String(ip.to_str().unwrap_or("").to_string()));
        }
        
        if let Some(user_agent) = headers.get("User-Agent") {
            context.insert("user_agent".to_string(), serde_json::Value::String(user_agent.to_str().unwrap_or("").to_string()));
        }
        
        context.insert("request_time".to_string(), serde_json::Value::String(chrono::Utc::now().to_rfc3339()));
        
        context
    }
}

pub struct AuditLogger;

impl AuditLogger {
    pub async fn log_access_granted(&self, decision: &AccessDecision) {
        info!("Access granted: {:?}", decision);
        // 实现审计日志记录
    }
    
    pub async fn log_access_denied(&self, decision: &AccessDecision) {
        warn!("Access denied: {:?}", decision);
        // 实现审计日志记录
    }
    
    pub async fn log_response_time(&self, duration: std::time::Duration) {
        info!("Response time: {:?}", duration);
        // 实现性能日志记录
    }
}
```

通过本指南，您可以实现完整的零信任架构，确保微服务环境下的安全性和合规性。
