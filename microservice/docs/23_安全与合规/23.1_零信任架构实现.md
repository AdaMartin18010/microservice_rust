# é›¶ä¿¡ä»»æ¶æ„å®ç°

> åŸºäºRust 1.90çš„å¾®æœåŠ¡é›¶ä¿¡ä»»å®‰å…¨æ¶æ„è®¾è®¡ä¸å®ç°

## ğŸ“‹ æ¦‚è¿°

é›¶ä¿¡ä»»æ¶æ„æ˜¯ä¸€ç§å®‰å…¨æ¨¡å‹ï¼Œå®ƒå‡è®¾ç½‘ç»œå†…å¤–éƒ½ä¸å­˜åœ¨å¯ä¿¡ä»»çš„è¾¹ç•Œï¼Œè¦æ±‚å¯¹æ‰€æœ‰è®¿é—®è¯·æ±‚è¿›è¡ŒéªŒè¯å’Œæˆæƒã€‚æœ¬æŒ‡å—å°†ä»‹ç»å¦‚ä½•åœ¨Rustå¾®æœåŠ¡ä¸­å®ç°é›¶ä¿¡ä»»æ¶æ„ï¼ŒåŒ…æ‹¬èº«ä»½éªŒè¯ã€æˆæƒã€åŠ å¯†ã€ç›‘æ§ç­‰æ ¸å¿ƒå®‰å…¨ç»„ä»¶ã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

- ç†è§£é›¶ä¿¡ä»»æ¶æ„çš„æ ¸å¿ƒåŸåˆ™å’Œè®¾è®¡ç†å¿µ
- æŒæ¡å¾®æœåŠ¡ç¯å¢ƒä¸‹çš„èº«ä»½è®¤è¯å’Œæˆæƒæœºåˆ¶
- å­¦ä¼šå®ç°æœåŠ¡é—´é€šä¿¡çš„å®‰å…¨åŠ å¯†
- äº†è§£å®‰å…¨ç›‘æ§å’Œå¨èƒæ£€æµ‹çš„å®ç°æ–¹æ³•

## ğŸ“š å†…å®¹å¤§çº²

## ğŸ”§ åŸºç¡€æ¦‚å¿µ

### é›¶ä¿¡ä»»æ¶æ„æ¨¡å‹

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        é›¶ä¿¡ä»»æ¶æ„å±‚æ¬¡                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ èº«ä»½å±‚ (Identity Layer)             â”‚
â”‚  â”œâ”€ å¤šå› ç´ è®¤è¯ (MFA)                â”‚
â”‚  â”œâ”€ å•ç‚¹ç™»å½• (SSO)                  â”‚
â”‚  â””â”€ èº«ä»½æä¾›è€… (IdP)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ è®¾å¤‡å±‚ (Device Layer)               â”‚
â”‚  â”œâ”€ è®¾å¤‡è®¤è¯                        â”‚
â”‚  â”œâ”€ è®¾å¤‡åˆè§„æ£€æŸ¥                    â”‚
â”‚  â””â”€ è®¾å¤‡ä¿¡ä»»è¯„ä¼°                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ç½‘ç»œå±‚ (Network Layer)              â”‚
â”‚  â”œâ”€ ç½‘ç»œåˆ†æ®µ                        â”‚
â”‚  â”œâ”€ å¾®éš”ç¦»                          â”‚
â”‚  â””â”€ æµé‡åŠ å¯†                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ åº”ç”¨å±‚ (Application Layer)          â”‚
â”‚  â”œâ”€ åº”ç”¨è®¤è¯                        â”‚
â”‚  â”œâ”€ APIå®‰å…¨                         â”‚
â”‚  â””â”€ æ•°æ®ä¿æŠ¤                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æ•°æ®å±‚ (Data Layer)                 â”‚
â”‚  â”œâ”€ æ•°æ®åˆ†ç±»                        â”‚
â”‚  â”œâ”€ æ•°æ®åŠ å¯†                        â”‚
â”‚  â””â”€ æ•°æ®è®¿é—®æ§åˆ¶                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒåŸåˆ™

1. **æ°¸ä¸ä¿¡ä»»ï¼Œå§‹ç»ˆéªŒè¯** (Never Trust, Always Verify)
2. **æœ€å°æƒé™åŸåˆ™** (Principle of Least Privilege)
3. **å‡è®¾è¿è§„** (Assume Breach)
4. **æŒç»­ç›‘æ§** (Continuous Monitoring)
5. **åŠ¨æ€è®¿é—®æ§åˆ¶** (Dynamic Access Control)

## ğŸ› ï¸ é›¶ä¿¡ä»»åŸåˆ™

### 1. èº«ä»½éªŒè¯ç³»ç»Ÿ

```rust
// src/identity/authentication.rs
use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: String,        // ç”¨æˆ·ID
    pub iss: String,        // å‘è¡Œè€…
    pub aud: String,        // å—ä¼—
    pub exp: usize,         // è¿‡æœŸæ—¶é—´
    pub iat: usize,         // ç­¾å‘æ—¶é—´
    pub nbf: usize,         // ç”Ÿæ•ˆæ—¶é—´
    pub jti: String,        // JWT ID
    pub roles: Vec<String>, // ç”¨æˆ·è§’è‰²
    pub permissions: Vec<String>, // ç”¨æˆ·æƒé™
    pub device_id: String,  // è®¾å¤‡ID
    pub session_id: String, // ä¼šè¯ID
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AuthenticationRequest {
    pub username: String,
    pub password: String,
    pub device_id: String,
    pub mfa_code: Option<String>,
    pub biometric_data: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AuthenticationResponse {
    pub access_token: String,
    pub refresh_token: String,
    pub token_type: String,
    pub expires_in: u64,
    pub scope: Vec<String>,
}

pub struct AuthenticationService {
    encoding_key: EncodingKey,
    decoding_key: DecodingKey,
    validation: Validation,
    secret: String,
}

impl AuthenticationService {
    pub fn new(secret: String) -> Self {
        let encoding_key = EncodingKey::from_secret(secret.as_ref());
        let decoding_key = DecodingKey::from_secret(secret.as_ref());
        
        let mut validation = Validation::new(Algorithm::HS256);
        validation.set_issuer(&["microservice-auth"]);
        validation.set_audience(&["microservice-api"]);
        
        Self {
            encoding_key,
            decoding_key,
            validation,
            secret,
        }
    }
    
    pub async fn authenticate(&self, request: AuthenticationRequest) -> Result<AuthenticationResponse, AuthError> {
        // 1. éªŒè¯ç”¨æˆ·åå’Œå¯†ç 
        let user = self.verify_credentials(&request.username, &request.password).await?;
        
        // 2. éªŒè¯è®¾å¤‡
        self.verify_device(&request.device_id, &user.id).await?;
        
        // 3. å¤šå› ç´ è®¤è¯
        if let Some(mfa_code) = request.mfa_code {
            self.verify_mfa(&user.id, &mfa_code).await?;
        }
        
        // 4. ç”Ÿç‰©è¯†åˆ«éªŒè¯
        if let Some(biometric) = request.biometric_data {
            self.verify_biometric(&user.id, &biometric).await?;
        }
        
        // 5. ç”Ÿæˆè®¿é—®ä»¤ç‰Œ
        let access_token = self.generate_access_token(&user).await?;
        let refresh_token = self.generate_refresh_token(&user).await?;
        
        Ok(AuthenticationResponse {
            access_token,
            refresh_token,
            token_type: "Bearer".to_string(),
            expires_in: 3600, // 1å°æ—¶
            scope: user.permissions.clone(),
        })
    }
    
    async fn verify_credentials(&self, username: &str, password: &str) -> Result<User, AuthError> {
        // å®ç°å¯†ç éªŒè¯é€»è¾‘
        // åŒ…æ‹¬å¯†ç å“ˆå¸ŒéªŒè¯ã€è´¦æˆ·é”å®šæ£€æŸ¥ç­‰
        todo!()
    }
    
    async fn verify_device(&self, device_id: &str, user_id: &str) -> Result<(), AuthError> {
        // å®ç°è®¾å¤‡éªŒè¯é€»è¾‘
        // åŒ…æ‹¬è®¾å¤‡æ³¨å†Œæ£€æŸ¥ã€è®¾å¤‡åˆè§„æ€§éªŒè¯ç­‰
        todo!()
    }
    
    async fn verify_mfa(&self, user_id: &str, mfa_code: &str) -> Result<(), AuthError> {
        // å®ç°å¤šå› ç´ è®¤è¯éªŒè¯
        // æ”¯æŒTOTPã€SMSã€é‚®ä»¶ç­‰å¤šç§æ–¹å¼
        todo!()
    }
    
    async fn verify_biometric(&self, user_id: &str, biometric_data: &str) -> Result<(), AuthError> {
        // å®ç°ç”Ÿç‰©è¯†åˆ«éªŒè¯
        // åŒ…æ‹¬æŒ‡çº¹ã€é¢éƒ¨è¯†åˆ«ç­‰
        todo!()
    }
    
    async fn generate_access_token(&self, user: &User) -> Result<String, AuthError> {
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as usize;
        
        let claims = Claims {
            sub: user.id.clone(),
            iss: "microservice-auth".to_string(),
            aud: "microservice-api".to_string(),
            exp: now + 3600, // 1å°æ—¶åè¿‡æœŸ
            iat: now,
            nbf: now,
            jti: Uuid::new_v4().to_string(),
            roles: user.roles.clone(),
            permissions: user.permissions.clone(),
            device_id: user.device_id.clone(),
            session_id: Uuid::new_v4().to_string(),
        };
        
        encode(&Header::new(Algorithm::HS256), &claims, &self.encoding_key)
            .map_err(|e| AuthError::TokenGeneration(e.to_string()))
    }
    
    async fn generate_refresh_token(&self, user: &User) -> Result<String, AuthError> {
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as usize;
        
        let claims = Claims {
            sub: user.id.clone(),
            iss: "microservice-auth".to_string(),
            aud: "microservice-api".to_string(),
            exp: now + 86400 * 7, // 7å¤©åè¿‡æœŸ
            iat: now,
            nbf: now,
            jti: Uuid::new_v4().to_string(),
            roles: user.roles.clone(),
            permissions: user.permissions.clone(),
            device_id: user.device_id.clone(),
            session_id: Uuid::new_v4().to_string(),
        };
        
        encode(&Header::new(Algorithm::HS256), &claims, &self.encoding_key)
            .map_err(|e| AuthError::TokenGeneration(e.to_string()))
    }
    
    pub fn validate_token(&self, token: &str) -> Result<Claims, AuthError> {
        decode::<Claims>(token, &self.decoding_key, &self.validation)
            .map(|data| data.claims)
            .map_err(|e| AuthError::TokenValidation(e.to_string()))
    }
}

#[derive(Debug)]
pub struct User {
    pub id: String,
    pub username: String,
    pub email: String,
    pub roles: Vec<String>,
    pub permissions: Vec<String>,
    pub device_id: String,
    pub is_active: bool,
    pub last_login: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, thiserror::Error)]
pub enum AuthError {
    #[error("Invalid credentials")]
    InvalidCredentials,
    #[error("Account locked")]
    AccountLocked,
    #[error("Device not registered")]
    DeviceNotRegistered,
    #[error("MFA verification failed")]
    MfaVerificationFailed,
    #[error("Biometric verification failed")]
    BiometricVerificationFailed,
    #[error("Token generation failed: {0}")]
    TokenGeneration(String),
    #[error("Token validation failed: {0}")]
    TokenValidation(String),
}
```

### 2. æˆæƒä¸è®¿é—®æ§åˆ¶

```rust
// src/authorization/access_control.rs
use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use tracing::{info, warn, error};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Policy {
    pub id: String,
    pub name: String,
    pub description: String,
    pub rules: Vec<Rule>,
    pub conditions: Vec<Condition>,
    pub effect: Effect,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Rule {
    pub id: String,
    pub resource: String,
    pub action: String,
    pub conditions: Vec<Condition>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Condition {
    pub attribute: String,
    pub operator: Operator,
    pub value: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Operator {
    Equals,
    NotEquals,
    In,
    NotIn,
    GreaterThan,
    LessThan,
    Contains,
    StartsWith,
    EndsWith,
    Regex,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Effect {
    Allow,
    Deny,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AccessRequest {
    pub subject: String,      // ç”¨æˆ·ID
    pub resource: String,     // èµ„æº
    pub action: String,       // æ“ä½œ
    pub context: HashMap<String, serde_json::Value>, // ä¸Šä¸‹æ–‡ä¿¡æ¯
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AccessDecision {
    pub decision: Effect,
    pub reason: String,
    pub policies: Vec<String>,
    pub conditions_met: Vec<String>,
    pub conditions_failed: Vec<String>,
}

pub struct AccessControlService {
    policies: HashMap<String, Policy>,
    policy_engine: PolicyEngine,
}

impl AccessControlService {
    pub fn new() -> Self {
        Self {
            policies: HashMap::new(),
            policy_engine: PolicyEngine::new(),
        }
    }
    
    pub fn add_policy(&mut self, policy: Policy) {
        self.policies.insert(policy.id.clone(), policy);
    }
    
    pub async fn authorize(&self, request: AccessRequest) -> Result<AccessDecision, AuthError> {
        info!("å¤„ç†è®¿é—®è¯·æ±‚: {:?}", request);
        
        // 1. è·å–é€‚ç”¨çš„ç­–ç•¥
        let applicable_policies = self.get_applicable_policies(&request).await;
        
        if applicable_policies.is_empty() {
            return Ok(AccessDecision {
                decision: Effect::Deny,
                reason: "No applicable policies found".to_string(),
                policies: vec![],
                conditions_met: vec![],
                conditions_failed: vec![],
            });
        }
        
        // 2. è¯„ä¼°ç­–ç•¥
        let mut decision = AccessDecision {
            decision: Effect::Deny,
            reason: "Default deny".to_string(),
            policies: vec![],
            conditions_met: vec![],
            conditions_failed: vec![],
        };
        
        for policy in applicable_policies {
            let policy_decision = self.policy_engine.evaluate_policy(&policy, &request).await;
            
            match policy_decision.decision {
                Effect::Allow => {
                    decision.decision = Effect::Allow;
                    decision.reason = format!("Policy {} allows access", policy.name);
                    decision.policies.push(policy.id.clone());
                    decision.conditions_met.extend(policy_decision.conditions_met);
                    break; // ç¬¬ä¸€ä¸ªAllowç­–ç•¥ç”Ÿæ•ˆ
                }
                Effect::Deny => {
                    decision.decision = Effect::Deny;
                    decision.reason = format!("Policy {} denies access", policy.name);
                    decision.policies.push(policy.id.clone());
                    decision.conditions_failed.extend(policy_decision.conditions_failed);
                    break; // ç¬¬ä¸€ä¸ªDenyç­–ç•¥ç”Ÿæ•ˆ
                }
            }
        }
        
        info!("è®¿é—®å†³ç­–: {:?}", decision);
        Ok(decision)
    }
    
    async fn get_applicable_policies(&self, request: &AccessRequest) -> Vec<&Policy> {
        self.policies
            .values()
            .filter(|policy| self.is_policy_applicable(policy, request))
            .collect()
    }
    
    fn is_policy_applicable(&self, policy: &Policy, request: &AccessRequest) -> bool {
        // æ£€æŸ¥ç­–ç•¥æ˜¯å¦é€‚ç”¨äºå½“å‰è¯·æ±‚
        policy.rules.iter().any(|rule| {
            self.matches_resource(rule, &request.resource) &&
            self.matches_action(rule, &request.action)
        })
    }
    
    fn matches_resource(&self, rule: &Rule, resource: &str) -> bool {
        // å®ç°èµ„æºåŒ¹é…é€»è¾‘
        // æ”¯æŒé€šé…ç¬¦ã€æ­£åˆ™è¡¨è¾¾å¼ç­‰
        rule.resource == resource || 
        rule.resource.ends_with("*") && resource.starts_with(&rule.resource[..rule.resource.len()-1])
    }
    
    fn matches_action(&self, rule: &Rule, action: &str) -> bool {
        // å®ç°æ“ä½œåŒ¹é…é€»è¾‘
        rule.action == action || rule.action == "*"
    }
}

pub struct PolicyEngine {
    condition_evaluator: ConditionEvaluator,
}

impl PolicyEngine {
    pub fn new() -> Self {
        Self {
            condition_evaluator: ConditionEvaluator::new(),
        }
    }
    
    pub async fn evaluate_policy(&self, policy: &Policy, request: &AccessRequest) -> AccessDecision {
        let mut conditions_met = Vec::new();
        let mut conditions_failed = Vec::new();
        
        // è¯„ä¼°ç­–ç•¥æ¡ä»¶
        for condition in &policy.conditions {
            if self.condition_evaluator.evaluate(condition, &request.context).await {
                conditions_met.push(condition.attribute.clone());
            } else {
                conditions_failed.push(condition.attribute.clone());
            }
        }
        
        // è¯„ä¼°è§„åˆ™
        for rule in &policy.rules {
            let rule_conditions_met = self.evaluate_rule_conditions(rule, &request.context).await;
            if rule_conditions_met.is_empty() {
                continue;
            }
            
            conditions_met.extend(rule_conditions_met);
        }
        
        AccessDecision {
            decision: policy.effect.clone(),
            reason: format!("Policy {} evaluated", policy.name),
            policies: vec![policy.id.clone()],
            conditions_met,
            conditions_failed,
        }
    }
    
    async fn evaluate_rule_conditions(&self, rule: &Rule, context: &HashMap<String, serde_json::Value>) -> Vec<String> {
        let mut conditions_met = Vec::new();
        
        for condition in &rule.conditions {
            if self.condition_evaluator.evaluate(condition, context).await {
                conditions_met.push(condition.attribute.clone());
            }
        }
        
        conditions_met
    }
}

pub struct ConditionEvaluator;

impl ConditionEvaluator {
    pub fn new() -> Self {
        Self
    }
    
    pub async fn evaluate(&self, condition: &Condition, context: &HashMap<String, serde_json::Value>) -> bool {
        let attribute_value = context.get(&condition.attribute);
        
        match attribute_value {
            Some(value) => self.compare_values(value, &condition.operator, &condition.value),
            None => false,
        }
    }
    
    fn compare_values(&self, actual: &serde_json::Value, operator: &Operator, expected: &serde_json::Value) -> bool {
        match operator {
            Operator::Equals => actual == expected,
            Operator::NotEquals => actual != expected,
            Operator::In => {
                if let Some(array) = expected.as_array() {
                    array.contains(actual)
                } else {
                    false
                }
            }
            Operator::NotIn => {
                if let Some(array) = expected.as_array() {
                    !array.contains(actual)
                } else {
                    true
                }
            }
            Operator::GreaterThan => {
                if let (Some(a), Some(e)) = (actual.as_f64(), expected.as_f64()) {
                    a > e
                } else {
                    false
                }
            }
            Operator::LessThan => {
                if let (Some(a), Some(e)) = (actual.as_f64(), expected.as_f64()) {
                    a < e
                } else {
                    false
                }
            }
            Operator::Contains => {
                if let (Some(a), Some(e)) = (actual.as_str(), expected.as_str()) {
                    a.contains(e)
                } else {
                    false
                }
            }
            Operator::StartsWith => {
                if let (Some(a), Some(e)) = (actual.as_str(), expected.as_str()) {
                    a.starts_with(e)
                } else {
                    false
                }
            }
            Operator::EndsWith => {
                if let (Some(a), Some(e)) = (actual.as_str(), expected.as_str()) {
                    a.ends_with(e)
                } else {
                    false
                }
            }
            Operator::Regex => {
                if let (Some(a), Some(e)) = (actual.as_str(), expected.as_str()) {
                    regex::Regex::new(e).map_or(false, |re| re.is_match(a))
                } else {
                    false
                }
            }
        }
    }
}
```

### 3. æœåŠ¡é—´é€šä¿¡å®‰å…¨

```rust
// src/security/service_communication.rs
use std::collections::HashMap;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Deserialize, Serialize};
use ring::{digest, hmac, rand};
use base64::{Engine as _, engine::general_purpose};

#[derive(Debug, Serialize, Deserialize)]
pub struct ServiceToken {
    pub service_id: String,
    pub target_service: String,
    pub permissions: Vec<String>,
    pub expires_at: u64,
    pub issued_at: u64,
    pub nonce: String,
    pub signature: String,
}

pub struct ServiceCommunicationSecurity {
    service_key: hmac::Key,
    token_cache: HashMap<String, ServiceToken>,
}

impl ServiceCommunicationSecurity {
    pub fn new(service_key: &[u8]) -> Self {
        Self {
            service_key: hmac::Key::new(hmac::HMAC_SHA256, service_key),
            token_cache: HashMap::new(),
        }
    }
    
    pub fn generate_service_token(
        &self,
        service_id: &str,
        target_service: &str,
        permissions: Vec<String>,
        ttl_seconds: u64,
    ) -> Result<ServiceToken, SecurityError> {
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
        let expires_at = now + ttl_seconds;
        
        // ç”Ÿæˆéšæœºnonce
        let mut nonce_bytes = [0u8; 16];
        rand::SystemRandom::new().fill(&mut nonce_bytes).unwrap();
        let nonce = general_purpose::STANDARD.encode(nonce_bytes);
        
        let token = ServiceToken {
            service_id: service_id.to_string(),
            target_service: target_service.to_string(),
            permissions,
            expires_at,
            issued_at: now,
            nonce,
            signature: String::new(), // å°†åœ¨ä¸‹é¢è®¡ç®—
        };
        
        // è®¡ç®—ç­¾å
        let signature = self.sign_token(&token)?;
        
        Ok(ServiceToken {
            signature,
            ..token
        })
    }
    
    pub fn verify_service_token(&self, token: &ServiceToken) -> Result<bool, SecurityError> {
        // 1. æ£€æŸ¥è¿‡æœŸæ—¶é—´
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
        if token.expires_at < now {
            return Ok(false);
        }
        
        // 2. éªŒè¯ç­¾å
        let expected_signature = self.sign_token(token)?;
        if token.signature != expected_signature {
            return Ok(false);
        }
        
        // 3. æ£€æŸ¥nonceæ˜¯å¦å·²ä½¿ç”¨ï¼ˆé˜²é‡æ”¾æ”»å‡»ï¼‰
        if self.token_cache.contains_key(&token.nonce) {
            return Ok(false);
        }
        
        // 4. ç¼“å­˜tokenï¼ˆé˜²é‡æ”¾ï¼‰
        self.token_cache.insert(token.nonce.clone(), token.clone());
        
        Ok(true)
    }
    
    fn sign_token(&self, token: &ServiceToken) -> Result<String, SecurityError> {
        // åˆ›å»ºå¾…ç­¾åçš„æ•°æ®
        let mut data = Vec::new();
        data.extend_from_slice(token.service_id.as_bytes());
        data.extend_from_slice(token.target_service.as_bytes());
        data.extend_from_slice(&token.expires_at.to_be_bytes());
        data.extend_from_slice(&token.issued_at.to_be_bytes());
        data.extend_from_slice(token.nonce.as_bytes());
        
        // æ·»åŠ æƒé™
        for permission in &token.permissions {
            data.extend_from_slice(permission.as_bytes());
        }
        
        // è®¡ç®—HMACç­¾å
        let signature = hmac::sign(&self.service_key, &data);
        Ok(general_purpose::STANDARD.encode(signature.as_ref()))
    }
    
    pub fn encrypt_message(&self, message: &[u8], key: &[u8]) -> Result<Vec<u8>, SecurityError> {
        use aes_gcm::{Aes256Gcm, Key, Nonce};
        use aes_gcm::aead::{Aead, NewAead};
        
        let cipher = Aes256Gcm::new(Key::from_slice(key));
        let nonce = Nonce::from_slice(&[0u8; 12]); // å®é™…åº”ç”¨ä¸­åº”ä½¿ç”¨éšæœºnonce
        
        cipher.encrypt(nonce, message)
            .map_err(|e| SecurityError::EncryptionError(e.to_string()))
    }
    
    pub fn decrypt_message(&self, encrypted: &[u8], key: &[u8]) -> Result<Vec<u8>, SecurityError> {
        use aes_gcm::{Aes256Gcm, Key, Nonce};
        use aes_gcm::aead::{Aead, NewAead};
        
        let cipher = Aes256Gcm::new(Key::from_slice(key));
        let nonce = Nonce::from_slice(&[0u8; 12]); // å®é™…åº”ç”¨ä¸­åº”ä½¿ç”¨éšæœºnonce
        
        cipher.decrypt(nonce, encrypted)
            .map_err(|e| SecurityError::DecryptionError(e.to_string()))
    }
}

#[derive(Debug, thiserror::Error)]
pub enum SecurityError {
    #[error("Encryption error: {0}")]
    EncryptionError(String),
    #[error("Decryption error: {0}")]
    DecryptionError(String),
    #[error("Signature verification failed")]
    SignatureVerificationFailed,
    #[error("Token expired")]
    TokenExpired,
    #[error("Invalid token format")]
    InvalidTokenFormat,
}
```

### 4. æ•°æ®åŠ å¯†ä¸ä¿æŠ¤

```rust
// src/security/data_protection.rs
use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use ring::{digest, pbkdf2, rand};
use aes_gcm::{Aes256Gcm, Key, Nonce};
use aes_gcm::aead::{Aead, NewAead};

#[derive(Debug, Serialize, Deserialize)]
pub struct EncryptedData {
    pub ciphertext: String,
    pub nonce: String,
    pub salt: String,
    pub key_id: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DataClassification {
    pub level: ClassificationLevel,
    pub categories: Vec<String>,
    pub retention_period: Option<u64>,
    pub encryption_required: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum ClassificationLevel {
    Public,
    Internal,
    Confidential,
    Restricted,
}

pub struct DataProtectionService {
    encryption_keys: HashMap<String, Vec<u8>>,
    classification_rules: HashMap<String, DataClassification>,
}

impl DataProtectionService {
    pub fn new() -> Self {
        Self {
            encryption_keys: HashMap::new(),
            classification_rules: HashMap::new(),
        }
    }
    
    pub fn add_encryption_key(&mut self, key_id: String, key: Vec<u8>) {
        self.encryption_keys.insert(key_id, key);
    }
    
    pub fn add_classification_rule(&mut self, pattern: String, classification: DataClassification) {
        self.classification_rules.insert(pattern, classification);
    }
    
    pub fn encrypt_data(&self, data: &[u8], key_id: &str) -> Result<EncryptedData, SecurityError> {
        let key = self.encryption_keys.get(key_id)
            .ok_or_else(|| SecurityError::KeyNotFound(key_id.to_string()))?;
        
        // ç”Ÿæˆéšæœºsalt
        let mut salt = [0u8; 16];
        rand::SystemRandom::new().fill(&mut salt).unwrap();
        
        // ç”Ÿæˆéšæœºnonce
        let mut nonce_bytes = [0u8; 12];
        rand::SystemRandom::new().fill(&mut nonce_bytes).unwrap();
        
        // åˆ›å»ºåŠ å¯†å™¨
        let cipher = Aes256Gcm::new(Key::from_slice(key));
        let nonce = Nonce::from_slice(&nonce_bytes);
        
        // åŠ å¯†æ•°æ®
        let ciphertext = cipher.encrypt(nonce, data)
            .map_err(|e| SecurityError::EncryptionError(e.to_string()))?;
        
        Ok(EncryptedData {
            ciphertext: base64::encode(ciphertext),
            nonce: base64::encode(nonce_bytes),
            salt: base64::encode(salt),
            key_id: key_id.to_string(),
        })
    }
    
    pub fn decrypt_data(&self, encrypted_data: &EncryptedData) -> Result<Vec<u8>, SecurityError> {
        let key = self.encryption_keys.get(&encrypted_data.key_id)
            .ok_or_else(|| SecurityError::KeyNotFound(encrypted_data.key_id.clone()))?;
        
        // è§£ç æ•°æ®
        let ciphertext = base64::decode(&encrypted_data.ciphertext)
            .map_err(|e| SecurityError::DecodingError(e.to_string()))?;
        
        let nonce_bytes = base64::decode(&encrypted_data.nonce)
            .map_err(|e| SecurityError::DecodingError(e.to_string()))?;
        
        // åˆ›å»ºè§£å¯†å™¨
        let cipher = Aes256Gcm::new(Key::from_slice(key));
        let nonce = Nonce::from_slice(&nonce_bytes);
        
        // è§£å¯†æ•°æ®
        cipher.decrypt(nonce, &ciphertext)
            .map_err(|e| SecurityError::DecryptionError(e.to_string()))
    }
    
    pub fn classify_data(&self, data: &str) -> DataClassification {
        // æ ¹æ®åˆ†ç±»è§„åˆ™å¯¹æ•°æ®è¿›è¡Œåˆ†ç±»
        for (pattern, classification) in &self.classification_rules {
            if data.contains(pattern) {
                return classification.clone();
            }
        }
        
        // é»˜è®¤åˆ†ç±»
        DataClassification {
            level: ClassificationLevel::Internal,
            categories: vec!["general".to_string()],
            retention_period: Some(365 * 24 * 60 * 60), // 1å¹´
            encryption_required: true,
        }
    }
    
    pub fn hash_sensitive_data(&self, data: &str) -> String {
        use ring::digest;
        
        let hash = digest::digest(&digest::SHA256, data.as_bytes());
        hex::encode(hash.as_ref())
    }
    
    pub fn mask_sensitive_data(&self, data: &str, mask_char: char) -> String {
        if data.len() <= 4 {
            return mask_char.to_string().repeat(data.len());
        }
        
        let visible_chars = 2;
        let masked_chars = data.len() - visible_chars;
        
        format!("{}{}", 
            &data[..visible_chars],
            mask_char.to_string().repeat(masked_chars)
        )
    }
}

#[derive(Debug, thiserror::Error)]
pub enum SecurityError {
    #[error("Key not found: {0}")]
    KeyNotFound(String),
    #[error("Encryption error: {0}")]
    EncryptionError(String),
    #[error("Decryption error: {0}")]
    DecryptionError(String),
    #[error("Decoding error: {0}")]
    DecodingError(String),
}
```

## ğŸ“– æœ€ä½³å®è·µ

### 1. å®‰å…¨é…ç½®ç®¡ç†

```rust
// src/security/config.rs
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize)]
pub struct SecurityConfig {
    pub authentication: AuthenticationConfig,
    pub authorization: AuthorizationConfig,
    pub encryption: EncryptionConfig,
    pub monitoring: MonitoringConfig,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AuthenticationConfig {
    pub jwt_secret: String,
    pub token_expiry: u64,
    pub refresh_token_expiry: u64,
    pub mfa_required: bool,
    pub password_policy: PasswordPolicy,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PasswordPolicy {
    pub min_length: usize,
    pub require_uppercase: bool,
    pub require_lowercase: bool,
    pub require_numbers: bool,
    pub require_special_chars: bool,
    pub max_age_days: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AuthorizationConfig {
    pub rbac_enabled: bool,
    pub abac_enabled: bool,
    pub policy_cache_ttl: u64,
    pub default_deny: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct EncryptionConfig {
    pub algorithm: String,
    pub key_size: usize,
    pub key_rotation_days: u64,
    pub encryption_at_rest: bool,
    pub encryption_in_transit: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MonitoringConfig {
    pub audit_logging: bool,
    pub threat_detection: bool,
    pub anomaly_detection: bool,
    pub alert_thresholds: HashMap<String, f64>,
}

impl SecurityConfig {
    pub fn from_env() -> Result<Self, ConfigError> {
        // ä»ç¯å¢ƒå˜é‡åŠ è½½å®‰å…¨é…ç½®
        Ok(SecurityConfig {
            authentication: AuthenticationConfig {
                jwt_secret: std::env::var("JWT_SECRET")?,
                token_expiry: std::env::var("TOKEN_EXPIRY")?.parse()?,
                refresh_token_expiry: std::env::var("REFRESH_TOKEN_EXPIRY")?.parse()?,
                mfa_required: std::env::var("MFA_REQUIRED")?.parse()?,
                password_policy: PasswordPolicy {
                    min_length: std::env::var("PASSWORD_MIN_LENGTH")?.parse()?,
                    require_uppercase: std::env::var("PASSWORD_REQUIRE_UPPERCASE")?.parse()?,
                    require_lowercase: std::env::var("PASSWORD_REQUIRE_LOWERCASE")?.parse()?,
                    require_numbers: std::env::var("PASSWORD_REQUIRE_NUMBERS")?.parse()?,
                    require_special_chars: std::env::var("PASSWORD_REQUIRE_SPECIAL")?.parse()?,
                    max_age_days: std::env::var("PASSWORD_MAX_AGE")?.parse()?,
                },
            },
            authorization: AuthorizationConfig {
                rbac_enabled: std::env::var("RBAC_ENABLED")?.parse()?,
                abac_enabled: std::env::var("ABAC_ENABLED")?.parse()?,
                policy_cache_ttl: std::env::var("POLICY_CACHE_TTL")?.parse()?,
                default_deny: std::env::var("DEFAULT_DENY")?.parse()?,
            },
            encryption: EncryptionConfig {
                algorithm: std::env::var("ENCRYPTION_ALGORITHM")?,
                key_size: std::env::var("ENCRYPTION_KEY_SIZE")?.parse()?,
                key_rotation_days: std::env::var("KEY_ROTATION_DAYS")?.parse()?,
                encryption_at_rest: std::env::var("ENCRYPTION_AT_REST")?.parse()?,
                encryption_in_transit: std::env::var("ENCRYPTION_IN_TRANSIT")?.parse()?,
            },
            monitoring: MonitoringConfig {
                audit_logging: std::env::var("AUDIT_LOGGING")?.parse()?,
                threat_detection: std::env::var("THREAT_DETECTION")?.parse()?,
                anomaly_detection: std::env::var("ANOMALY_DETECTION")?.parse()?,
                alert_thresholds: HashMap::new(), // ä»é…ç½®æ–‡ä»¶åŠ è½½
            },
        })
    }
}

#[derive(Debug, thiserror::Error)]
pub enum ConfigError {
    #[error("Environment variable not found: {0}")]
    EnvVarNotFound(String),
    #[error("Invalid configuration value: {0}")]
    InvalidValue(String),
}
```

### 2. å®‰å…¨ä¸­é—´ä»¶

```rust
// src/security/middleware.rs
use axum::{
    extract::{Request, State},
    middleware::Next,
    response::Response,
    http::{StatusCode, HeaderMap},
};
use std::sync::Arc;
use tracing::{info, warn, error};

pub struct SecurityMiddleware {
    auth_service: Arc<AuthenticationService>,
    access_control: Arc<AccessControlService>,
    audit_logger: Arc<AuditLogger>,
}

impl SecurityMiddleware {
    pub fn new(
        auth_service: Arc<AuthenticationService>,
        access_control: Arc<AccessControlService>,
        audit_logger: Arc<AuditLogger>,
    ) -> Self {
        Self {
            auth_service,
            access_control,
            audit_logger,
        }
    }
    
    pub async fn authenticate_and_authorize(
        State(security): State<Arc<SecurityMiddleware>>,
        headers: HeaderMap,
        request: Request,
        next: Next,
    ) -> Result<Response, StatusCode> {
        let start_time = std::time::Instant::now();
        
        // 1. æå–å’ŒéªŒè¯ä»¤ç‰Œ
        let token = security.extract_token(&headers)?;
        let claims = security.auth_service.validate_token(&token)
            .map_err(|_| StatusCode::UNAUTHORIZED)?;
        
        // 2. æ„å»ºè®¿é—®è¯·æ±‚
        let access_request = AccessRequest {
            subject: claims.sub,
            resource: request.uri().path().to_string(),
            action: request.method().to_string(),
            context: security.build_context(&claims, &headers, &request),
        };
        
        // 3. æ‰§è¡Œæˆæƒæ£€æŸ¥
        let decision = security.access_control.authorize(access_request).await
            .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
        
        if matches!(decision.decision, Effect::Deny) {
            security.audit_logger.log_access_denied(&decision).await;
            return Err(StatusCode::FORBIDDEN);
        }
        
        // 4. è®°å½•è®¿é—®æ—¥å¿—
        security.audit_logger.log_access_granted(&decision).await;
        
        // 5. ç»§ç»­å¤„ç†è¯·æ±‚
        let response = next.run(request).await;
        
        // 6. è®°å½•å“åº”æ—¶é—´
        let duration = start_time.elapsed();
        security.audit_logger.log_response_time(duration).await;
        
        Ok(response)
    }
    
    fn extract_token(&self, headers: &HeaderMap) -> Result<String, StatusCode> {
        let auth_header = headers.get("Authorization")
            .ok_or(StatusCode::UNAUTHORIZED)?
            .to_str()
            .map_err(|_| StatusCode::UNAUTHORIZED)?;
        
        if !auth_header.starts_with("Bearer ") {
            return Err(StatusCode::UNAUTHORIZED);
        }
        
        Ok(auth_header[7..].to_string())
    }
    
    fn build_context(
        &self,
        claims: &Claims,
        headers: &HeaderMap,
        request: &Request,
    ) -> HashMap<String, serde_json::Value> {
        let mut context = HashMap::new();
        
        context.insert("user_id".to_string(), serde_json::Value::String(claims.sub.clone()));
        context.insert("roles".to_string(), serde_json::to_value(&claims.roles).unwrap());
        context.insert("permissions".to_string(), serde_json::to_value(&claims.permissions).unwrap());
        context.insert("device_id".to_string(), serde_json::Value::String(claims.device_id.clone()));
        context.insert("session_id".to_string(), serde_json::Value::String(claims.session_id.clone()));
        
        // æ·»åŠ è¯·æ±‚ä¸Šä¸‹æ–‡
        if let Some(ip) = headers.get("X-Forwarded-For") {
            context.insert("client_ip".to_string(), serde_json::Value::String(ip.to_str().unwrap_or("").to_string()));
        }
        
        if let Some(user_agent) = headers.get("User-Agent") {
            context.insert("user_agent".to_string(), serde_json::Value::String(user_agent.to_str().unwrap_or("").to_string()));
        }
        
        context.insert("request_time".to_string(), serde_json::Value::String(chrono::Utc::now().to_rfc3339()));
        
        context
    }
}

pub struct AuditLogger;

impl AuditLogger {
    pub async fn log_access_granted(&self, decision: &AccessDecision) {
        info!("Access granted: {:?}", decision);
        // å®ç°å®¡è®¡æ—¥å¿—è®°å½•
    }
    
    pub async fn log_access_denied(&self, decision: &AccessDecision) {
        warn!("Access denied: {:?}", decision);
        // å®ç°å®¡è®¡æ—¥å¿—è®°å½•
    }
    
    pub async fn log_response_time(&self, duration: std::time::Duration) {
        info!("Response time: {:?}", duration);
        // å®ç°æ€§èƒ½æ—¥å¿—è®°å½•
    }
}
```

é€šè¿‡æœ¬æŒ‡å—ï¼Œæ‚¨å¯ä»¥å®ç°å®Œæ•´çš„é›¶ä¿¡ä»»æ¶æ„ï¼Œç¡®ä¿å¾®æœåŠ¡ç¯å¢ƒä¸‹çš„å®‰å…¨æ€§å’Œåˆè§„æ€§ã€‚
