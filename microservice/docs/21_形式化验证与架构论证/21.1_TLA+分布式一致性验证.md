# TLA+åˆ†å¸ƒå¼ä¸€è‡´æ€§éªŒè¯

> åŸºäºTLA+çš„å¾®æœåŠ¡æ¶æ„åˆ†å¸ƒå¼ä¸€è‡´æ€§å½¢å¼åŒ–éªŒè¯å®è·µ

## ğŸ“‹ æ¦‚è¿°

TLA+æ˜¯ä¸€ç§ç”¨äºæŒ‡å®šå’ŒéªŒè¯å¹¶å‘å’Œåˆ†å¸ƒå¼ç³»ç»Ÿçš„å½¢å¼åŒ–è¯­è¨€ã€‚æœ¬æŒ‡å—å°†ä»‹ç»å¦‚ä½•ä½¿ç”¨TLA+å¯¹å¾®æœåŠ¡æ¶æ„ä¸­çš„åˆ†å¸ƒå¼ä¸€è‡´æ€§è¿›è¡Œå½¢å¼åŒ–éªŒè¯ï¼ŒåŒ…æ‹¬åˆ†å¸ƒå¼é”ã€åˆ†å¸ƒå¼äº‹åŠ¡ã€å…±è¯†ç®—æ³•ç­‰æ ¸å¿ƒç»„ä»¶çš„æ­£ç¡®æ€§è¯æ˜ã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

- ç†è§£TLA+çš„åŸºæœ¬è¯­æ³•å’Œè¯­ä¹‰
- æŒæ¡åˆ†å¸ƒå¼ä¸€è‡´æ€§çš„å½¢å¼åŒ–å»ºæ¨¡æ–¹æ³•
- å­¦ä¼šä½¿ç”¨TLA+éªŒè¯åˆ†å¸ƒå¼ç®—æ³•çš„æ­£ç¡®æ€§
- å®ç°å¾®æœåŠ¡æ¶æ„ä¸­å…³é”®ç»„ä»¶çš„TLA+æ¨¡å‹

## ğŸ“š å†…å®¹å¤§çº²

## ğŸ”§ åŸºç¡€æ¦‚å¿µ

### ä»€ä¹ˆæ˜¯TLA+

TLA+ï¼ˆTemporal Logic of Actionsï¼‰æ˜¯ä¸€ç§ç”¨äºæŒ‡å®šå’ŒéªŒè¯å¹¶å‘å’Œåˆ†å¸ƒå¼ç³»ç»Ÿçš„å½¢å¼åŒ–è¯­è¨€ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

- **æ—¶åºé€»è¾‘**ï¼šèƒ½å¤Ÿè¡¨è¾¾ç³»ç»Ÿçš„æ—¶åºè¡Œä¸º
- **åŠ¨ä½œç³»ç»Ÿ**ï¼šåŸºäºçŠ¶æ€è½¬æ¢çš„åŠ¨ä½œç³»ç»Ÿ
- **æ¨¡å‹æ£€æŸ¥**ï¼šè‡ªåŠ¨åŒ–çš„çŠ¶æ€ç©ºé—´æ¢ç´¢
- **ä¸å˜å¼éªŒè¯**ï¼šéªŒè¯ç³»ç»Ÿå±æ€§çš„ä¿æŒæ€§

### åˆ†å¸ƒå¼ä¸€è‡´æ€§æ¨¡å‹

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        ä¸€è‡´æ€§æ¨¡å‹å±‚æ¬¡                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å¼ºä¸€è‡´æ€§ (Strong Consistency)       â”‚
â”‚  â”œâ”€ çº¿æ€§ä¸€è‡´æ€§ (Linearizability)    â”‚
â”‚  â””â”€ é¡ºåºä¸€è‡´æ€§ (Sequential)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å¼±ä¸€è‡´æ€§ (Weak Consistency)         â”‚
â”‚  â”œâ”€ æœ€ç»ˆä¸€è‡´æ€§ (Eventual)           â”‚
â”‚  â”œâ”€ å› æœä¸€è‡´æ€§ (Causal)             â”‚
â”‚  â””â”€ ä¼šè¯ä¸€è‡´æ€§ (Session)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### éªŒè¯ç›®æ ‡

1. **å®‰å…¨æ€§**ï¼šç³»ç»Ÿä¸ä¼šè¿›å…¥é”™è¯¯çŠ¶æ€
2. **æ´»æ€§**ï¼šç³»ç»Ÿæœ€ç»ˆä¼šè¾¾åˆ°æœŸæœ›çŠ¶æ€
3. **ä¸å˜å¼**ï¼šç³»ç»Ÿå±æ€§åœ¨è¿è¡Œè¿‡ç¨‹ä¸­ä¿æŒä¸å˜
4. **å…¬å¹³æ€§**ï¼šç³»ç»Ÿè¡Œä¸ºçš„å…¬å¹³æ€§ä¿è¯

## ğŸ› ï¸ TLA+è¯­æ³•åŸºç¡€

### åŸºæœ¬è¯­æ³•

```tla
---- MODULE DistributedLock ----

EXTENDS Naturals, Sequences, TLC

CONSTANTS Nodes, MaxRetries

VARIABLES 
    \* ç³»ç»ŸçŠ¶æ€å˜é‡
    lock_holder,     \* å½“å‰é”æŒæœ‰è€…
    waiting_queue,   \* ç­‰å¾…é˜Ÿåˆ—
    node_states,     \* èŠ‚ç‚¹çŠ¶æ€
    message_queue    \* æ¶ˆæ¯é˜Ÿåˆ—

TypeOK == 
    /\ lock_holder \in Nodes \cup {null}
    /\ waiting_queue \in Seq(Nodes)
    /\ node_states \in [Nodes -> {"idle", "requesting", "holding", "releasing"}]
    /\ message_queue \in Seq([type: {"request", "grant", "release"}])

Init == 
    /\ lock_holder = null
    /\ waiting_queue = <<>>
    /\ node_states = [n \in Nodes |-> "idle"]
    /\ message_queue = <<>>

\* åŠ¨ä½œå®šä¹‰
RequestLock(n) == 
    /\ node_states[n] = "idle"
    /\ lock_holder = null
    /\ node_states' = [node_states EXCEPT ![n] = "requesting"]
    /\ waiting_queue' = Append(waiting_queue, n)
    /\ message_queue' = Append(message_queue, [type |-> "request", node |-> n])
    /\ UNCHANGED lock_holder

GrantLock == 
    /\ lock_holder = null
    /\ waiting_queue /= <<>>
    /\ LET head == Head(waiting_queue)
       IN /\ lock_holder' = head
          /\ node_states' = [node_states EXCEPT ![head] = "holding"]
          /\ waiting_queue' = Tail(waiting_queue)
          /\ message_queue' = Append(message_queue, [type |-> "grant", node |-> head])
    /\ UNCHANGED <<>>

ReleaseLock(n) == 
    /\ node_states[n] = "holding"
    /\ lock_holder = n
    /\ lock_holder' = null
    /\ node_states' = [node_states EXCEPT ![n] = "idle"]
    /\ message_queue' = Append(message_queue, [type |-> "release", node |-> n])
    /\ UNCHANGED waiting_queue

Next == 
    \/ \E n \in Nodes : RequestLock(n)
    \/ GrantLock
    \/ \E n \in Nodes : ReleaseLock(n)

Spec == Init /\ [][Next]_<<lock_holder, waiting_queue, node_states, message_queue>>

\* ä¸å˜å¼
MutualExclusion == 
    \A n1, n2 \in Nodes : 
        n1 /= n2 => ~(node_states[n1] = "holding" /\ node_states[n2] = "holding")

NoDeadlock == 
    \A n \in Nodes : 
        node_states[n] = "requesting" => <>[](node_states[n] = "holding")

Fairness == 
    \A n \in Nodes : 
        node_states[n] = "requesting" => <>(node_states[n] = "holding")

====
```

### é«˜çº§è¯­æ³•ç‰¹æ€§

```tla
---- MODULE AdvancedPatterns ----

EXTENDS Naturals, Sequences, FiniteSets, TLC

CONSTANTS Nodes, MaxRetries, Timeout

VARIABLES 
    node_states,
    message_queues,
    timers,
    retry_counts

\* é€’å½’å‡½æ•°å®šä¹‰
RecursiveFunction(n) == 
    IF n = 0 THEN 1
    ELSE n * RecursiveFunction(n-1)

\* é«˜é˜¶å‡½æ•°
MapFunction(f, seq) == 
    [i \in 1..Len(seq) |-> f(seq[i])]

\* é›†åˆæ¨å¯¼
FilterSet(set, predicate) == 
    {x \in set : predicate(x)}

\* æ—¶åºæ“ä½œç¬¦
Eventually(p) == <>p
Always(p) == []p
LeadsTo(p, q) == p ~> q

\* å…¬å¹³æ€§çº¦æŸ
FairnessConstraint == 
    \A n \in Nodes : 
        SF_<<node_states>>(node_states[n] = "requesting")

====
```

## ğŸ”’ åˆ†å¸ƒå¼é”éªŒè¯

### åˆ†å¸ƒå¼é”TLA+æ¨¡å‹

```tla
---- MODULE DistributedLockAdvanced ----

EXTENDS Naturals, Sequences, FiniteSets, TLC

CONSTANTS Nodes, MaxRetries, Timeout

VARIABLES 
    lock_holder,
    waiting_queue,
    node_states,
    message_queues,
    timers,
    retry_counts

TypeOK == 
    /\ lock_holder \in Nodes \cup {null}
    /\ waiting_queue \in Seq(Nodes)
    /\ node_states \in [Nodes -> {"idle", "requesting", "holding", "releasing", "failed"}]
    /\ message_queues \in [Nodes -> Seq([type: {"request", "grant", "release", "timeout"}])]
    /\ timers \in [Nodes -> Nat]
    /\ retry_counts \in [Nodes -> Nat]

Init == 
    /\ lock_holder = null
    /\ waiting_queue = <<>>
    /\ node_states = [n \in Nodes |-> "idle"]
    /\ message_queues = [n \in Nodes |-> <<>>]
    /\ timers = [n \in Nodes |-> 0]
    /\ retry_counts = [n \in Nodes |-> 0]

\* è¯·æ±‚é”åŠ¨ä½œ
RequestLock(n) == 
    /\ node_states[n] = "idle"
    /\ retry_counts[n] < MaxRetries
    /\ node_states' = [node_states EXCEPT ![n] = "requesting"]
    /\ waiting_queue' = Append(waiting_queue, n)
    /\ timers' = [timers EXCEPT ![n] = Timeout]
    /\ retry_counts' = [retry_counts EXCEPT ![n] = retry_counts[n] + 1]
    /\ UNCHANGED <<lock_holder, message_queues>>

\* æˆäºˆé”åŠ¨ä½œ
GrantLock == 
    /\ lock_holder = null
    /\ waiting_queue /= <<>>
    /\ LET head == Head(waiting_queue)
       IN /\ lock_holder' = head
          /\ node_states' = [node_states EXCEPT ![head] = "holding"]
          /\ waiting_queue' = Tail(waiting_queue)
          /\ timers' = [timers EXCEPT ![head] = 0]
    /\ UNCHANGED <<message_queues, retry_counts>>

\* é‡Šæ”¾é”åŠ¨ä½œ
ReleaseLock(n) == 
    /\ node_states[n] = "holding"
    /\ lock_holder = n
    /\ lock_holder' = null
    /\ node_states' = [node_states EXCEPT ![n] = "idle"]
    /\ retry_counts' = [retry_counts EXCEPT ![n] = 0]
    /\ UNCHANGED <<waiting_queue, message_queues, timers>>

\* è¶…æ—¶å¤„ç†
HandleTimeout(n) == 
    /\ node_states[n] = "requesting"
    /\ timers[n] > 0
    /\ timers' = [timers EXCEPT ![n] = timers[n] - 1]
    /\ IF timers[n] = 1 THEN
        /\ node_states' = [node_states EXCEPT ![n] = "failed"]
        /\ waiting_queue' = [i \in 1..Len(waiting_queue) |-> 
                            IF waiting_queue[i] = n THEN waiting_queue[i] ELSE waiting_queue[i]]
        /\ waiting_queue' = FilterSeq(waiting_queue', \x. x /= n)
      ELSE
        /\ UNCHANGED <<node_states, waiting_queue>>
    /\ UNCHANGED <<lock_holder, message_queues, retry_counts>>

\* é‡è¯•æœºåˆ¶
RetryRequest(n) == 
    /\ node_states[n] = "failed"
    /\ retry_counts[n] < MaxRetries
    /\ node_states' = [node_states EXCEPT ![n] = "requesting"]
    /\ waiting_queue' = Append(waiting_queue, n)
    /\ timers' = [timers EXCEPT ![n] = Timeout]
    /\ retry_counts' = [retry_counts EXCEPT ![n] = retry_counts[n] + 1]
    /\ UNCHANGED <<lock_holder, message_queues>>

Next == 
    \/ \E n \in Nodes : RequestLock(n)
    \/ GrantLock
    \/ \E n \in Nodes : ReleaseLock(n)
    \/ \E n \in Nodes : HandleTimeout(n)
    \/ \E n \in Nodes : RetryRequest(n)

Spec == Init /\ [][Next]_<<lock_holder, waiting_queue, node_states, message_queues, timers, retry_counts>>

\* ä¸å˜å¼
MutualExclusion == 
    \A n1, n2 \in Nodes : 
        n1 /= n2 => ~(node_states[n1] = "holding" /\ node_states[n2] = "holding")

NoDeadlock == 
    \A n \in Nodes : 
        node_states[n] = "requesting" => <>[](node_states[n] = "holding" \/ node_states[n] = "failed")

Fairness == 
    \A n \in Nodes : 
        node_states[n] = "requesting" => <>(node_states[n] = "holding" \/ node_states[n] = "failed")

Liveness == 
    \A n \in Nodes : 
        node_states[n] = "requesting" => <>[](node_states[n] = "holding")

====
```

### éªŒè¯é…ç½®

```tla
---- MODULE DistributedLockConfig ----

EXTENDS DistributedLockAdvanced

\* æ¨¡å‹å‚æ•°
Nodes == {n1, n2, n3}
MaxRetries == 3
Timeout == 5

\* ä¸å˜å¼æ£€æŸ¥
Invariants == 
    /\ MutualExclusion
    /\ NoDeadlock

\* æ—¶åºå±æ€§æ£€æŸ¥
Properties == 
    /\ Fairness
    /\ Liveness

====
```

## ğŸ’° åˆ†å¸ƒå¼äº‹åŠ¡éªŒè¯

### ä¸¤é˜¶æ®µæäº¤åè®®

```tla
---- MODULE TwoPhaseCommit ----

EXTENDS Naturals, Sequences, FiniteSets, TLC

CONSTANTS Participants, Coordinator, Timeout

VARIABLES 
    coordinator_state,
    participant_states,
    vote_results,
    decision,
    timers

TypeOK == 
    /\ coordinator_state \in {"idle", "preparing", "committing", "aborting", "committed", "aborted"}
    /\ participant_states \in [Participants -> {"idle", "prepared", "committed", "aborted"}]
    /\ vote_results \in [Participants -> {"yes", "no", "pending"}]
    /\ decision \in {"commit", "abort", "pending"}
    /\ timers \in [Participants -> Nat]

Init == 
    /\ coordinator_state = "idle"
    /\ participant_states = [p \in Participants |-> "idle"]
    /\ vote_results = [p \in Participants |-> "pending"]
    /\ decision = "pending"
    /\ timers = [p \in Participants |-> 0]

\* å¼€å§‹äº‹åŠ¡
StartTransaction == 
    /\ coordinator_state = "idle"
    /\ coordinator_state' = "preparing"
    /\ timers' = [p \in Participants |-> Timeout]
    /\ UNCHANGED <<participant_states, vote_results, decision>>

\* å‚ä¸è€…æŠ•ç¥¨
Vote(p, vote) == 
    /\ participant_states[p] = "idle"
    /\ coordinator_state = "preparing"
    /\ vote_results' = [vote_results EXCEPT ![p] = vote]
    /\ participant_states' = [participant_states EXCEPT ![p] = "prepared"]
    /\ UNCHANGED <<coordinator_state, decision, timers>>

\* åè°ƒè€…å†³ç­–
MakeDecision == 
    /\ coordinator_state = "preparing"
    /\ \A p \in Participants : vote_results[p] /= "pending"
    /\ LET all_yes == \A p \in Participants : vote_results[p] = "yes"
       IN /\ decision' = IF all_yes THEN "commit" ELSE "abort"
          /\ coordinator_state' = IF all_yes THEN "committing" ELSE "aborting"
    /\ UNCHANGED <<participant_states, vote_results, timers>>

\* æ‰§è¡Œæäº¤
ExecuteCommit == 
    /\ coordinator_state = "committing"
    /\ decision = "commit"
    /\ coordinator_state' = "committed"
    /\ participant_states' = [p \in Participants |-> "committed"]
    /\ UNCHANGED <<vote_results, decision, timers>>

\* æ‰§è¡Œä¸­æ­¢
ExecuteAbort == 
    /\ coordinator_state = "aborting"
    /\ decision = "abort"
    /\ coordinator_state' = "aborted"
    /\ participant_states' = [p \in Participants |-> "aborted"]
    /\ UNCHANGED <<vote_results, decision, timers>>

\* è¶…æ—¶å¤„ç†
HandleTimeout(p) == 
    /\ timers[p] > 0
    /\ timers' = [timers EXCEPT ![p] = timers[p] - 1]
    /\ IF timers[p] = 1 THEN
        /\ coordinator_state' = "aborting"
        /\ decision' = "abort"
        /\ participant_states' = [participant_states EXCEPT ![p] = "aborted"]
      ELSE
        /\ UNCHANGED <<coordinator_state, decision, participant_states>>
    /\ UNCHANGED <<vote_results>>

Next == 
    \/ StartTransaction
    \/ \E p \in Participants, vote \in {"yes", "no"} : Vote(p, vote)
    \/ MakeDecision
    \/ ExecuteCommit
    \/ ExecuteAbort
    \/ \E p \in Participants : HandleTimeout(p)

Spec == Init /\ [][Next]_<<coordinator_state, participant_states, vote_results, decision, timers>>

\* ä¸å˜å¼
Atomicity == 
    \A p \in Participants : 
        participant_states[p] = "committed" => decision = "commit"

Consistency == 
    \A p1, p2 \in Participants : 
        participant_states[p1] = "committed" /\ participant_states[p2] = "aborted" => FALSE

Isolation == 
    \A p \in Participants : 
        participant_states[p] = "prepared" => coordinator_state \in {"preparing", "committing", "aborting"}

Durability == 
    \A p \in Participants : 
        participant_states[p] = "committed" => <>[](participant_states[p] = "committed")

====
```

## ğŸ—³ï¸ å…±è¯†ç®—æ³•éªŒè¯

### Raftç®—æ³•TLA+æ¨¡å‹

```tla
---- MODULE RaftConsensus ----

EXTENDS Naturals, Sequences, FiniteSets, TLC

CONSTANTS Nodes, MaxLogEntries, ElectionTimeout, HeartbeatTimeout

VARIABLES 
    node_states,        \* èŠ‚ç‚¹çŠ¶æ€: "follower", "candidate", "leader"
    current_term,       \* å½“å‰ä»»æœŸ
    voted_for,          \* æŠ•ç¥¨ç»™è°
    log_entries,        \* æ—¥å¿—æ¡ç›®
    commit_index,       \* æäº¤ç´¢å¼•
    last_applied,       \* æœ€ååº”ç”¨ç´¢å¼•
    next_index,         \* ä¸‹ä¸€ä¸ªç´¢å¼•
    match_index,        \* åŒ¹é…ç´¢å¼•
    election_timers,    \* é€‰ä¸¾å®šæ—¶å™¨
    heartbeat_timers    \* å¿ƒè·³å®šæ—¶å™¨

TypeOK == 
    /\ node_states \in [Nodes -> {"follower", "candidate", "leader"}]
    /\ current_term \in [Nodes -> Nat]
    /\ voted_for \in [Nodes -> Nodes \cup {null}]
    /\ log_entries \in [Nodes -> Seq([term: Nat, command: STRING])]
    /\ commit_index \in [Nodes -> Nat]
    /\ last_applied \in [Nodes -> Nat]
    /\ next_index \in [Nodes -> [Nodes -> Nat]]
    /\ match_index \in [Nodes -> [Nodes -> Nat]]
    /\ election_timers \in [Nodes -> Nat]
    /\ heartbeat_timers \in [Nodes -> Nat]

Init == 
    /\ node_states = [n \in Nodes |-> "follower"]
    /\ current_term = [n \in Nodes |-> 0]
    /\ voted_for = [n \in Nodes |-> null]
    /\ log_entries = [n \in Nodes |-> <<>>]
    /\ commit_index = [n \in Nodes |-> 0]
    /\ last_applied = [n \in Nodes |-> 0]
    /\ next_index = [n \in Nodes |-> [m \in Nodes |-> 1]]
    /\ match_index = [n \in Nodes |-> [m \in Nodes |-> 0]]
    /\ election_timers = [n \in Nodes |-> ElectionTimeout]
    /\ heartbeat_timers = [n \in Nodes |-> 0]

\* å¼€å§‹é€‰ä¸¾
StartElection(n) == 
    /\ node_states[n] = "follower"
    /\ election_timers[n] = 0
    /\ node_states' = [node_states EXCEPT ![n] = "candidate"]
    /\ current_term' = [current_term EXCEPT ![n] = current_term[n] + 1]
    /\ voted_for' = [voted_for EXCEPT ![n] = n]
    /\ election_timers' = [election_timers EXCEPT ![n] = ElectionTimeout]
    /\ UNCHANGED <<log_entries, commit_index, last_applied, next_index, match_index, heartbeat_timers>>

\* æŠ•ç¥¨
Vote(n, candidate) == 
    /\ node_states[n] = "follower"
    /\ voted_for[n] = null
    /\ current_term[n] <= current_term[candidate]
    /\ voted_for' = [voted_for EXCEPT ![n] = candidate]
    /\ UNCHANGED <<node_states, current_term, log_entries, commit_index, last_applied, next_index, match_index, election_timers, heartbeat_timers>>

\* æˆä¸ºé¢†å¯¼è€…
BecomeLeader(n) == 
    /\ node_states[n] = "candidate"
    /\ LET votes == {m \in Nodes : voted_for[m] = n}
       IN /\ Cardinality(votes) > Cardinality(Nodes) / 2
          /\ node_states' = [node_states EXCEPT ![n] = "leader"]
          /\ next_index' = [next_index EXCEPT ![n] = [m \in Nodes |-> Len(log_entries[n]) + 1]]
          /\ match_index' = [match_index EXCEPT ![n] = [m \in Nodes |-> 0]]
          /\ heartbeat_timers' = [heartbeat_timers EXCEPT ![n] = HeartbeatTimeout]
    /\ UNCHANGED <<current_term, voted_for, log_entries, commit_index, last_applied, election_timers>>

\* è¿½åŠ æ—¥å¿—æ¡ç›®
AppendEntries(n, m, prev_log_index, prev_log_term, entries, leader_commit) == 
    /\ node_states[n] = "leader"
    /\ node_states[m] = "follower"
    /\ current_term[n] = current_term[m]
    /\ prev_log_index = 0 \/ (prev_log_index <= Len(log_entries[m]) /\ log_entries[m][prev_log_index].term = prev_log_term)
    /\ log_entries' = [log_entries EXCEPT ![m] = 
                      IF prev_log_index = 0 THEN entries
                      ELSE SubSeq(log_entries[m], 1, prev_log_index) \o entries]
    /\ commit_index' = [commit_index EXCEPT ![m] = 
                       IF leader_commit > commit_index[m] THEN 
                           Min(leader_commit, Len(log_entries'[m]))
                       ELSE commit_index[m]]
    /\ UNCHANGED <<node_states, current_term, voted_for, last_applied, next_index, match_index, election_timers, heartbeat_timers>>

\* å®šæ—¶å™¨é€’å‡
DecrementTimers == 
    /\ election_timers' = [n \in Nodes |-> IF election_timers[n] > 0 THEN election_timers[n] - 1 ELSE 0]
    /\ heartbeat_timers' = [n \in Nodes |-> IF heartbeat_timers[n] > 0 THEN heartbeat_timers[n] - 1 ELSE 0]
    /\ UNCHANGED <<node_states, current_term, voted_for, log_entries, commit_index, last_applied, next_index, match_index>>

Next == 
    \/ \E n \in Nodes : StartElection(n)
    \/ \E n, m \in Nodes : Vote(n, m)
    \/ \E n \in Nodes : BecomeLeader(n)
    \/ \E n, m \in Nodes, prev_log_index \in Nat, prev_log_term \in Nat, 
        entries \in Seq([term: Nat, command: STRING]), leader_commit \in Nat : 
        AppendEntries(n, m, prev_log_index, prev_log_term, entries, leader_commit)
    \/ DecrementTimers

Spec == Init /\ [][Next]_<<node_states, current_term, voted_for, log_entries, commit_index, last_applied, next_index, match_index, election_timers, heartbeat_timers>>

\* ä¸å˜å¼
LeaderUniqueness == 
    \A n1, n2 \in Nodes : 
        n1 /= n2 => ~(node_states[n1] = "leader" /\ node_states[n2] = "leader")

TermMonotonicity == 
    \A n \in Nodes : 
        current_term[n] >= 0

LogConsistency == 
    \A n1, n2 \in Nodes, i \in 1..Min(Len(log_entries[n1]), Len(log_entries[n2])) : 
        log_entries[n1][i].term = log_entries[n2][i].term => log_entries[n1][i].command = log_entries[n2][i].command

====
```

## ğŸ—ï¸ å¾®æœåŠ¡æ¶æ„éªŒè¯

### æœåŠ¡å‘ç°ä¸€è‡´æ€§

```tla
---- MODULE ServiceDiscovery ----

EXTENDS Naturals, Sequences, FiniteSets, TLC

CONSTANTS Services, Nodes, MaxReplicas

VARIABLES 
    service_registry,   \* æœåŠ¡æ³¨å†Œè¡¨
    node_status,        \* èŠ‚ç‚¹çŠ¶æ€
    service_instances,  \* æœåŠ¡å®ä¾‹
    health_checks       \* å¥åº·æ£€æŸ¥

TypeOK == 
    /\ service_registry \in [Services -> Seq(Nodes)]
    /\ node_status \in [Nodes -> {"healthy", "unhealthy", "unknown"}]
    /\ service_instances \in [Services -> [Nodes -> {"running", "stopped", "starting"}]]
    /\ health_checks \in [Nodes -> Nat]

Init == 
    /\ service_registry = [s \in Services |-> <<>>]
    /\ node_status = [n \in Nodes |-> "unknown"]
    /\ service_instances = [s \in Services |-> [n \in Nodes |-> "stopped"]]
    /\ health_checks = [n \in Nodes |-> 0]

\* æœåŠ¡æ³¨å†Œ
RegisterService(s, n) == 
    /\ service_instances[s][n] = "stopped"
    /\ service_instances' = [service_instances EXCEPT ![s][n] = "running"]
    /\ service_registry' = [service_registry EXCEPT ![s] = 
                           IF n \in service_registry[s] THEN service_registry[s]
                           ELSE Append(service_registry[s], n)]
    /\ UNCHANGED <<node_status, health_checks>>

\* æœåŠ¡æ³¨é”€
UnregisterService(s, n) == 
    /\ service_instances[s][n] = "running"
    /\ service_instances' = [service_instances EXCEPT ![s][n] = "stopped"]
    /\ service_registry' = [service_registry EXCEPT ![s] = 
                           FilterSeq(service_registry[s], \x. x /= n)]
    /\ UNCHANGED <<node_status, health_checks>>

\* å¥åº·æ£€æŸ¥
HealthCheck(n, status) == 
    /\ node_status' = [node_status EXCEPT ![n] = status]
    /\ health_checks' = [health_checks EXCEPT ![n] = health_checks[n] + 1]
    /\ UNCHANGED <<service_registry, service_instances>>

\* æ¸…ç†ä¸å¥åº·èŠ‚ç‚¹
CleanupUnhealthyNodes == 
    /\ \E n \in Nodes : node_status[n] = "unhealthy"
    /\ service_registry' = [s \in Services |-> 
                           FilterSeq(service_registry[s], \n. node_status[n] = "healthy")]
    /\ UNCHANGED <<node_status, service_instances, health_checks>>

Next == 
    \/ \E s \in Services, n \in Nodes : RegisterService(s, n)
    \/ \E s \in Services, n \in Nodes : UnregisterService(s, n)
    \/ \E n \in Nodes, status \in {"healthy", "unhealthy"} : HealthCheck(n, status)
    \/ CleanupUnhealthyNodes

Spec == Init /\ [][Next]_<<service_registry, node_status, service_instances, health_checks>>

\* ä¸å˜å¼
ServiceAvailability == 
    \A s \in Services : 
        Len(service_registry[s]) <= MaxReplicas

Consistency == 
    \A s \in Services, n \in Nodes : 
        n \in service_registry[s] => service_instances[s][n] = "running"

HealthConsistency == 
    \A s \in Services, n \in Nodes : 
        n \in service_registry[s] => node_status[n] = "healthy"

====
```

## ğŸ“– æœ€ä½³å®è·µ

### 1. æ¨¡å‹è®¾è®¡åŸåˆ™

```tla
\* 1. ä¿æŒæ¨¡å‹ç®€å•
\* 2. ä½¿ç”¨æ¸…æ™°çš„å˜é‡å‘½å
\* 3. å®šä¹‰æ˜ç¡®çš„ç±»å‹çº¦æŸ
\* 4. åˆ†ç¦»å…³æ³¨ç‚¹

---- MODULE BestPractices ----

EXTENDS Naturals, Sequences, FiniteSets, TLC

CONSTANTS Nodes, MaxRetries

VARIABLES 
    \* ä½¿ç”¨æè¿°æ€§çš„å˜é‡å
    node_states,
    message_queues,
    retry_counts

\* å®šä¹‰æ¸…æ™°çš„ç±»å‹çº¦æŸ
TypeOK == 
    /\ node_states \in [Nodes -> {"idle", "busy", "failed"}]
    /\ message_queues \in [Nodes -> Seq(STRING)]
    /\ retry_counts \in [Nodes -> Nat]

\* åˆ†ç¦»åˆå§‹åŒ–é€»è¾‘
Init == 
    /\ node_states = [n \in Nodes |-> "idle"]
    /\ message_queues = [n \in Nodes |-> <<>>]
    /\ retry_counts = [n \in Nodes |-> 0]

\* åˆ†ç¦»åŠ¨ä½œå®šä¹‰
ProcessMessage(n) == 
    /\ node_states[n] = "idle"
    /\ message_queues[n] /= <<>>
    /\ node_states' = [node_states EXCEPT ![n] = "busy"]
    /\ message_queues' = [message_queues EXCEPT ![n] = Tail(message_queues[n])]
    /\ UNCHANGED retry_counts

\* ç»„åˆåŠ¨ä½œ
Next == 
    \/ \E n \in Nodes : ProcessMessage(n)
    \/ \E n \in Nodes : HandleFailure(n)
    \/ \E n \in Nodes : RetryOperation(n)

====
```

### 2. éªŒè¯ç­–ç•¥

```tla
\* 1. åˆ†å±‚éªŒè¯
\* 2. æ¸è¿›å¼éªŒè¯
\* 3. å±æ€§åˆ†ç±»éªŒè¯

---- MODULE VerificationStrategy ----

EXTENDS DistributedSystem

\* åŸºç¡€ä¸å˜å¼
BasicInvariants == 
    /\ TypeOK
    /\ \A n \in Nodes : node_states[n] \in {"idle", "busy", "failed"}

\* å®‰å…¨å±æ€§
SafetyProperties == 
    /\ MutualExclusion
    /\ NoDeadlock
    /\ Consistency

\* æ´»æ€§å±æ€§
LivenessProperties == 
    /\ Fairness
    /\ Progress
    /\ Termination

\* æ€§èƒ½å±æ€§
PerformanceProperties == 
    /\ BoundedLatency
    /\ Throughput
    /\ ResourceUtilization

====
```

### 3. è°ƒè¯•æŠ€å·§

```tla
\* 1. ä½¿ç”¨æ–­è¨€
\* 2. æ·»åŠ è°ƒè¯•å˜é‡
\* 3. ä½¿ç”¨TLCè°ƒè¯•å™¨

---- MODULE Debugging ----

EXTENDS DistributedSystem

VARIABLES 
    debug_trace,        \* è°ƒè¯•è·Ÿè¸ª
    error_count,        \* é”™è¯¯è®¡æ•°
    state_history       \* çŠ¶æ€å†å²

\* è°ƒè¯•æ–­è¨€
DebugAssertions == 
    /\ error_count <= 10
    /\ Len(debug_trace) <= 1000
    /\ \A i \in 1..Len(state_history) : TypeOK

\* é”™è¯¯æ£€æµ‹
DetectError == 
    /\ \E n \in Nodes : node_states[n] = "failed"
    /\ error_count' = error_count + 1
    /\ debug_trace' = Append(debug_trace, "Error detected")
    /\ UNCHANGED <<node_states, state_history>>

====
```

## ğŸš€ å®é™…åº”ç”¨æ¡ˆä¾‹

### å¾®æœåŠ¡æ¶æ„éªŒè¯é…ç½®

```tla
---- MODULE MicroserviceArchitecture ----

EXTENDS DistributedLockAdvanced, TwoPhaseCommit, RaftConsensus, ServiceDiscovery

CONSTANTS 
    Services == {"user-service", "order-service", "payment-service"}
    Nodes == {n1, n2, n3, n4, n5}
    MaxRetries == 3
    Timeout == 10
    ElectionTimeout == 15
    HeartbeatTimeout == 5

\* ç»¼åˆéªŒè¯
ArchitectureInvariants == 
    /\ \* åˆ†å¸ƒå¼é”ä¸å˜å¼
       MutualExclusion
    /\ \* åˆ†å¸ƒå¼äº‹åŠ¡ä¸å˜å¼
       Atomicity
    /\ \* å…±è¯†ç®—æ³•ä¸å˜å¼
       LeaderUniqueness
    /\ \* æœåŠ¡å‘ç°ä¸å˜å¼
       ServiceAvailability

\* ç»¼åˆæ—¶åºå±æ€§
ArchitectureProperties == 
    /\ \* åˆ†å¸ƒå¼é”æ´»æ€§
       Fairness
    /\ \* åˆ†å¸ƒå¼äº‹åŠ¡æŒä¹…æ€§
       Durability
    /\ \* å…±è¯†ç®—æ³•ä¸€è‡´æ€§
       LogConsistency
    /\ \* æœåŠ¡å‘ç°ä¸€è‡´æ€§
       HealthConsistency

====
```

é€šè¿‡æœ¬æŒ‡å—ï¼Œæ‚¨å¯ä»¥æŒæ¡ä½¿ç”¨TLA+å¯¹å¾®æœåŠ¡æ¶æ„è¿›è¡Œå½¢å¼åŒ–éªŒè¯çš„æ–¹æ³•ï¼Œç¡®ä¿åˆ†å¸ƒå¼ç³»ç»Ÿçš„æ­£ç¡®æ€§å’Œå¯é æ€§ã€‚
