# 7.5 NATS/Kafka 组合范式 与 Rust 1.90 实践

> 将 NATS（轻量、请求-响应、JetStream KV/对象存储）与 Kafka（高吞吐、持久有序、批处理）按职责拆分，结合 Rust 1.90 的异步 trait/GAT/TAIT 构建高可靠事件驱动系统。

## 7.5.1 职责划分与场景

- NATS：低延迟通知、控制面（配置热更新、路由开关）、RPC 请求-响应、边缘/IoT 汇聚。
- Kafka：业务事件主干、可回放、批量处理、流式 ETL、CDC 通道。

## 7.5.2 总线与网关层

- 统一事件模型：定义 `Event{ id, ts, key, kind, data, headers }`；
- 边缘入口先经 NATS，核心处理落地 Kafka，必要时双写（带幂等键与去重策略）。

## 7.5.3 Rust 1.90 语言特性落地

- 异步 trait：抽象 `Publisher`/`Subscriber` 接口，支持多实现（NATS/Kafka）。
- GAT：为 `Stream<'a>` 风格消费接口建模；
- TAIT：隐藏具体 client 与组合器返回类型，暴露统一能力边界。

```rust
pub trait Publisher {
    type Error;
    async fn publish(&self, topic: &str, payload: bytes::Bytes) -> Result<(), Self::Error>;
}

pub trait Consumer {
    type Error;
    type Stream<'a>: futures_core::Stream<Item = Result<Event, Self::Error>> + 'a where Self: 'a;
    fn subscribe<'a>(&'a self, topic: &'a str) -> Self::Stream<'a>;
}
```

## 7.5.4 组合策略

- 写入路径：NATS 同步回执 + 异步转发到 Kafka（失败时落盘重试/死信队列）；
- 读取路径：Kafka 为主消费，NATS 用于实时通知与补偿触发；
- 事务一致性：利用幂等键（业务主键+版本），消费者侧 Upsert/去重；
- 背压：Kafka 使用批量与分区并行；NATS 使用 JetStream 拉取+Ack 策略（限制 in-flight 条数）。

## 7.5.5 关键代码片段（伪代码）

```rust
// 统一发布者别名（TAIT）
pub type PublishResult = impl core::future::Future<Output = Result<(), anyhow::Error>> + Send;

pub struct Bus { nats: NatsClient, kafka: KafkaProducer }

impl Bus {
    pub fn publish(&self, topic: &str, payload: bytes::Bytes) -> PublishResult {
        async move {
            // 1) NATS 快速回执
            self.nats.publish(topic, &payload).await?;
            // 2) 异步转发 Kafka（可启用重试/回溯）
            self.kafka.send(topic, payload).await?;
            Ok(())
        }
    }
}
```

### JetStream 拉取式消费与 Ack 策略（关键片段）

```rust
// 伪代码：展示拉取、Ack、限制 in-flight
async fn consume_js(stream: &str, subject: &str) -> anyhow::Result<()> {
    let js = nats::jetstream::new_client().await?;
    let consumer = js.pull_consumer(stream, "c1").await?;
    loop {
        let messages = consumer.fetch(100).expires(std::time::Duration::from_millis(1000)).await?;
        for msg in messages {
            // 处理业务
            // ...
            msg.ack().await?; // 确认消费
        }
    }
}
```

### Kafka 事务性发送（Exactly-Once 处理链的基础）

```rust
// 伪代码：初始化事务、发送、commit 或 abort
async fn kafka_tx(producer: &rdkafka::producer::BaseProducer, records: Vec<Record>) -> anyhow::Result<()> {
    producer.init_transactions(std::time::Duration::from_secs(5))?;
    producer.begin_transaction()?;
    for r in records {
        producer.send(r.topic, r.key, r.payload).await?;
    }
    // 与消费位点（consumer group offsets）绑定提交实现 EOS 语义
    producer.commit_transaction(std::time::Duration::from_secs(5))?;
    Ok(())
}
```

## 7.5.6 观测与治理

- 指标：发布/消费 QPS、滞留、重试次数、Ack 延迟、DLQ 量；
- 追踪：跨总线携带 trace id、span 链路；
- 开关：通过 NATS KV/对象存储提供动态策略（如双写开关、降级到单通道）。

## 7.5.7 最佳实践

- 幂等优先：以业务键/版本为去重主线；
- 可回放：Kafka 作为事实来源，NATS 辅助实时触达；
- 端到端一致性：明确“写路径/读路径”的主次职责，发生故障时可审计与重放；
- 安全：mTLS、主题级 ACL、敏感字段脱敏；
- 成本控制：边缘用 NATS 汇聚与压缩，核心用 Kafka 做批处理与冷热分层。
