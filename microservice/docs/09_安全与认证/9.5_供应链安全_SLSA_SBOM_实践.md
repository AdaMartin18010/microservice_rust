# 9.5 供应链安全 SLSA SBOM 实践

> 基于 SLSA v1.0 和 SBOM (CycloneDX/SPDX) 的供应链安全实践，确保微服务构建和部署的安全性

## 9.5.1 概述

供应链安全是现代微服务架构的重要组成部分，通过以下技术确保软件供应链的可信度：

### SLSA (Supply-chain Levels for Software Artifacts)

- **Level 0**：无保证
- **Level 1**：构建过程可重现
- **Level 2**：构建过程可验证
- **Level 3**：构建过程可审计
- **Level 4**：构建过程可证明

### SBOM (Software Bill of Materials)

- **CycloneDX**：轻量级、JSON/XML 格式
- **SPDX**：标准化、多格式支持
- **组件清单**：依赖关系、许可证、漏洞信息

## 9.5.2 SLSA 构建流程

### GitHub Actions 配置

```yaml
# .github/workflows/slsa-build.yml
name: SLSA Build

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
      attestations: write
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        components: rustfmt, clippy
    
    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
    
    - name: Build
      run: |
        cargo build --release --verbose
        cargo test --verbose
    
    - name: Generate SBOM
      run: |
        cargo install cargo-cyclonedx
        cargo cyclonedx --format json --output sbom.json
    
    - name: Sign artifacts
      run: |
        # 使用 cosign 签名
        cosign sign-blob --bundle sbom.json.bundle sbom.json
        cosign sign-blob --bundle target/release/microservice.bundle target/release/microservice
    
    - name: Generate SLSA provenance
      uses: slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@v1.0.0
      with:
        base64-subjects: ${{ steps.hash.outputs.sha256 }}
        upload-assets: true
        compile-generator: true
```

### SLSA 配置文件

```yaml
# .slsa/config.yml
version: 1
build:
  type: "github-actions"
  builder_id: "https://github.com/actions/runner"
  build_type: "https://github.com/slsa-framework/slsa-github-generator/generic@v1.0.0"
  invocation:
    config_source:
      uri: "git+https://github.com/owner/repo@refs/heads/main"
      digest:
        sha1: "abc123..."
    parameters:
      build_artifacts:
        - path: "target/release/microservice"
          digest:
            sha256: "def456..."
        - path: "sbom.json"
          digest:
            sha256: "ghi789..."
    environment:
      runner_label: "ubuntu-latest"
      runner_context: "github-hosted"
      github_actor_id: "12345"
      github_repository_id: "67890"
      github_repository_owner_id: "11111"
      github_event_name: "push"
      github_ref: "refs/heads/main"
      github_ref_type: "branch"
      github_sha1: "abc123..."
```

## 9.5.3 SBOM 生成与管理

### CycloneDX 配置

```toml
# Cargo.toml 中添加
[package.metadata.cyclonedx]
format = "json"
output = "sbom.json"
include-dev-dependencies = false
include-build-dependencies = false
```

### SBOM 生成脚本

```rust
// scripts/generate_sbom.rs
use std::fs;
use std::path::Path;
use serde_json::{json, Value};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let sbom = generate_sbom()?;
    
    // 写入文件
    fs::write("sbom.json", serde_json::to_string_pretty(&sbom)?)?;
    
    // 验证 SBOM
    validate_sbom(&sbom)?;
    
    println!("SBOM generated successfully");
    Ok(())
}

fn generate_sbom() -> Result<Value, Box<dyn std::error::Error>> {
    let sbom = json!({
        "bomFormat": "CycloneDX",
        "specVersion": "1.5",
        "version": 1,
        "metadata": {
            "timestamp": chrono::Utc::now().to_rfc3339(),
            "tools": [
                {
                    "vendor": "CycloneDX",
                    "name": "cargo-cyclonedx",
                    "version": "0.1.0"
                }
            ],
            "component": {
                "type": "application",
                "name": "microservice",
                "version": env!("CARGO_PKG_VERSION"),
                "purl": format!("pkg:cargo/microservice@{}", env!("CARGO_PKG_VERSION")),
                "licenses": [
                    {
                        "license": {
                            "id": "MIT"
                        }
                    }
                ]
            }
        },
        "components": generate_components()?,
        "dependencies": generate_dependencies()?
    });
    
    Ok(sbom)
}

fn generate_components() -> Result<Vec<Value>, Box<dyn std::error::Error>> {
    let mut components = Vec::new();
    
    // 添加主要依赖
    let dependencies = [
        ("tokio", "1.0", "MIT"),
        ("axum", "0.7", "MIT"),
        ("tonic", "0.12", "MIT"),
        ("serde", "1.0", "MIT"),
        ("tracing", "0.1", "MIT"),
    ];
    
    for (name, version, license) in &dependencies {
        let component = json!({
            "type": "library",
            "name": name,
            "version": version,
            "purl": format!("pkg:cargo/{}@{}", name, version),
            "licenses": [
                {
                    "license": {
                        "id": license
                    }
                }
            ]
        });
        components.push(component);
    }
    
    Ok(components)
}

fn generate_dependencies() -> Result<Vec<Value>, Box<dyn std::error::Error>> {
    let dependencies = json!([
        {
            "ref": "pkg:cargo/microservice@1.0.0",
            "dependsOn": [
                "pkg:cargo/tokio@1.0",
                "pkg:cargo/axum@0.7",
                "pkg:cargo/tonic@0.12",
                "pkg:cargo/serde@1.0",
                "pkg:cargo/tracing@0.1"
            ]
        }
    ]);
    
    Ok(dependencies.as_array().unwrap().clone())
}

fn validate_sbom(sbom: &Value) -> Result<(), Box<dyn std::error::Error>> {
    // 验证必需字段
    let required_fields = ["bomFormat", "specVersion", "version", "metadata"];
    for field in &required_fields {
        if !sbom.get(field).is_some() {
            return Err(format!("Missing required field: {}", field).into());
        }
    }
    
    // 验证组件
    if let Some(components) = sbom.get("components") {
        if let Some(components_array) = components.as_array() {
            for component in components_array {
                if !component.get("name").is_some() || !component.get("version").is_some() {
                    return Err("Invalid component: missing name or version".into());
                }
            }
        }
    }
    
    println!("SBOM validation passed");
    Ok(())
}
```

## 9.5.4 漏洞扫描与修复

### 漏洞扫描配置

```yaml
# .github/workflows/security-scan.yml
name: Security Scan

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  schedule:
    - cron: '0 2 * * 1'  # 每周一凌晨2点

jobs:
  security-scan:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
    
    - name: Run cargo audit
      run: |
        cargo install cargo-audit
        cargo audit
    
    - name: Run cargo deny
      run: |
        cargo install cargo-deny
        cargo deny check
    
    - name: Run trivy scan
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-results.sarif'
```

### 漏洞修复策略

```rust
// scripts/security_fix.rs
use std::process::Command;
use serde_json::Value;

pub struct SecurityFixer {
    audit_results: Value,
    deny_results: Value,
}

impl SecurityFixer {
    pub fn new() -> Result<Self, Box<dyn std::error::Error>> {
        let audit_results = Self::run_cargo_audit()?;
        let deny_results = Self::run_cargo_deny()?;
        
        Ok(Self {
            audit_results,
            deny_results,
        })
    }
    
    fn run_cargo_audit() -> Result<Value, Box<dyn std::error::Error>> {
        let output = Command::new("cargo")
            .args(&["audit", "--json"])
            .output()?;
        
        let stdout = String::from_utf8(output.stdout)?;
        Ok(serde_json::from_str(&stdout)?)
    }
    
    fn run_cargo_deny() -> Result<Value, Box<dyn std::error::Error>> {
        let output = Command::new("cargo")
            .args(&["deny", "check", "--format", "json"])
            .output()?;
        
        let stdout = String::from_utf8(output.stdout)?;
        Ok(serde_json::from_str(&stdout)?)
    }
    
    pub fn analyze_vulnerabilities(&self) -> Vec<Vulnerability> {
        let mut vulnerabilities = Vec::new();
        
        // 分析 cargo audit 结果
        if let Some(vulns) = self.audit_results.get("vulnerabilities") {
            if let Some(vulns_array) = vulns.as_array() {
                for vuln in vulns_array {
                    let vulnerability = Vulnerability {
                        id: vuln.get("advisory").and_then(|a| a.get("id")).and_then(|v| v.as_str()).unwrap_or("").to_string(),
                        title: vuln.get("advisory").and_then(|a| a.get("title")).and_then(|v| v.as_str()).unwrap_or("").to_string(),
                        severity: vuln.get("advisory").and_then(|a| a.get("severity")).and_then(|v| v.as_str()).unwrap_or("").to_string(),
                        package: vuln.get("package").and_then(|p| p.get("name")).and_then(|v| v.as_str()).unwrap_or("").to_string(),
                        version: vuln.get("package").and_then(|p| p.get("version")).and_then(|v| v.as_str()).unwrap_or("").to_string(),
                        fix_available: vuln.get("advisory").and_then(|a| a.get("patched_versions")).is_some(),
                    };
                    vulnerabilities.push(vulnerability);
                }
            }
        }
        
        vulnerabilities
    }
    
    pub fn generate_fix_plan(&self, vulnerabilities: &[Vulnerability]) -> FixPlan {
        let mut fix_plan = FixPlan::new();
        
        for vuln in vulnerabilities {
            if vuln.fix_available {
                fix_plan.add_fix(vuln.clone());
            } else {
                fix_plan.add_workaround(vuln.clone());
            }
        }
        
        fix_plan
    }
}

#[derive(Debug, Clone)]
pub struct Vulnerability {
    pub id: String,
    pub title: String,
    pub severity: String,
    pub package: String,
    pub version: String,
    pub fix_available: bool,
}

pub struct FixPlan {
    fixes: Vec<Vulnerability>,
    workarounds: Vec<Vulnerability>,
}

impl FixPlan {
    pub fn new() -> Self {
        Self {
            fixes: Vec::new(),
            workarounds: Vec::new(),
        }
    }
    
    pub fn add_fix(&mut self, vuln: Vulnerability) {
        self.fixes.push(vuln);
    }
    
    pub fn add_workaround(&mut self, vuln: Vulnerability) {
        self.workarounds.push(vuln);
    }
    
    pub fn generate_report(&self) -> String {
        let mut report = String::new();
        
        report.push_str("# 安全修复计划\n\n");
        
        if !self.fixes.is_empty() {
            report.push_str("## 可修复的漏洞\n\n");
            for fix in &self.fixes {
                report.push_str(&format!(
                    "- **{}**: {} ({} - {})\n",
                    fix.id, fix.title, fix.package, fix.version
                ));
            }
        }
        
        if !self.workarounds.is_empty() {
            report.push_str("\n## 需要人工处理的漏洞\n\n");
            for workaround in &self.workarounds {
                report.push_str(&format!(
                    "- **{}**: {} ({} - {})\n",
                    workaround.id, workaround.title, workaround.package, workaround.version
                ));
            }
        }
        
        report
    }
}
```

## 9.5.5 签名与验证

### Cosign 签名配置

```yaml
# .github/workflows/sign.yml
name: Sign Artifacts

on:
  push:
    tags: ['v*']

jobs:
  sign:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: write
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Install cosign
      uses: sigstore/cosign-installer@v3
    
    - name: Build
      run: cargo build --release
    
    - name: Sign binary
      run: |
        cosign sign-blob \
          --bundle target/release/microservice.bundle \
          target/release/microservice
    
    - name: Sign SBOM
      run: |
        cosign sign-blob \
          --bundle sbom.json.bundle \
          sbom.json
    
    - name: Upload signatures
      uses: actions/upload-artifact@v3
      with:
        name: signatures
        path: |
          target/release/microservice.bundle
          sbom.json.bundle
```

### 签名验证脚本

```rust
// scripts/verify_signatures.rs
use std::process::Command;
use std::path::Path;

pub struct SignatureVerifier {
    cosign_path: String,
}

impl SignatureVerifier {
    pub fn new() -> Self {
        Self {
            cosign_path: "cosign".to_string(),
        }
    }
    
    pub fn verify_binary(&self, binary_path: &Path, bundle_path: &Path) -> Result<bool, Box<dyn std::error::Error>> {
        let output = Command::new(&self.cosign_path)
            .args(&["verify-blob", "--bundle", bundle_path.to_str().unwrap(), binary_path.to_str().unwrap()])
            .output()?;
        
        Ok(output.status.success())
    }
    
    pub fn verify_sbom(&self, sbom_path: &Path, bundle_path: &Path) -> Result<bool, Box<dyn std::error::Error>> {
        let output = Command::new(&self.cosign_path)
            .args(&["verify-blob", "--bundle", bundle_path.to_str().unwrap(), sbom_path.to_str().unwrap()])
            .output()?;
        
        Ok(output.status.success())
    }
    
    pub fn verify_all(&self, artifacts_dir: &Path) -> Result<VerificationResult, Box<dyn std::error::Error>> {
        let mut result = VerificationResult::new();
        
        // 验证二进制文件
        let binary_path = artifacts_dir.join("microservice");
        let binary_bundle = artifacts_dir.join("microservice.bundle");
        if binary_path.exists() && binary_bundle.exists() {
            match self.verify_binary(&binary_path, &binary_bundle) {
                Ok(true) => result.add_success("binary".to_string()),
                Ok(false) => result.add_failure("binary".to_string(), "Signature verification failed".to_string()),
                Err(e) => result.add_failure("binary".to_string(), e.to_string()),
            }
        }
        
        // 验证 SBOM
        let sbom_path = artifacts_dir.join("sbom.json");
        let sbom_bundle = artifacts_dir.join("sbom.json.bundle");
        if sbom_path.exists() && sbom_bundle.exists() {
            match self.verify_sbom(&sbom_path, &sbom_bundle) {
                Ok(true) => result.add_success("sbom".to_string()),
                Ok(false) => result.add_failure("sbom".to_string(), "Signature verification failed".to_string()),
                Err(e) => result.add_failure("sbom".to_string(), e.to_string()),
            }
        }
        
        Ok(result)
    }
}

pub struct VerificationResult {
    successes: Vec<String>,
    failures: Vec<(String, String)>,
}

impl VerificationResult {
    pub fn new() -> Self {
        Self {
            successes: Vec::new(),
            failures: Vec::new(),
        }
    }
    
    pub fn add_success(&mut self, artifact: String) {
        self.successes.push(artifact);
    }
    
    pub fn add_failure(&mut self, artifact: String, error: String) {
        self.failures.push((artifact, error));
    }
    
    pub fn is_success(&self) -> bool {
        self.failures.is_empty()
    }
    
    pub fn generate_report(&self) -> String {
        let mut report = String::new();
        
        report.push_str("# 签名验证报告\n\n");
        
        if !self.successes.is_empty() {
            report.push_str("## 验证成功的文件\n\n");
            for success in &self.successes {
                report.push_str(&format!("- {}\n", success));
            }
        }
        
        if !self.failures.is_empty() {
            report.push_str("\n## 验证失败的文件\n\n");
            for (artifact, error) in &self.failures {
                report.push_str(&format!("- **{}**: {}\n", artifact, error));
            }
        }
        
        report
    }
}
```

## 9.5.6 策略即代码

### Kyverno 策略

```yaml
# policies/slsa-policy.yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: require-slsa-provenance
spec:
  validationFailureAction: enforce
  background: true
  rules:
  - name: require-slsa-provenance
    match:
      any:
      - resources:
          kinds:
          - Pod
          namespaces:
          - microservice-*
    validate:
      message: "Pod must have SLSA provenance attestation"
      pattern:
        metadata:
          annotations:
            "slsa.dev/provenance": "?*"
            "slsa.dev/builder": "?*"
            "slsa.dev/buildType": "?*"
---
# policies/sbom-policy.yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: require-sbom
spec:
  validationFailureAction: enforce
  background: true
  rules:
  - name: require-sbom
    match:
      any:
      - resources:
          kinds:
          - Pod
          namespaces:
          - microservice-*
    validate:
      message: "Pod must have SBOM annotation"
      pattern:
        metadata:
          annotations:
            "sbom.dev/format": "?*"
            "sbom.dev/version": "?*"
---
# policies/signature-policy.yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: require-signature
spec:
  validationFailureAction: enforce
  background: true
  rules:
  - name: require-signature
    match:
      any:
      - resources:
          kinds:
          - Pod
          namespaces:
          - microservice-*
    validate:
      message: "Pod must have signature verification"
      pattern:
        metadata:
          annotations:
            "cosign.dev/signature": "?*"
            "cosign.dev/bundle": "?*"
```

### Conftest 策略

```rego
# policies/slsa.rego
package slsa

deny[msg] {
    input.kind == "Pod"
    not input.metadata.annotations["slsa.dev/provenance"]
    msg := "Pod must have SLSA provenance annotation"
}

deny[msg] {
    input.kind == "Pod"
    not input.metadata.annotations["slsa.dev/builder"]
    msg := "Pod must have SLSA builder annotation"
}

deny[msg] {
    input.kind == "Pod"
    not input.metadata.annotations["slsa.dev/buildType"]
    msg := "Pod must have SLSA build type annotation"
}

# policies/sbom.rego
package sbom

deny[msg] {
    input.kind == "Pod"
    not input.metadata.annotations["sbom.dev/format"]
    msg := "Pod must have SBOM format annotation"
}

deny[msg] {
    input.kind == "Pod"
    not input.metadata.annotations["sbom.dev/version"]
    msg := "Pod must have SBOM version annotation"
}

# policies/signature.rego
package signature

deny[msg] {
    input.kind == "Pod"
    not input.metadata.annotations["cosign.dev/signature"]
    msg := "Pod must have signature annotation"
}

deny[msg] {
    input.kind == "Pod"
    not input.metadata.annotations["cosign.dev/bundle"]
    msg := "Pod must have signature bundle annotation"
}
```

## 9.5.7 监控与告警

### 安全指标收集

```rust
// src/security_metrics.rs
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;

pub struct SecurityMetrics {
    pub slsa_level: AtomicU64,
    pub sbom_completeness: AtomicU64,
    pub signature_verification: AtomicU64,
    pub vulnerability_count: AtomicU64,
    pub last_scan_time: AtomicU64,
}

impl SecurityMetrics {
    pub fn new() -> Self {
        Self {
            slsa_level: AtomicU64::new(0),
            sbom_completeness: AtomicU64::new(0),
            signature_verification: AtomicU64::new(0),
            vulnerability_count: AtomicU64::new(0),
            last_scan_time: AtomicU64::new(0),
        }
    }
    
    pub fn set_slsa_level(&self, level: u64) {
        self.slsa_level.store(level, Ordering::SeqCst);
    }
    
    pub fn set_sbom_completeness(&self, completeness: u64) {
        self.sbom_completeness.store(completeness, Ordering::SeqCst);
    }
    
    pub fn set_signature_verification(&self, verified: bool) {
        self.signature_verification.store(if verified { 1 } else { 0 }, Ordering::SeqCst);
    }
    
    pub fn set_vulnerability_count(&self, count: u64) {
        self.vulnerability_count.store(count, Ordering::SeqCst);
    }
    
    pub fn update_scan_time(&self) {
        self.last_scan_time.store(
            std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs(),
            Ordering::SeqCst
        );
    }
    
    pub fn get_metrics(&self) -> String {
        format!(
            "security_slsa_level {}\n\
             security_sbom_completeness {}\n\
             security_signature_verification {}\n\
             security_vulnerability_count {}\n\
             security_last_scan_time {}",
            self.slsa_level.load(Ordering::SeqCst),
            self.sbom_completeness.load(Ordering::SeqCst),
            self.signature_verification.load(Ordering::SeqCst),
            self.vulnerability_count.load(Ordering::SeqCst),
            self.last_scan_time.load(Ordering::SeqCst),
        )
    }
}
```

### Prometheus 规则

```yaml
# prometheus-rules.yaml
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: security-rules
  namespace: monitoring
spec:
  groups:
  - name: security
    rules:
    - alert: HighVulnerabilityCount
      expr: security_vulnerability_count > 10
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "High vulnerability count detected"
        description: "Vulnerability count is {{ $value }}"
    
    - alert: SLSALevelLow
      expr: security_slsa_level < 3
      for: 1m
      labels:
        severity: critical
      annotations:
        summary: "SLSA level is too low"
        description: "SLSA level is {{ $value }}, should be >= 3"
    
    - alert: SignatureVerificationFailed
      expr: security_signature_verification == 0
      for: 1m
      labels:
        severity: critical
      annotations:
        summary: "Signature verification failed"
        description: "Artifact signature verification failed"
    
    - alert: SBOMIncomplete
      expr: security_sbom_completeness < 80
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "SBOM is incomplete"
        description: "SBOM completeness is {{ $value }}%"
```

## 9.5.8 总结

供应链安全实践包括：

1. **SLSA 构建**：可重现、可验证、可审计的构建过程
2. **SBOM 管理**：完整的软件物料清单
3. **漏洞扫描**：自动化安全扫描和修复
4. **签名验证**：数字签名确保完整性
5. **策略即代码**：自动化安全策略执行
6. **监控告警**：实时安全状态监控

通过实施这些实践，可以确保微服务供应链的安全性和可信度，降低安全风险，提高系统的整体安全性。
