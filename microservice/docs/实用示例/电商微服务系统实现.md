# 电商微服务系统实现

## 概述

本文档展示了一个完整的电商微服务系统的实现，包括用户服务、商品服务、订单服务、支付服务等核心模块。通过这个实际案例，开发者可以学习如何设计和实现一个生产级的微服务系统。

## 系统架构

```mermaid
graph TB
    A[API网关] --> B[用户服务]
    A --> C[商品服务]
    A --> D[订单服务]
    A --> E[支付服务]
    A --> F[库存服务]
    
    B --> G[用户数据库]
    C --> H[商品数据库]
    D --> I[订单数据库]
    E --> J[支付数据库]
    F --> K[库存数据库]
    
    L[消息队列] --> B
    L --> C
    L --> D
    L --> E
    L --> F
    
    M[Redis缓存] --> B
    M --> C
    M --> D
```

## 核心服务实现

### 1. 用户服务

```rust
// 用户服务主文件
use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::Json,
    routing::{get, post},
    Router,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[derive(Clone)]
pub struct AppState {
    pub user_service: Arc<UserService>,
    pub event_publisher: Arc<EventPublisher>,
}

#[tokio::main]
async fn main() {
    // 初始化数据库连接
    let database = Database::new("postgresql://localhost:5432/ecommerce").await;
    
    // 初始化服务
    let user_repository = Arc::new(PostgresUserRepository::new(database.clone()));
    let event_publisher = Arc::new(RabbitMQEventPublisher::new("amqp://localhost:5672").await);
    let user_service = Arc::new(UserService::new(user_repository, event_publisher.clone()));
    
    let app_state = AppState {
        user_service,
        event_publisher,
    };
    
    // 构建路由
    let app = Router::new()
        .route("/users", post(create_user))
        .route("/users/:id", get(get_user))
        .route("/users/:id", post(update_user))
        .route("/users/:id/orders", get(get_user_orders))
        .with_state(app_state);
    
    // 启动服务器
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3001").await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

// 用户创建请求
#[derive(Deserialize)]
pub struct CreateUserRequest {
    pub username: String,
    pub email: String,
    pub password: String,
    pub full_name: String,
}

// 用户响应
#[derive(Serialize)]
pub struct UserResponse {
    pub id: String,
    pub username: String,
    pub email: String,
    pub full_name: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
}

// 创建用户处理器
async fn create_user(
    State(state): State<AppState>,
    Json(payload): Json<CreateUserRequest>,
) -> Result<Json<UserResponse>, StatusCode> {
    let create_user_command = CreateUserCommand {
        username: payload.username,
        email: payload.email,
        password: payload.password,
        full_name: payload.full_name,
    };
    
    match state.user_service.create_user(create_user_command).await {
        Ok(user) => Ok(Json(UserResponse {
            id: user.id.to_string(),
            username: user.username,
            email: user.email,
            full_name: user.full_name,
            created_at: user.created_at,
        })),
        Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
    }
}

// 获取用户处理器
async fn get_user(
    State(state): State<AppState>,
    Path(user_id): Path<String>,
) -> Result<Json<UserResponse>, StatusCode> {
    let user_id = UserId::from_str(&user_id).map_err(|_| StatusCode::BAD_REQUEST)?;
    
    match state.user_service.get_user(user_id).await {
        Ok(Some(user)) => Ok(Json(UserResponse {
            id: user.id.to_string(),
            username: user.username,
            email: user.email,
            full_name: user.full_name,
            created_at: user.created_at,
        })),
        Ok(None) => Err(StatusCode::NOT_FOUND),
        Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
    }
}
```

### 2. 商品服务

```rust
// 商品服务实现
use std::collections::HashMap;

pub struct ProductService {
    product_repository: Arc<dyn ProductRepository>,
    cache: Arc<dyn Cache>,
    event_publisher: Arc<dyn EventPublisher>,
}

impl ProductService {
    pub async fn create_product(&self, command: CreateProductCommand) -> Result<Product, ProductError> {
        // 1. 验证商品信息
        self.validate_product(&command)?;
        
        // 2. 创建商品
        let product = Product::new(
            command.name,
            command.description,
            command.price,
            command.category_id,
            command.sku,
            command.stock_quantity,
        );
        
        // 3. 保存到数据库
        self.product_repository.save(&product).await?;
        
        // 4. 更新缓存
        self.cache.set(
            &format!("product:{}", product.id),
            &product,
            Duration::from_secs(3600),
        ).await?;
        
        // 5. 发布事件
        self.event_publisher.publish(ProductEvent::Created {
            product_id: product.id,
            name: product.name.clone(),
            price: product.price,
        }).await?;
        
        Ok(product)
    }
    
    pub async fn get_product(&self, product_id: ProductId) -> Result<Option<Product>, ProductError> {
        // 1. 尝试从缓存获取
        if let Some(product) = self.cache.get::<Product>(&format!("product:{}", product_id)).await? {
            return Ok(Some(product));
        }
        
        // 2. 从数据库获取
        let product = self.product_repository.find_by_id(product_id).await?;
        
        // 3. 更新缓存
        if let Some(ref product) = product {
            self.cache.set(
                &format!("product:{}", product.id),
                product,
                Duration::from_secs(3600),
            ).await?;
        }
        
        Ok(product)
    }
    
    pub async fn update_stock(&self, product_id: ProductId, quantity: i32) -> Result<(), ProductError> {
        // 1. 获取商品
        let mut product = self.product_repository.find_by_id(product_id).await?
            .ok_or(ProductError::ProductNotFound)?;
        
        // 2. 更新库存
        product.update_stock(quantity)?;
        
        // 3. 保存到数据库
        self.product_repository.save(&product).await?;
        
        // 4. 更新缓存
        self.cache.set(
            &format!("product:{}", product.id),
            &product,
            Duration::from_secs(3600),
        ).await?;
        
        // 5. 发布库存变更事件
        self.event_publisher.publish(ProductEvent::StockUpdated {
            product_id: product.id,
            old_stock: product.stock_quantity + quantity,
            new_stock: product.stock_quantity,
        }).await?;
        
        Ok(())
    }
    
    fn validate_product(&self, command: &CreateProductCommand) -> Result<(), ProductError> {
        if command.name.is_empty() {
            return Err(ProductError::InvalidName);
        }
        
        if command.price <= 0 {
            return Err(ProductError::InvalidPrice);
        }
        
        if command.stock_quantity < 0 {
            return Err(ProductError::InvalidStock);
        }
        
        Ok(())
    }
}
```

### 3. 订单服务

```rust
// 订单服务实现
pub struct OrderService {
    order_repository: Arc<dyn OrderRepository>,
    product_service: Arc<dyn ProductService>,
    user_service: Arc<dyn UserService>,
    event_publisher: Arc<dyn EventPublisher>,
    saga_orchestrator: Arc<SagaOrchestrator>,
}

impl OrderService {
    pub async fn create_order(&self, command: CreateOrderCommand) -> Result<Order, OrderError> {
        // 1. 验证用户存在
        self.user_service.get_user(command.user_id).await?
            .ok_or(OrderError::UserNotFound)?;
        
        // 2. 验证商品和库存
        let mut order_items = Vec::new();
        let mut total_amount = 0.0;
        
        for item in &command.items {
            let product = self.product_service.get_product(item.product_id).await?
                .ok_or(OrderError::ProductNotFound)?;
            
            if product.stock_quantity < item.quantity {
                return Err(OrderError::InsufficientStock);
            }
            
            let item_total = product.price * item.quantity as f64;
            total_amount += item_total;
            
            order_items.push(OrderItem {
                product_id: item.product_id,
                quantity: item.quantity,
                unit_price: product.price,
                total_price: item_total,
            });
        }
        
        // 3. 创建订单
        let order = Order::new(
            command.user_id,
            order_items,
            total_amount,
            command.shipping_address,
        );
        
        // 4. 保存订单
        self.order_repository.save(&order).await?;
        
        // 5. 启动订单处理Saga
        let saga_context = OrderSagaContext {
            order_id: order.id,
            user_id: order.user_id,
            items: command.items,
            total_amount,
        };
        
        self.saga_orchestrator.execute_saga(
            SagaId::new(),
            saga_context,
        ).await?;
        
        Ok(order)
    }
    
    pub async fn get_order(&self, order_id: OrderId) -> Result<Option<Order>, OrderError> {
        self.order_repository.find_by_id(order_id).await
    }
    
    pub async fn update_order_status(&self, order_id: OrderId, status: OrderStatus) -> Result<(), OrderError> {
        let mut order = self.order_repository.find_by_id(order_id).await?
            .ok_or(OrderError::OrderNotFound)?;
        
        let old_status = order.status;
        order.update_status(status);
        
        self.order_repository.save(&order).await?;
        
        // 发布订单状态变更事件
        self.event_publisher.publish(OrderEvent::StatusChanged {
            order_id: order.id,
            old_status,
            new_status: order.status,
        }).await?;
        
        Ok(())
    }
}
```

### 4. 支付服务

```rust
// 支付服务实现
pub struct PaymentService {
    payment_repository: Arc<dyn PaymentRepository>,
    payment_gateway: Arc<dyn PaymentGateway>,
    event_publisher: Arc<dyn EventPublisher>,
}

impl PaymentService {
    pub async fn process_payment(&self, command: ProcessPaymentCommand) -> Result<Payment, PaymentError> {
        // 1. 创建支付记录
        let payment = Payment::new(
            command.order_id,
            command.amount,
            command.payment_method,
            command.card_token,
        );
        
        // 2. 保存支付记录
        self.payment_repository.save(&payment).await?;
        
        // 3. 调用支付网关
        let gateway_result = self.payment_gateway.process_payment(PaymentRequest {
            amount: command.amount,
            currency: "USD".to_string(),
            payment_method: command.payment_method,
            card_token: command.card_token,
            order_id: command.order_id.to_string(),
        }).await?;
        
        // 4. 更新支付状态
        let mut payment = payment;
        payment.update_status(gateway_result.status);
        payment.set_transaction_id(gateway_result.transaction_id);
        
        self.payment_repository.save(&payment).await?;
        
        // 5. 发布支付事件
        self.event_publisher.publish(PaymentEvent::Processed {
            payment_id: payment.id,
            order_id: payment.order_id,
            amount: payment.amount,
            status: payment.status,
        }).await?;
        
        Ok(payment)
    }
    
    pub async fn refund_payment(&self, payment_id: PaymentId, amount: f64) -> Result<Refund, PaymentError> {
        let payment = self.payment_repository.find_by_id(payment_id).await?
            .ok_or(PaymentError::PaymentNotFound)?;
        
        if payment.status != PaymentStatus::Completed {
            return Err(PaymentError::InvalidPaymentStatus);
        }
        
        if amount > payment.amount {
            return Err(PaymentError::RefundAmountExceedsPayment);
        }
        
        // 调用支付网关退款
        let refund_result = self.payment_gateway.refund_payment(RefundRequest {
            transaction_id: payment.transaction_id.clone(),
            amount,
            reason: "Customer request".to_string(),
        }).await?;
        
        // 创建退款记录
        let refund = Refund::new(
            payment_id,
            amount,
            refund_result.refund_id,
            RefundStatus::Completed,
        );
        
        self.payment_repository.save_refund(&refund).await?;
        
        // 发布退款事件
        self.event_publisher.publish(PaymentEvent::Refunded {
            payment_id,
            refund_id: refund.id,
            amount,
        }).await?;
        
        Ok(refund)
    }
}
```

## 部署配置

### Docker Compose配置

```yaml
version: '3.8'

services:
  # 数据库服务
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: ecommerce
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  # Redis缓存
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  # RabbitMQ消息队列
  rabbitmq:
    image: rabbitmq:3-management
    environment:
      RABBITMQ_DEFAULT_USER: admin
      RABBITMQ_DEFAULT_PASS: password
    ports:
      - "5672:5672"
      - "15672:15672"
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq

  # 用户服务
  user-service:
    build: ./services/user-service
    ports:
      - "3001:3001"
    environment:
      DATABASE_URL: postgresql://postgres:password@postgres:5432/ecommerce
      REDIS_URL: redis://redis:6379
      RABBITMQ_URL: amqp://admin:password@rabbitmq:5672
    depends_on:
      - postgres
      - redis
      - rabbitmq

  # 商品服务
  product-service:
    build: ./services/product-service
    ports:
      - "3002:3002"
    environment:
      DATABASE_URL: postgresql://postgres:password@postgres:5432/ecommerce
      REDIS_URL: redis://redis:6379
      RABBITMQ_URL: amqp://admin:password@rabbitmq:5672
    depends_on:
      - postgres
      - redis
      - rabbitmq

  # 订单服务
  order-service:
    build: ./services/order-service
    ports:
      - "3003:3003"
    environment:
      DATABASE_URL: postgresql://postgres:password@postgres:5432/ecommerce
      REDIS_URL: redis://redis:6379
      RABBITMQ_URL: amqp://admin:password@rabbitmq:5672
      USER_SERVICE_URL: http://user-service:3001
      PRODUCT_SERVICE_URL: http://product-service:3002
    depends_on:
      - postgres
      - redis
      - rabbitmq
      - user-service
      - product-service

  # 支付服务
  payment-service:
    build: ./services/payment-service
    ports:
      - "3004:3004"
    environment:
      DATABASE_URL: postgresql://postgres:password@postgres:5432/ecommerce
      REDIS_URL: redis://redis:6379
      RABBITMQ_URL: amqp://admin:password@rabbitmq:5672
    depends_on:
      - postgres
      - redis
      - rabbitmq

  # API网关
  api-gateway:
    build: ./gateway
    ports:
      - "8080:8080"
    environment:
      USER_SERVICE_URL: http://user-service:3001
      PRODUCT_SERVICE_URL: http://product-service:3002
      ORDER_SERVICE_URL: http://order-service:3003
      PAYMENT_SERVICE_URL: http://payment-service:3004
    depends_on:
      - user-service
      - product-service
      - order-service
      - payment-service

volumes:
  postgres_data:
  redis_data:
  rabbitmq_data:
```

### Kubernetes部署配置

```yaml
# 用户服务部署
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
    spec:
      containers:
      - name: user-service
        image: ecommerce/user-service:latest
        ports:
        - containerPort: 3001
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: database-secret
              key: url
        - name: REDIS_URL
          valueFrom:
            configMapKeyRef:
              name: redis-config
              key: url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3001
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 3001
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: user-service
spec:
  selector:
    app: user-service
  ports:
  - port: 3001
    targetPort: 3001
  type: ClusterIP
```

## 测试策略

### 单元测试示例

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use mockall::predicate::*;
    use tokio_test;

    #[tokio::test]
    async fn test_create_user_success() {
        // 准备测试数据
        let mut mock_repository = MockUserRepository::new();
        let mut mock_event_publisher = MockEventPublisher::new();
        
        // 设置mock期望
        mock_repository
            .expect_save()
            .with(eq(any()))
            .times(1)
            .returning(|_| Ok(()));
        
        mock_event_publisher
            .expect_publish()
            .with(eq(any()))
            .times(1)
            .returning(|_| Ok(()));
        
        // 创建服务
        let user_service = UserService::new(
            Arc::new(mock_repository),
            Arc::new(mock_event_publisher),
        );
        
        // 执行测试
        let command = CreateUserCommand {
            username: "testuser".to_string(),
            email: "test@example.com".to_string(),
            password: "password123".to_string(),
            full_name: "Test User".to_string(),
        };
        
        let result = user_service.create_user(command).await;
        
        // 验证结果
        assert!(result.is_ok());
        let user = result.unwrap();
        assert_eq!(user.username, "testuser");
        assert_eq!(user.email, "test@example.com");
    }
    
    #[tokio::test]
    async fn test_create_user_duplicate_username() {
        // 准备测试数据
        let mut mock_repository = MockUserRepository::new();
        let mock_event_publisher = MockEventPublisher::new();
        
        // 设置mock期望 - 用户名已存在
        mock_repository
            .expect_find_by_username()
            .with(eq("existinguser"))
            .times(1)
            .returning(|_| Ok(Some(User::new(
                UserId::new(),
                "existinguser".to_string(),
                "existing@example.com".to_string(),
                "Existing User".to_string(),
            ))));
        
        // 创建服务
        let user_service = UserService::new(
            Arc::new(mock_repository),
            Arc::new(mock_event_publisher),
        );
        
        // 执行测试
        let command = CreateUserCommand {
            username: "existinguser".to_string(),
            email: "new@example.com".to_string(),
            password: "password123".to_string(),
            full_name: "New User".to_string(),
        };
        
        let result = user_service.create_user(command).await;
        
        // 验证结果
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), UserError::UsernameAlreadyExists);
    }
}
```

### 集成测试示例

```rust
#[cfg(test)]
mod integration_tests {
    use super::*;
    use testcontainers::*;
    use testcontainers::images::postgres::Postgres;
    use testcontainers::images::redis::Redis;

    #[tokio::test]
    async fn test_user_service_integration() {
        // 启动测试容器
        let docker = clients::Cli::default();
        let postgres_image = Postgres::default();
        let redis_image = Redis::default();
        
        let postgres_container = docker.run(postgres_image);
        let redis_container = docker.run(redis_image);
        
        // 获取连接信息
        let postgres_port = postgres_container.get_host_port_ipv4(5432);
        let redis_port = redis_container.get_host_port_ipv4(6379);
        
        let database_url = format!("postgresql://postgres:postgres@localhost:{}/postgres", postgres_port);
        let redis_url = format!("redis://localhost:{}", redis_port);
        
        // 初始化数据库
        let database = Database::new(&database_url).await;
        database.run_migrations().await;
        
        // 创建服务
        let user_repository = Arc::new(PostgresUserRepository::new(database));
        let event_publisher = Arc::new(MockEventPublisher::new());
        let user_service = UserService::new(user_repository, event_publisher);
        
        // 执行测试
        let command = CreateUserCommand {
            username: "integrationtest".to_string(),
            email: "integration@example.com".to_string(),
            password: "password123".to_string(),
            full_name: "Integration Test".to_string(),
        };
        
        let result = user_service.create_user(command).await;
        assert!(result.is_ok());
        
        let user = result.unwrap();
        let retrieved_user = user_service.get_user(user.id).await.unwrap();
        assert!(retrieved_user.is_some());
        assert_eq!(retrieved_user.unwrap().username, "integrationtest");
    }
}
```

## 监控和日志

### 健康检查实现

```rust
// 健康检查处理器
async fn health_check(State(state): State<AppState>) -> Json<HealthStatus> {
    let mut status = HealthStatus {
        status: "healthy".to_string(),
        timestamp: chrono::Utc::now(),
        services: HashMap::new(),
    };
    
    // 检查数据库连接
    match state.user_service.check_database_health().await {
        Ok(_) => {
            status.services.insert("database".to_string(), "healthy".to_string());
        }
        Err(_) => {
            status.services.insert("database".to_string(), "unhealthy".to_string());
            status.status = "unhealthy".to_string();
        }
    }
    
    // 检查Redis连接
    match state.user_service.check_cache_health().await {
        Ok(_) => {
            status.services.insert("cache".to_string(), "healthy".to_string());
        }
        Err(_) => {
            status.services.insert("cache".to_string(), "unhealthy".to_string());
            status.status = "unhealthy".to_string();
        }
    }
    
    // 检查消息队列
    match state.event_publisher.check_health().await {
        Ok(_) => {
            status.services.insert("message_queue".to_string(), "healthy".to_string());
        }
        Err(_) => {
            status.services.insert("message_queue".to_string(), "unhealthy".to_string());
            status.status = "unhealthy".to_string();
        }
    }
    
    Json(status)
}
```

### 指标收集

```rust
// 指标收集器
use prometheus::{Counter, Histogram, Registry, TextEncoder};

pub struct MetricsCollector {
    request_counter: Counter,
    request_duration: Histogram,
    registry: Registry,
}

impl MetricsCollector {
    pub fn new() -> Self {
        let registry = Registry::new();
        
        let request_counter = Counter::new(
            "http_requests_total",
            "Total number of HTTP requests"
        ).unwrap();
        
        let request_duration = Histogram::new(
            "http_request_duration_seconds",
            "HTTP request duration in seconds"
        ).unwrap();
        
        registry.register(Box::new(request_counter.clone())).unwrap();
        registry.register(Box::new(request_duration.clone())).unwrap();
        
        Self {
            request_counter,
            request_duration,
            registry,
        }
    }
    
    pub fn record_request(&self, method: &str, path: &str, status_code: u16, duration: f64) {
        self.request_counter.inc();
        self.request_duration.observe(duration);
    }
    
    pub async fn get_metrics(&self) -> String {
        let metric_families = self.registry.gather();
        TextEncoder::new().encode_to_string(&metric_families).unwrap()
    }
}
```

## 高级实现细节

### 1. 完整的错误处理系统

```rust
// 统一错误处理
use thiserror::Error;
use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};

#[derive(Error, Debug)]
pub enum AppError {
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),
    
    #[error("Validation error: {0}")]
    Validation(#[from] validator::ValidationErrors),
    
    #[error("Authentication error: {0}")]
    Authentication(String),
    
    #[error("Authorization error: {0}")]
    Authorization(String),
    
    #[error("Business logic error: {0}")]
    BusinessLogic(String),
    
    #[error("External service error: {0}")]
    ExternalService(String),
    
    #[error("Configuration error: {0}")]
    Configuration(String),
    
    #[error("Internal server error: {0}")]
    Internal(#[from] anyhow::Error),
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let (status, error_message) = match self {
            AppError::Database(_) => (
                StatusCode::INTERNAL_SERVER_ERROR,
                "Database operation failed".to_string(),
            ),
            AppError::Validation(_) => (
                StatusCode::BAD_REQUEST,
                "Validation failed".to_string(),
            ),
            AppError::Authentication(msg) => (
                StatusCode::UNAUTHORIZED,
                format!("Authentication failed: {}", msg),
            ),
            AppError::Authorization(msg) => (
                StatusCode::FORBIDDEN,
                format!("Authorization failed: {}", msg),
            ),
            AppError::BusinessLogic(msg) => (
                StatusCode::UNPROCESSABLE_ENTITY,
                format!("Business logic error: {}", msg),
            ),
            AppError::ExternalService(msg) => (
                StatusCode::BAD_GATEWAY,
                format!("External service error: {}", msg),
            ),
            AppError::Configuration(msg) => (
                StatusCode::INTERNAL_SERVER_ERROR,
                format!("Configuration error: {}", msg),
            ),
            AppError::Internal(_) => (
                StatusCode::INTERNAL_SERVER_ERROR,
                "Internal server error".to_string(),
            ),
        };

        let body = Json(serde_json::json!({
            "error": error_message,
            "code": status.as_u16(),
            "timestamp": chrono::Utc::now()
        }));

        (status, body).into_response()
    }
}
```

### 2. 配置管理系统

```rust
// 配置管理
use config::{Config, ConfigError, Environment, File};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct AppConfig {
    pub server: ServerConfig,
    pub database: DatabaseConfig,
    pub redis: RedisConfig,
    pub jwt: JwtConfig,
    pub logging: LoggingConfig,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ServerConfig {
    pub host: String,
    pub port: u16,
    pub workers: Option<usize>,
    pub max_connections: Option<usize>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct DatabaseConfig {
    pub url: String,
    pub max_connections: u32,
    pub min_connections: u32,
    pub acquire_timeout: u64,
}

impl AppConfig {
    pub fn load() -> Result<Self, ConfigError> {
        let run_mode = env::var("RUN_MODE").unwrap_or_else(|_| "development".into());
        
        let config = Config::builder()
            .add_source(File::with_name("config/default"))
            .add_source(File::with_name(&format!("config/{}", run_mode)).required(false))
            .add_source(Environment::with_prefix("APP").separator("_"))
            .build()?;
        
        config.try_deserialize()
    }
}
```

### 3. 高级中间件系统

```rust
// 请求限流中间件
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;

pub struct RateLimiter {
    limits: Arc<RwLock<HashMap<String, RateLimitInfo>>>,
    default_limit: RateLimitInfo,
}

#[derive(Debug, Clone)]
pub struct RateLimitInfo {
    pub requests: u32,
    pub window: Duration,
    pub burst: u32,
}

impl RateLimiter {
    pub fn new(default_limit: RateLimitInfo) -> Self {
        Self {
            limits: Arc::new(RwLock::new(HashMap::new())),
            default_limit,
        }
    }
    
    pub async fn check_rate_limit(&self, key: &str) -> Result<(), RateLimitError> {
        let mut limits = self.limits.write().await;
        let limit_info = limits.get(key).unwrap_or(&self.default_limit);
        
        if limit_info.requests >= limit_info.burst {
            return Err(RateLimitError::TooManyRequests);
        }
        
        Ok(())
    }
}
```

## 最佳实践总结

### 1. 服务设计

- **单一职责**: 每个服务只负责一个业务领域
- **数据隔离**: 每个服务拥有独立的数据存储
- **接口设计**: 设计稳定、版本化的API接口
- **错误处理**: 统一的错误处理和响应格式

### 2. 数据管理

- **事务处理**: 使用Saga模式处理分布式事务
- **数据一致性**: 采用最终一致性模型
- **缓存策略**: 合理使用缓存提高性能
- **数据迁移**: 设计数据迁移和版本管理策略

### 3. 通信机制

- **同步通信**: 使用HTTP/gRPC进行同步通信
- **异步通信**: 使用消息队列进行异步通信
- **服务发现**: 实现动态服务注册和发现
- **负载均衡**: 实现智能负载均衡策略

### 4. 监控运维

- **健康检查**: 实现全面的健康检查机制
- **指标收集**: 收集关键业务和技术指标
- **日志管理**: 结构化日志和集中化收集
- **告警机制**: 智能告警和故障自愈

### 5. 安全考虑

- **身份认证**: 实现JWT认证机制
- **授权管理**: 细粒度权限控制
- **数据加密**: 传输和存储数据加密
- **安全审计**: 完整的操作审计日志

---

**文档版本**: v1.0  
**最后更新**: 2025-01-XX  
**维护者**: 开发团队
