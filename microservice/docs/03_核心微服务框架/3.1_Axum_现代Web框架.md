# 3.1 Axum 现代Web框架

## 📋 目录

- [3.1 Axum 现代Web框架](#31-axum-现代web框架)
  - [📋 目录](#-目录)
  - [Axum简介](#axum简介)
    - [设计理念](#设计理念)
  - [核心特性](#核心特性)
    - [类型安全的路由](#类型安全的路由)
    - [强大的提取器](#强大的提取器)
  - [快速开始](#快速开始)
    - [基本服务器](#基本服务器)
    - [微服务结构](#微服务结构)
  - [路由系统](#路由系统)
    - [路由定义](#路由定义)
    - [路由参数](#路由参数)
  - [中间件](#中间件)
    - [内置中间件](#内置中间件)
    - [自定义中间件](#自定义中间件)
    - [中间件组合](#中间件组合)
  - [错误处理](#错误处理)
    - [自定义错误类型](#自定义错误类型)
    - [错误恢复](#错误恢复)
  - [异步处理](#异步处理)
    - [异步处理器](#异步处理器)
    - [流式响应](#流式响应)
  - [性能优化](#性能优化)
    - [连接池优化](#连接池优化)
    - [缓存策略](#缓存策略)
    - [压缩和静态文件](#压缩和静态文件)
  - [实际案例](#实际案例)
    - [完整的微服务示例](#完整的微服务示例)
  - [最佳实践](#最佳实践)
    - [1. 状态管理](#1-状态管理)
    - [2. 错误处理](#2-错误处理)
    - [3. 中间件使用](#3-中间件使用)
    - [4. 测试](#4-测试)
  - [总结](#总结)
  - [进阶模式（Rust 1.90 对齐）](#进阶模式rust-190-对齐)
    - [可观测性：Tracing + OpenTelemetry + Metrics](#可观测性tracing--opentelemetry--metrics)
    - [可靠性：超时/重试/熔断/退避](#可靠性超时重试熔断退避)
    - [限流与背压](#限流与背压)
    - [优雅关闭与健康检查（liveness/readiness）](#优雅关闭与健康检查livenessreadiness)
    - [安全：JWT/OIDC（简化）](#安全jwtoidc简化)
    - [配置与特性开关（feature flags）](#配置与特性开关feature-flags)
    - [与第14章蓝图的对齐](#与第14章蓝图的对齐)

## Axum简介

Axum是由Tokio团队开发的现代、高性能的Rust Web框架，专为异步编程和微服务架构设计。
它基于hyper和tower生态系统构建，提供了简洁的API和强大的类型安全保证。

### 设计理念

- **类型安全**: 利用Rust的类型系统确保API的正确性
- **异步优先**: 完全基于async/await的异步编程模型
- **模块化**: 可组合的中间件和处理器
- **性能**: 零成本抽象，接近原生性能

## 核心特性

### 类型安全的路由

```rust
use axum::{
    extract::{Path, Query},
    http::StatusCode,
    response::Json,
    routing::get,
    Router,
};
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
struct User {
    id: u64,
    name: String,
    email: String,
}

#[derive(Deserialize)]
struct UserQuery {
    page: Option<u32>,
    limit: Option<u32>,
}

// 类型安全的路由处理器
async fn get_user(Path(id): Path<u64>) -> Result<Json<User>, StatusCode> {
    // 编译器确保路径参数类型正确
    match find_user(id).await {
        Some(user) => Ok(Json(user)),
        None => Err(StatusCode::NOT_FOUND),
    }
}

async fn list_users(Query(params): Query<UserQuery>) -> Json<Vec<User>> {
    // 查询参数自动解析和验证
    let users = get_users(params.page, params.limit).await;
    Json(users)
}
```

### 强大的提取器

```rust
use axum::{
    extract::{
        ConnectInfo, FromRequest, FromRequestParts, 
        Host, OriginalUri, Query, Request,
    },
    http::request::Parts,
};

// 自定义提取器
#[derive(FromRequest)]
#[from_request(state = AppState)]
struct AuthenticatedUser {
    user: User,
    token: String,
}

#[async_trait::async_trait]
impl<S> FromRequest<S> for AuthenticatedUser
where
    S: Send + Sync,
{
    type Rejection = StatusCode;

    async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
        let (parts, body) = req.into_parts();
        
        // 从请求头提取认证信息
        let auth_header = parts
            .headers
            .get("authorization")
            .and_then(|h| h.to_str().ok())
            .ok_or(StatusCode::UNAUTHORIZED)?;
            
        // 验证token并获取用户信息
        let token = auth_header.strip_prefix("Bearer ").unwrap_or(auth_header);
        let user = validate_token(token).await.map_err(|_| StatusCode::UNAUTHORIZED)?;
        
        Ok(AuthenticatedUser {
            user,
            token: token.to_string(),
        })
    }
}

// 使用自定义提取器
async fn protected_route(user: AuthenticatedUser) -> Json<User> {
    Json(user.user)
}
```

## 快速开始

### 基本服务器

```rust
use axum::{
    response::Html,
    routing::get,
    Router,
};
use tokio::net::TcpListener;

#[tokio::main]
async fn main() {
    // 构建路由
    let app = Router::new()
        .route("/", get(root))
        .route("/health", get(health_check));

    // 启动服务器
    let listener = TcpListener::bind("0.0.0.0:3000").await.unwrap();
    println!("Server running on http://0.0.0.0:3000");
    
    axum::serve(listener, app).await.unwrap();
}

async fn root() -> Html<&'static str> {
    Html("<h1>Hello, Axum!</h1>")
}

async fn health_check() -> &'static str {
    "OK"
}
```

### 微服务结构

```rust
use axum::{
    extract::State,
    response::Json,
    routing::{get, post},
    Router,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[derive(Clone)]
struct AppState {
    database: Arc<DatabasePool>,
    cache: Arc<RedisClient>,
    metrics: Arc<MetricsCollector>,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 初始化应用状态
    let state = AppState {
        database: Arc::new(DatabasePool::new().await?),
        cache: Arc::new(RedisClient::new().await?),
        metrics: Arc::new(MetricsCollector::new()),
    };

    // 构建API路由
    let app = Router::new()
        .route("/api/users", post(create_user))
        .route("/api/users/:id", get(get_user))
        .route("/api/users/:id", post(update_user))
        .route("/health", get(health_check))
        .with_state(state);

    // 启动服务器
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await?;
    axum::serve(listener, app).await?;
    
    Ok(())
}
```

## 路由系统

### 路由定义

```rust
use axum::{
    routing::{get, post, put, delete},
    Router,
};

fn create_user_routes() -> Router {
    Router::new()
        .route("/users", post(create_user))
        .route("/users/:id", get(get_user))
        .route("/users/:id", put(update_user))
        .route("/users/:id", delete(delete_user))
        .route("/users/:id/posts", get(get_user_posts))
        .route("/users/:id/posts", post(create_user_post))
}

fn create_post_routes() -> Router {
    Router::new()
        .route("/posts", get(list_posts))
        .route("/posts", post(create_post))
        .route("/posts/:id", get(get_post))
        .route("/posts/:id", put(update_post))
        .route("/posts/:id", delete(delete_post))
}

// 嵌套路由
fn create_api_routes() -> Router {
    Router::new()
        .nest("/api/v1", create_user_routes())
        .nest("/api/v1", create_post_routes())
        .route("/api/health", get(health_check))
}
```

### 路由参数

```rust
use axum::{
    extract::{Path, Query},
    http::StatusCode,
    response::Json,
};

#[derive(Deserialize)]
struct PaginationQuery {
    page: Option<u32>,
    limit: Option<u32>,
}

#[derive(Deserialize)]
struct UserPath {
    user_id: u64,
}

#[derive(Deserialize)]
struct PostPath {
    user_id: u64,
    post_id: u64,
}

// 路径参数提取
async fn get_user(Path(user_id): Path<u64>) -> Result<Json<User>, StatusCode> {
    match find_user_by_id(user_id).await {
        Some(user) => Ok(Json(user)),
        None => Err(StatusCode::NOT_FOUND),
    }
}

// 嵌套路径参数
async fn get_user_post(
    Path(PostPath { user_id, post_id }): Path<PostPath>,
) -> Result<Json<Post>, StatusCode> {
    match find_user_post(user_id, post_id).await {
        Some(post) => Ok(Json(post)),
        None => Err(StatusCode::NOT_FOUND),
    }
}

// 查询参数
async fn list_users(
    Query(pagination): Query<PaginationQuery>,
) -> Json<Vec<User>> {
    let page = pagination.page.unwrap_or(1);
    let limit = pagination.limit.unwrap_or(10);
    
    let users = get_users_paginated(page, limit).await;
    Json(users)
}
```

## 中间件

### 内置中间件

```rust
use axum::{
    middleware,
    response::Response,
    routing::get,
    Router,
};
use tower::ServiceBuilder;
use tower_http::{
    cors::CorsLayer,
    compression::CompressionLayer,
    trace::TraceLayer,
    timeout::TimeoutLayer,
};

fn create_app() -> Router {
    Router::new()
        .route("/", get(handler))
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(CompressionLayer::new())
                .layer(CorsLayer::permissive())
                .layer(TimeoutLayer::new(Duration::from_secs(30)))
        )
}

async fn handler() -> &'static str {
    "Hello, Middleware!"
}
```

### 自定义中间件

```rust
use axum::{
    extract::Request,
    http::{HeaderValue, StatusCode},
    middleware::Next,
    response::Response,
};
use tower::ServiceBuilder;
use std::time::Instant;

// 请求ID中间件
pub async fn request_id_middleware(
    mut request: Request,
    next: Next,
) -> Response {
    let request_id = uuid::Uuid::new_v4().to_string();
    request.headers_mut().insert(
        "x-request-id",
        HeaderValue::from_str(&request_id).unwrap(),
    );
    
    let mut response = next.run(request).await;
    response.headers_mut().insert(
        "x-request-id",
        HeaderValue::from_str(&request_id).unwrap(),
    );
    
    response
}

// 性能监控中间件
pub async fn metrics_middleware(
    request: Request,
    next: Next,
) -> Response {
    let start = Instant::now();
    let method = request.method().clone();
    let path = request.uri().path().to_string();
    
    let mut response = next.run(request).await;
    let duration = start.elapsed();
    
    // 记录指标
    record_request_metrics(&method, &path, response.status(), duration);
    
    response
}

// 认证中间件
pub async fn auth_middleware(
    mut request: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    let auth_header = request
        .headers()
        .get("authorization")
        .and_then(|h| h.to_str().ok());
        
    match auth_header {
        Some(token) if validate_token(token).await => {
            Ok(next.run(request).await)
        }
        _ => Err(StatusCode::UNAUTHORIZED),
    }
}
```

### 中间件组合

```rust
use tower::ServiceBuilder;

fn create_app_with_middleware() -> Router {
    Router::new()
        .route("/", get(handler))
        .layer(
            ServiceBuilder::new()
                .layer(middleware::from_fn(request_id_middleware))
                .layer(middleware::from_fn(metrics_middleware))
                .layer(middleware::from_fn_with_state(
                    auth_middleware,
                    app_state.clone(),
                ))
        )
}
```

## 错误处理

### 自定义错误类型

```rust
use axum::{
    extract::rejection::JsonRejection,
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde_json::json;

#[derive(Debug)]
pub enum AppError {
    NotFound(String),
    ValidationError(String),
    DatabaseError(sqlx::Error),
    JsonError(JsonRejection),
    InternalError(String),
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let (status, error_message) = match self {
            AppError::NotFound(msg) => (StatusCode::NOT_FOUND, msg),
            AppError::ValidationError(msg) => (StatusCode::BAD_REQUEST, msg),
            AppError::DatabaseError(_) => (
                StatusCode::INTERNAL_SERVER_ERROR,
                "Database error".to_string(),
            ),
            AppError::JsonError(_) => (
                StatusCode::BAD_REQUEST,
                "Invalid JSON".to_string(),
            ),
            AppError::InternalError(msg) => (StatusCode::INTERNAL_SERVER_ERROR, msg),
        };

        let body = Json(json!({
            "error": error_message,
            "status": status.as_u16()
        }));

        (status, body).into_response()
    }
}

// 使用自定义错误
async fn create_user(
    Json(payload): Json<CreateUserRequest>,
) -> Result<Json<User>, AppError> {
    if payload.name.is_empty() {
        return Err(AppError::ValidationError("Name cannot be empty".to_string()));
    }
    
    let user = User::create(payload)
        .await
        .map_err(|e| AppError::DatabaseError(e))?;
    
    Ok(Json(user))
}
```

### 错误恢复

```rust
use axum::{
    extract::rejection::JsonRejection,
    response::Json,
};

// JSON错误处理
async fn handle_json_error(
    rejection: JsonRejection,
) -> Result<Json<serde_json::Value>, AppError> {
    let error_message = match rejection {
        JsonRejection::JsonDataError(err) => format!("JSON data error: {}", err),
        JsonRejection::JsonSyntaxError(err) => format!("JSON syntax error: {}", err),
        _ => "Invalid JSON".to_string(),
    };
    
    Err(AppError::ValidationError(error_message))
}

// 全局错误处理
fn create_error_handler() -> Router {
    Router::new()
        .route("/", get(handler))
        .layer(
            ServiceBuilder::new()
                .layer(HandleErrorLayer::new(handle_json_error))
        )
}
```

## 异步处理

### 异步处理器

```rust
use axum::{
    extract::State,
    response::Json,
};
use tokio::task;

async fn heavy_computation_handler(
    State(state): State<AppState>,
) -> Result<Json<ComputationResult>, AppError> {
    // 在后台任务中执行重计算
    let result = task::spawn_blocking(move || {
        // CPU密集型计算
        perform_heavy_computation()
    }).await
    .map_err(|_| AppError::InternalError("Task failed".to_string()))?;
    
    Ok(Json(result))
}

async fn concurrent_requests_handler(
    State(state): State<AppState>,
) -> Result<Json<AggregatedData>, AppError> {
    // 并发执行多个异步操作
    let (users, posts, comments) = tokio::join!(
        get_users(&state.database),
        get_posts(&state.database),
        get_comments(&state.database),
    );
    
    let aggregated = AggregatedData {
        users: users?,
        posts: posts?,
        comments: comments?,
    };
    
    Ok(Json(aggregated))
}
```

### 流式响应

```rust
use axum::{
    body::Stream,
    extract::State,
    response::Response,
};
use tokio_stream::{StreamExt, Stream};

async fn stream_data_handler(
    State(state): State<AppState>,
) -> Response {
    let stream = async_stream::stream! {
        for i in 0..1000 {
            let data = fetch_data(i, &state.database).await;
            yield Ok::<_, axum::Error>(data);
            tokio::time::sleep(Duration::from_millis(100)).await;
        }
    };
    
    Response::builder()
        .header("content-type", "application/json")
        .body(Stream::new(stream))
        .unwrap()
}
```

## 性能优化

### 连接池优化

```rust
use sqlx::PgPool;

struct AppState {
    database: PgPool,
}

impl AppState {
    async fn new() -> Result<Self, sqlx::Error> {
        let database = PgPool::builder()
            .max_connections(20)
            .min_connections(5)
            .acquire_timeout(Duration::from_secs(30))
            .idle_timeout(Duration::from_secs(600))
            .build(&database_url)
            .await?;
            
        Ok(Self { database })
    }
}
```

### 缓存策略

```rust
use axum::{
    extract::State,
    response::Json,
};
use redis::AsyncCommands;

async fn get_cached_user(
    State(state): State<AppState>,
    Path(user_id): Path<u64>,
) -> Result<Json<User>, AppError> {
    // 尝试从缓存获取
    let cache_key = format!("user:{}", user_id);
    if let Ok(cached_user) = state.cache.get::<_, String>(&cache_key).await {
        if let Ok(user) = serde_json::from_str::<User>(&cached_user) {
            return Ok(Json(user));
        }
    }
    
    // 从数据库获取
    let user = get_user_from_db(&state.database, user_id).await?;
    
    // 缓存结果
    let user_json = serde_json::to_string(&user)?;
    let _: () = state.cache
        .set_ex(&cache_key, user_json, 3600)
        .await?;
    
    Ok(Json(user))
}
```

### 压缩和静态文件

```rust
use tower_http::{
    compression::CompressionLayer,
    services::ServeDir,
};

fn create_app() -> Router {
    Router::new()
        .route("/api/*", api_routes())
        .nest_service("/static", ServeDir::new("static"))
        .layer(CompressionLayer::new())
}
```

## 实际案例

### 完整的微服务示例

```rust
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::Json,
    routing::{get, post, put, delete},
    Router,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[derive(Clone)]
struct AppState {
    database: Arc<DatabasePool>,
    cache: Arc<RedisClient>,
    metrics: Arc<MetricsCollector>,
}

#[derive(Serialize, Deserialize)]
struct User {
    id: u64,
    name: String,
    email: String,
    created_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Deserialize)]
struct CreateUserRequest {
    name: String,
    email: String,
}

#[derive(Deserialize)]
struct UpdateUserRequest {
    name: Option<String>,
    email: Option<String>,
}

#[derive(Deserialize)]
struct UserQuery {
    page: Option<u32>,
    limit: Option<u32>,
    search: Option<String>,
}

// 创建用户
async fn create_user(
    State(state): State<AppState>,
    Json(request): Json<CreateUserRequest>,
) -> Result<Json<User>, AppError> {
    // 验证输入
    validate_user_data(&request)?;
    
    // 创建用户
    let user = User::create(&state.database, request).await?;
    
    // 记录指标
    state.metrics.increment_user_created();
    
    Ok(Json(user))
}

// 获取用户
async fn get_user(
    State(state): State<AppState>,
    Path(user_id): Path<u64>,
) -> Result<Json<User>, AppError> {
    // 尝试从缓存获取
    if let Some(user) = get_user_from_cache(&state.cache, user_id).await? {
        return Ok(Json(user));
    }
    
    // 从数据库获取
    let user = get_user_from_db(&state.database, user_id).await?;
    
    // 缓存结果
    cache_user(&state.cache, &user).await?;
    
    Ok(Json(user))
}

// 更新用户
async fn update_user(
    State(state): State<AppState>,
    Path(user_id): Path<u64>,
    Json(request): Json<UpdateUserRequest>,
) -> Result<Json<User>, AppError> {
    // 更新用户
    let user = update_user_in_db(&state.database, user_id, request).await?;
    
    // 更新缓存
    cache_user(&state.cache, &user).await?;
    
    Ok(Json(user))
}

// 删除用户
async fn delete_user(
    State(state): State<AppState>,
    Path(user_id): Path<u64>,
) -> Result<StatusCode, AppError> {
    // 从数据库删除
    delete_user_from_db(&state.database, user_id).await?;
    
    // 从缓存删除
    remove_user_from_cache(&state.cache, user_id).await?;
    
    Ok(StatusCode::NO_CONTENT)
}

// 列出用户
async fn list_users(
    State(state): State<AppState>,
    Query(query): Query<UserQuery>,
) -> Result<Json<Vec<User>>, AppError> {
    let page = query.page.unwrap_or(1);
    let limit = query.limit.unwrap_or(10);
    
    let users = get_users_paginated(
        &state.database,
        page,
        limit,
        query.search,
    ).await?;
    
    Ok(Json(users))
}

// 健康检查
async fn health_check(State(state): State<AppState>) -> Json<serde_json::Value> {
    let db_healthy = check_database_health(&state.database).await;
    let cache_healthy = check_cache_health(&state.cache).await;
    
    Json(json!({
        "status": "healthy",
        "database": db_healthy,
        "cache": cache_healthy,
        "timestamp": chrono::Utc::now(),
    }))
}

fn create_user_routes() -> Router<AppState> {
    Router::new()
        .route("/users", post(create_user))
        .route("/users", get(list_users))
        .route("/users/:id", get(get_user))
        .route("/users/:id", put(update_user))
        .route("/users/:id", delete(delete_user))
        .route("/health", get(health_check))
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 初始化应用状态
    let state = AppState::new().await?;
    
    // 构建应用
    let app = Router::new()
        .nest("/api/v1", create_user_routes())
        .with_state(state);
    
    // 启动服务器
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await?;
    println!("User service running on http://0.0.0.0:3000");
    
    axum::serve(listener, app).await?;
    Ok(())
}
```

## 最佳实践

### 1. 状态管理

```rust
// 使用Arc实现状态共享
#[derive(Clone)]
struct AppState {
    database: Arc<DatabasePool>,
    cache: Arc<RedisClient>,
    config: Arc<Config>,
}

// 在处理器中使用状态
async fn handler(State(state): State<AppState>) -> Result<Json<Data>, AppError> {
    let data = fetch_data(&state.database).await?;
    Ok(Json(data))
}
```

### 2. 错误处理

```rust
// 统一的错误类型
#[derive(Debug, thiserror::Error)]
pub enum AppError {
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),
    
    #[error("Cache error: {0}")]
    Cache(#[from] redis::RedisError),
    
    #[error("Validation error: {0}")]
    Validation(String),
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        // 实现错误响应
    }
}
```

### 3. 中间件使用

```rust
// 组合中间件
fn create_app() -> Router {
    Router::new()
        .route("/", get(handler))
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(CompressionLayer::new())
                .layer(CorsLayer::permissive())
                .layer(TimeoutLayer::new(Duration::from_secs(30)))
        )
}
```

### 4. 测试

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use axum::{
        body::Body,
        http::{Request, StatusCode},
    };
    use tower::ServiceExt;

    #[tokio::test]
    async fn test_create_user() {
        let app = create_user_routes();
        
        let request = Request::builder()
            .method("POST")
            .uri("/users")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"name":"John","email":"john@example.com"}"#))
            .unwrap();
            
        let response = app.oneshot(request).await.unwrap();
        assert_eq!(response.status(), StatusCode::CREATED);
    }
}
```

## 总结

Axum是一个功能强大、性能优异的现代Rust Web框架，特别适合构建微服务：

1. **类型安全**: 编译时确保API正确性
2. **异步优先**: 完全异步的编程模型
3. **模块化**: 可组合的中间件和处理器
4. **高性能**: 接近原生的性能表现
5. **易用性**: 简洁的API设计

通过合理使用Axum的特性和最佳实践，可以构建出高性能、可维护的微服务系统。

## 进阶模式（Rust 1.90 对齐）

### 可观测性：Tracing + OpenTelemetry + Metrics

```rust
use axum::{Router, routing::get};
use opentelemetry::{sdk::Resource, KeyValue};
use opentelemetry_otlp::WithExportConfig;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};
use tower_http::trace::TraceLayer;

async fn init_telemetry(service_name: &str) -> anyhow::Result<()> {
    let exporter = opentelemetry_otlp::new_pipeline()
        .tracing()
        .with_exporter(
            opentelemetry_otlp::new_exporter()
                .tonic()
                .with_endpoint("http://otel-collector:4317"),
        )
        .with_trace_config(
            opentelemetry::sdk::trace::Config::default()
                .with_resource(Resource::new(vec![KeyValue::new("service.name", service_name)]))
        )
        .install_batch(opentelemetry::runtime::Tokio)?;

    let telemetry = tracing_opentelemetry::layer().with_tracer(exporter);
    tracing_subscriber::registry()
        .with(tracing_subscriber::fmt::layer())
        .with(telemetry)
        .init();

    Ok(())
}

fn app_with_tracing() -> Router {
    Router::new()
        .route("/health", get(|| async { "OK" }))
        .layer(TraceLayer::new_for_http())
}
```

- 指南：在 handler 入口打点 span；对外暴露 Prometheus 指标（`metrics-exporter-prometheus`），并在 8.x/14.x 蓝图中统一接入。

### 可靠性：超时/重试/熔断/退避

```rust
use std::time::Duration;
use tower::{ServiceBuilder, timeout::TimeoutLayer};
use tower_retry::RetryLayer;
use tower::limit::ConcurrencyLimitLayer;
use tower_cbor::CircuitBreakerLayer; // 伪示例：实际可自实现熔断或使用现成实现

fn reliability_stack() -> ServiceBuilder {
    ServiceBuilder::new()
        .layer(ConcurrencyLimitLayer::new(1024))
        .layer(TimeoutLayer::new(Duration::from_secs(2)))
        .layer(RetryLayer::new(tower_retry::Policy::default()))
        // .layer(CircuitBreakerLayer::new(params)) // 按需接入
}

fn app_with_reliability() -> Router {
    Router::new()
        .route("/api", get(handler))
        .layer(reliability_stack().into_inner())
}
```

- 要点：避免与 Service Mesh 的重试/超时叠加冲突（见 14.5）。

### 限流与背压

```rust
use tower_governor::{GovernorLayer, governor::GovernorConfigBuilder};

fn rate_limit_layer() -> GovernorLayer {
    let config = GovernorConfigBuilder::default()
        .per_second(200)
        .burst_size(400)
        .finish().unwrap();
    GovernorLayer::new(config)
}

fn app_with_ratelimit() -> Router {
    Router::new()
        .route("/api", get(handler))
        .layer(rate_limit_layer())
}
```

- 辅以队列长度与丢弃策略；结合 P95/P99 指标调整。

### 优雅关闭与健康检查（liveness/readiness）

```rust
use axum::{Router, routing::get};
use tokio::{signal, net::TcpListener};

async fn shutdown_signal() {
    let ctrl_c = async {
        signal::ctrl_c().await.expect("failed to install Ctrl+C handler");
    };
    #[cfg(unix)]
    let terminate = async {
        use tokio::signal::unix::{signal, SignalKind};
        signal(SignalKind::terminate()).unwrap().recv().await;
    };
    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! { _ = ctrl_c => {}, _ = terminate => {}, }
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    init_telemetry("user-service").await?;
    let app = Router::new()
        .route("/health", get(|| async { "OK" }))
        .route("/ready", get(|| async { "READY" }));

    let listener = TcpListener::bind("0.0.0.0:3000").await?;
    axum::serve(listener, app)
        .with_graceful_shutdown(shutdown_signal())
        .await?;
    Ok(())
}
```

### 安全：JWT/OIDC（简化）

```rust
use axum::{extract::State, http::StatusCode, middleware::Next, response::Response, Request};
use jsonwebtoken::{decode, DecodingKey, Validation};

#[derive(Clone)]
struct AuthState { jwk: DecodingKey, validation: Validation }

pub async fn jwt_middleware(mut req: Request, next: Next, State(state): State<AuthState>) -> Result<Response, StatusCode> {
    let token = req.headers()
        .get("authorization")
        .and_then(|h| h.to_str().ok())
        .and_then(|v| v.strip_prefix("Bearer "))
        .ok_or(StatusCode::UNAUTHORIZED)?;

    decode::<serde_json::Value>(token, &state.jwk, &state.validation)
        .map_err(|_| StatusCode::UNAUTHORIZED)?;

    Ok(next.run(req).await)
}
```

- OIDC 场景对接 IdP 的 JWKS，定期轮换；内网通道开启 mTLS（见 14.2/14.5）。

### 配置与特性开关（feature flags）

```toml
# Cargo.toml
[features]
http = []
grpc = []
consumer = []

[dependencies]
axum = { version = "0.7", optional = true }
tonic = { version = "0.12", optional = true }
```

```rust
#[cfg(feature = "http")]
fn start_http() { /* ... */ }

#[cfg(feature = "grpc")]
fn start_grpc() { /* ... */ }
```

- 在 CI 与部署中按环境启用不同特性，实现可裁剪二进制。

### 与第14章蓝图的对齐

- 互联网 API（14.1）：搭配 SQLx/Redis/Kafka、Traefik、OTel、K8s。
- 内部 RPC（14.2）：共享领域服务 trait，HTTP 与 gRPC 复用实现。
- 事件驱动（14.3）：使用异步流与背压策略，消费 Kafka/NATS。
- 边缘高吞吐（14.4）：零拷贝 Bytes、连接调优、批处理。
- Mesh 零信任（14.5）：与 sidecar 策略解耦，避免重试/超时冲突。
- 多租户多区域（14.6）：按租户标签输出指标、限流与配额。
