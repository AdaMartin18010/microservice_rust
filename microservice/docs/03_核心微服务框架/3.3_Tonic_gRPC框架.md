# 3.3 Tonic gRPC 框架

Tonic 基于 `hyper` 和 `tower`，提供高性能 gRPC 能力，适合强协议约束、跨语言互通与流式场景。

## 3.3.1 关键特性

- HTTP/2、双向流、拦截器、中间件（`tower` 生态）。
- 与 `prost` 生成高性能 Rust 结构；与 `tracing`/OpenTelemetry 无缝对接。

## 3.3.2 最小可用示例

```rust
// 伪代码示意：
#[derive(Default)]
pub struct UserGrpc;

#[tonic::async_trait]
impl user::user_service_server::UserService for UserGrpc {
    async fn get_user(
        &self,
        req: Request<GetUserRequest>,
    ) -> Result<Response<GetUserResponse>, Status> {
        // ... 查询与转换
        Ok(Response::new(GetUserResponse { ..Default::default() }))
    }
}
```

## 3.3.3 与领域服务解耦

- 将领域逻辑封装在 `AsyncService`（本仓示例）等接口中；
- gRPC 层仅负责协议编解码与校验，内部调度依赖注入的领域服务；
- 通过 `tower` 中间件统一限流、熔断、重试与超时。

## 3.3.4 互操作与演进

- 版本演进采用 `oneof`/新增字段的向后兼容策略；
- 与 `grpc-gateway` 或边缘网关组合提供 REST 兼容入口；
- 强约束 API 结合 Schema Registry 与契约测试。

## 3.3.5 构建与代码生成（build.rs + proto 规范）

```rust
// build.rs
fn main() {
    println!("cargo:rerun-if-changed=proto/");
    tonic_build::configure()
        .build_server(true)
        .build_client(true)
        .out_dir("src/gen")
        .compile(&["proto/user_service.proto"], &["proto"]) // 与仓库 proto 对齐
        .expect("compile protos");
}
```

- 约定：`proto/` 按领域分包；字段演进仅新增/保守变更，删除使用废弃标记。

## 3.3.6 可观测性与拦截器

```rust
use tonic::{Request, Status, Code};
use tonic::metadata::MetadataMap;
use tracing::{info_span, Instrument};

pub fn otel_inbound() -> impl tower::Layer<Svc> { // 伪签名：按需包装
    tower::layer::util::Identity::new() // 实际请接入 tracing/otel layer
}

pub fn auth_interceptor(token_header: &'static str) -> impl tonic::service::Interceptor {
    move |mut req: Request<()>| {
        let meta: &MetadataMap = req.metadata();
        let _ = meta.get(token_header).ok_or(Status::unauthenticated("missing token"))?;
        Ok(req)
    }
}

// server
Server::builder()
    .layer(tower_http::trace::TraceLayer::new_for_http())
    .add_service(
        user_service::UserServiceServer::with_interceptor(UserGrpc::default(), auth_interceptor("authorization"))
    );
```

- 指南：服务端/客户端均接入 tracing 和 OTel；统一注入 `x-request-id` 并在 span 上挂载。

## 3.3.7 可靠性：超时、重试、熔断、负载均衡

```rust
use tower::{ServiceBuilder, timeout::TimeoutLayer};
use std::time::Duration;
use tonic::transport::{Channel, ClientTlsConfig};

async fn grpc_channel(endpoint: &str) -> anyhow::Result<Channel> {
    let channel = Channel::from_shared(endpoint.to_string())?
        .connect_timeout(Duration::from_secs(2))
        .tcp_keepalive(Some(Duration::from_secs(60)))
        .http2_keep_alive_interval(Duration::from_secs(30))
        .keep_alive_while_idle(true)
        .connect()
        .await?;
    Ok(channel)
}

fn client_stack() -> ServiceBuilder {
    ServiceBuilder::new()
        .layer(TimeoutLayer::new(Duration::from_secs(2)))
        // .layer(RetryLayer::new(policy))
        // .layer(CircuitBreakerLayer::new(params))
}
```

- 负载均衡：使用 `tonic::transport::Endpoint::connect_lazy` 与自实现 resolver（etcd/Consul），或结合 Traefik/Envoy 统一负载。

## 3.3.8 TLS/mTLS 与 SPIFFE

```rust
use tonic::transport::{Channel, ClientTlsConfig, Certificate, Identity};

fn tls(client_cert_pem: &str, client_key_pem: &str, ca_pem: &str) -> ClientTlsConfig {
    let identity = Identity::from_pem(client_cert_pem.as_bytes(), client_key_pem.as_bytes());
    let ca = Certificate::from_pem(ca_pem.as_bytes());
    ClientTlsConfig::new().ca_certificate(ca).identity(identity)
}
```

- 在 Mesh 场景下透传 sidecar mTLS；直连时启用 mTLS 与证书轮换（见 14.5）。

## 3.3.9 流式与背压

```rust
use futures::Stream;
use tokio_stream::wrappers::ReceiverStream;

type OutStream = Pin<Box<dyn Stream<Item = Result<Reply, Status>> + Send>>;

async fn server_streaming() -> Result<Response<OutStream>, Status> {
    let (tx, rx) = tokio::sync::mpsc::channel(128);
    tokio::spawn(async move {
        for i in 0..1000 {
            if tx.send(Ok(Reply { value: i })).await.is_err() { break; }
        }
    });
    Ok(Response::new(Box::pin(ReceiverStream::new(rx))))
}
```

- 建议：合理的 channel 大小、速率限制与超时，避免生产者-消费者失衡。

## 3.3.10 错误映射与版本演进

```rust
// 领域错误到 gRPC Status 映射
impl From<DomainError> for tonic::Status {
    fn from(e: DomainError) -> Self {
        match e {
            DomainError::NotFound(id) => Status::new(Code::NotFound, format!("not found: {id}")),
            DomainError::Validation(m) => Status::new(Code::InvalidArgument, m),
            DomainError::Unauthenticated => Status::unauthenticated("unauthenticated"),
            DomainError::Internal => Status::internal("internal"),
        }
    }
}
```

- 版本演进：新增字段与 `oneof`；弃用通过注释与 lint 管控；契约测试保障兼容。

## 3.3.11 与第14章蓝图的对应

- 14.2 企业内部 RPC：作为主力 RPC；与 etcd/Traefik/OTel 协同。
- 14.1/14.4：边缘入口统一到 HTTP，核心内部走 gRPC；复用领域接口。
