# 3.3 Tonic gRPC æ¡†æ¶

## ğŸ“‹ ç›®å½•

- [3.3 Tonic gRPC æ¡†æ¶](#33-tonic-grpc-æ¡†æ¶)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [3.3.1 å…³é”®ç‰¹æ€§](#331-å…³é”®ç‰¹æ€§)
  - [3.3.2 æœ€å°å¯ç”¨ç¤ºä¾‹](#332-æœ€å°å¯ç”¨ç¤ºä¾‹)
  - [3.3.3 ä¸é¢†åŸŸæœåŠ¡è§£è€¦](#333-ä¸é¢†åŸŸæœåŠ¡è§£è€¦)
  - [3.3.4 äº’æ“ä½œä¸æ¼”è¿›](#334-äº’æ“ä½œä¸æ¼”è¿›)
  - [3.3.5 æ„å»ºä¸ä»£ç ç”Ÿæˆï¼ˆbuild.rs + proto è§„èŒƒï¼‰](#335-æ„å»ºä¸ä»£ç ç”Ÿæˆbuildrs--proto-è§„èŒƒ)
  - [3.3.6 å¯è§‚æµ‹æ€§ä¸æ‹¦æˆªå™¨](#336-å¯è§‚æµ‹æ€§ä¸æ‹¦æˆªå™¨)
  - [3.3.7 å¯é æ€§ï¼šè¶…æ—¶ã€é‡è¯•ã€ç†”æ–­ã€è´Ÿè½½å‡è¡¡](#337-å¯é æ€§è¶…æ—¶é‡è¯•ç†”æ–­è´Ÿè½½å‡è¡¡)
  - [3.3.8 TLS/mTLS ä¸ SPIFFE](#338-tlsmtls-ä¸-spiffe)
  - [3.3.9 æµå¼ä¸èƒŒå‹](#339-æµå¼ä¸èƒŒå‹)
  - [3.3.10 é”™è¯¯æ˜ å°„ä¸ç‰ˆæœ¬æ¼”è¿›](#3310-é”™è¯¯æ˜ å°„ä¸ç‰ˆæœ¬æ¼”è¿›)
  - [3.3.11 ä¸ç¬¬14ç« è“å›¾çš„å¯¹åº”](#3311-ä¸ç¬¬14ç« è“å›¾çš„å¯¹åº”)

Tonic åŸºäº `hyper` å’Œ `tower`ï¼Œæä¾›é«˜æ€§èƒ½ gRPC èƒ½åŠ›ï¼Œé€‚åˆå¼ºåè®®çº¦æŸã€è·¨è¯­è¨€äº’é€šä¸æµå¼åœºæ™¯ã€‚

## 3.3.1 å…³é”®ç‰¹æ€§

- HTTP/2ã€åŒå‘æµã€æ‹¦æˆªå™¨ã€ä¸­é—´ä»¶ï¼ˆ`tower` ç”Ÿæ€ï¼‰ã€‚
- ä¸ `prost` ç”Ÿæˆé«˜æ€§èƒ½ Rust ç»“æ„ï¼›ä¸ `tracing`/OpenTelemetry æ— ç¼å¯¹æ¥ã€‚

## 3.3.2 æœ€å°å¯ç”¨ç¤ºä¾‹

```rust
// ä¼ªä»£ç ç¤ºæ„ï¼š
#[derive(Default)]
pub struct UserGrpc;

#[tonic::async_trait]
impl user::user_service_server::UserService for UserGrpc {
    async fn get_user(
        &self,
        req: Request<GetUserRequest>,
    ) -> Result<Response<GetUserResponse>, Status> {
        // ... æŸ¥è¯¢ä¸è½¬æ¢
        Ok(Response::new(GetUserResponse { ..Default::default() }))
    }
}
```

> Rust 1.90 æç¤ºï¼šç»“åˆ TAIT ç®€åŒ–è¿”å› Future ç±»å‹ï¼Œéšè—ä¸­é—´ä»¶ç»„åˆç»†èŠ‚ï¼ˆè§ 17.3ï¼‰ã€‚

## 3.3.3 ä¸é¢†åŸŸæœåŠ¡è§£è€¦

- å°†é¢†åŸŸé€»è¾‘å°è£…åœ¨ `AsyncService`ï¼ˆæœ¬ä»“ç¤ºä¾‹ï¼‰ç­‰æ¥å£ä¸­ï¼›
- gRPC å±‚ä»…è´Ÿè´£åè®®ç¼–è§£ç ä¸æ ¡éªŒï¼Œå†…éƒ¨è°ƒåº¦ä¾èµ–æ³¨å…¥çš„é¢†åŸŸæœåŠ¡ï¼›
- é€šè¿‡ `tower` ä¸­é—´ä»¶ç»Ÿä¸€é™æµã€ç†”æ–­ã€é‡è¯•ä¸è¶…æ—¶ã€‚

## 3.3.4 äº’æ“ä½œä¸æ¼”è¿›

- ç‰ˆæœ¬æ¼”è¿›é‡‡ç”¨ `oneof`/æ–°å¢å­—æ®µçš„å‘åå…¼å®¹ç­–ç•¥ï¼›
- ä¸ `grpc-gateway` æˆ–è¾¹ç¼˜ç½‘å…³ç»„åˆæä¾› REST å…¼å®¹å…¥å£ï¼›
- å¼ºçº¦æŸ API ç»“åˆ Schema Registry ä¸å¥‘çº¦æµ‹è¯•ã€‚

## 3.3.5 æ„å»ºä¸ä»£ç ç”Ÿæˆï¼ˆbuild.rs + proto è§„èŒƒï¼‰

```rust
// build.rs
fn main() {
    println!("cargo:rerun-if-changed=proto/");
    tonic_build::configure()
        .build_server(true)
        .build_client(true)
        .out_dir("src/gen")
        .compile(&["proto/user_service.proto"], &["proto"]) // ä¸ä»“åº“ proto å¯¹é½
        .expect("compile protos");
}
```

- çº¦å®šï¼š`proto/` æŒ‰é¢†åŸŸåˆ†åŒ…ï¼›å­—æ®µæ¼”è¿›ä»…æ–°å¢/ä¿å®ˆå˜æ›´ï¼Œåˆ é™¤ä½¿ç”¨åºŸå¼ƒæ ‡è®°ã€‚

## 3.3.6 å¯è§‚æµ‹æ€§ä¸æ‹¦æˆªå™¨

```rust
use tonic::{Request, Status, Code};
use tonic::metadata::MetadataMap;
use tracing::{info_span, Instrument};

pub fn otel_inbound() -> impl tower::Layer<Svc> { // ä¼ªç­¾åï¼šæŒ‰éœ€åŒ…è£…
    tower::layer::util::Identity::new() // å®é™…è¯·æ¥å…¥ tracing/otel layer
}

pub fn auth_interceptor(token_header: &'static str) -> impl tonic::service::Interceptor {
    move |mut req: Request<()>| {
        let meta: &MetadataMap = req.metadata();
        let _ = meta.get(token_header).ok_or(Status::unauthenticated("missing token"))?;
        Ok(req)
    }
}

// serverï¼šå åŠ  tower å±‚ä¸æ‹¦æˆªå™¨
Server::builder()
    .layer(tower_http::trace::TraceLayer::new_for_http())
    .add_service(
        user_service::UserServiceServer::with_interceptor(UserGrpc::default(), auth_interceptor("authorization"))
    );
```

- æŒ‡å—ï¼šæœåŠ¡ç«¯/å®¢æˆ·ç«¯å‡æ¥å…¥ tracing å’Œ OTelï¼›ç»Ÿä¸€æ³¨å…¥ `x-request-id` å¹¶åœ¨ span ä¸ŠæŒ‚è½½ã€‚

## 3.3.7 å¯é æ€§ï¼šè¶…æ—¶ã€é‡è¯•ã€ç†”æ–­ã€è´Ÿè½½å‡è¡¡

```rust
use tower::{ServiceBuilder, timeout::TimeoutLayer};
use std::time::Duration;
use tonic::transport::{Channel, ClientTlsConfig};

async fn grpc_channel(endpoint: &str) -> anyhow::Result<Channel> {
    let channel = Channel::from_shared(endpoint.to_string())?
        .connect_timeout(Duration::from_secs(2))
        .tcp_keepalive(Some(Duration::from_secs(60)))
        .http2_keep_alive_interval(Duration::from_secs(30))
        .keep_alive_while_idle(true)
        .connect()
        .await?;
    Ok(channel)
}

fn client_stack() -> ServiceBuilder {
    ServiceBuilder::new()
        .layer(TimeoutLayer::new(Duration::from_secs(2)))
        // .layer(RetryLayer::new(policy))
        // .layer(CircuitBreakerLayer::new(params))
}
```

- è´Ÿè½½å‡è¡¡ï¼šä½¿ç”¨ `tonic::transport::Endpoint::connect_lazy` ä¸è‡ªå®ç° resolverï¼ˆetcd/Consulï¼‰ï¼Œæˆ–ç»“åˆ Traefik/Envoy ç»Ÿä¸€è´Ÿè½½ã€‚
- Rust 1.90ï¼šç”¨å¼‚æ­¥ trait æŠ½è±¡ Resolver æ¥å£ï¼›ç”¨ TAIT éšè— client stack è¿”å›ç±»å‹ä»¥ä¿æŒ API ç®€æ´ã€‚

## 3.3.8 TLS/mTLS ä¸ SPIFFE

```rust
use tonic::transport::{Channel, ClientTlsConfig, Certificate, Identity};

fn tls(client_cert_pem: &str, client_key_pem: &str, ca_pem: &str) -> ClientTlsConfig {
    let identity = Identity::from_pem(client_cert_pem.as_bytes(), client_key_pem.as_bytes());
    let ca = Certificate::from_pem(ca_pem.as_bytes());
    ClientTlsConfig::new().ca_certificate(ca).identity(identity)
}
```

- åœ¨ Mesh åœºæ™¯ä¸‹é€ä¼  sidecar mTLSï¼›ç›´è¿æ—¶å¯ç”¨ mTLS ä¸è¯ä¹¦è½®æ¢ï¼ˆè§ 14.5ï¼‰ã€‚

## 3.3.9 æµå¼ä¸èƒŒå‹

```rust
use futures::Stream;
use tokio_stream::wrappers::ReceiverStream;

type OutStream = Pin<Box<dyn Stream<Item = Result<Reply, Status>> + Send>>;

async fn server_streaming() -> Result<Response<OutStream>, Status> {
    let (tx, rx) = tokio::sync::mpsc::channel(128);
    tokio::spawn(async move {
        for i in 0..1000 {
            if tx.send(Ok(Reply { value: i })).await.is_err() { break; }
        }
    });
    Ok(Response::new(Box::pin(ReceiverStream::new(rx))))
}
```

- å»ºè®®ï¼šåˆç†çš„ channel å¤§å°ã€é€Ÿç‡é™åˆ¶ä¸è¶…æ—¶ï¼Œé¿å…ç”Ÿäº§è€…-æ¶ˆè´¹è€…å¤±è¡¡ã€‚
- Rust 1.90ï¼šä¹Ÿå¯ç”¨ `type OutStream = impl Stream<Item = Result<Reply, Status>> + Send;`ï¼ˆTAITï¼‰åœ¨æ¨¡å—è¾¹ç•Œéšè—å…·ä½“ç±»å‹ã€‚

## 3.3.10 é”™è¯¯æ˜ å°„ä¸ç‰ˆæœ¬æ¼”è¿›

```rust
// é¢†åŸŸé”™è¯¯åˆ° gRPC Status æ˜ å°„
impl From<DomainError> for tonic::Status {
    fn from(e: DomainError) -> Self {
        match e {
            DomainError::NotFound(id) => Status::new(Code::NotFound, format!("not found: {id}")),
            DomainError::Validation(m) => Status::new(Code::InvalidArgument, m),
            DomainError::Unauthenticated => Status::unauthenticated("unauthenticated"),
            DomainError::Internal => Status::internal("internal"),
        }
    }
}
```

- ç‰ˆæœ¬æ¼”è¿›ï¼šæ–°å¢å­—æ®µä¸ `oneof`ï¼›å¼ƒç”¨é€šè¿‡æ³¨é‡Šä¸ lint ç®¡æ§ï¼›å¥‘çº¦æµ‹è¯•ä¿éšœå…¼å®¹ã€‚

## 3.3.11 ä¸ç¬¬14ç« è“å›¾çš„å¯¹åº”

- 14.2 ä¼ä¸šå†…éƒ¨ RPCï¼šä½œä¸ºä¸»åŠ› RPCï¼›ä¸ etcd/Traefik/OTel ååŒã€‚
- 14.1/14.4ï¼šè¾¹ç¼˜å…¥å£ç»Ÿä¸€åˆ° HTTPï¼Œæ ¸å¿ƒå†…éƒ¨èµ° gRPCï¼›å¤ç”¨é¢†åŸŸæ¥å£ã€‚
