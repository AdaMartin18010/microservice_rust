# 3.2 Actix-Web é«˜æ€§èƒ½æ¡†æ¶

## ğŸ“‹ ç›®å½•

- [3.2 Actix-Web é«˜æ€§èƒ½æ¡†æ¶](#32-actix-web-é«˜æ€§èƒ½æ¡†æ¶)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [3.2.1 å…³é”®ç‰¹æ€§](#321-å…³é”®ç‰¹æ€§)
  - [3.2.2 æœ€å°å¯ç”¨ç¤ºä¾‹](#322-æœ€å°å¯ç”¨ç¤ºä¾‹)
  - [3.2.3 ä¸­é—´ä»¶ä¸å¯è§‚æµ‹æ€§](#323-ä¸­é—´ä»¶ä¸å¯è§‚æµ‹æ€§)
  - [3.2.4 ä¸ axum/tonic çš„ç»„åˆ](#324-ä¸-axumtonic-çš„ç»„åˆ)
  - [3.2.5 é›¶æ‹·è´ä¸å¤§æ–‡ä»¶ä¼ è¾“](#325-é›¶æ‹·è´ä¸å¤§æ–‡ä»¶ä¼ è¾“)
  - [3.2.6 ç½‘ç»œä¸çº¿ç¨‹æ± è°ƒä¼˜](#326-ç½‘ç»œä¸çº¿ç¨‹æ± è°ƒä¼˜)
  - [3.2.7 é™æµä¸èƒŒå‹](#327-é™æµä¸èƒŒå‹)
  - [3.2.8 å¯è§‚æµ‹æ€§ï¼šTracing + OpenTelemetry](#328-å¯è§‚æµ‹æ€§tracing--opentelemetry)
  - [3.2.9 ä¼˜é›…å…³é—­ä¸å¥åº·æ£€æŸ¥](#329-ä¼˜é›…å…³é—­ä¸å¥åº·æ£€æŸ¥)
  - [3.2.10 TLS/mTLSï¼ˆç‰‡æ®µï¼‰](#3210-tlsmtlsç‰‡æ®µ)
  - [3.2.11 ä¸ 14.4 è“å›¾å¯¹é½](#3211-ä¸-144-è“å›¾å¯¹é½)

Actix-Web ä»¥æè‡´æ€§èƒ½ä¸æˆç†Ÿä¸­é—´ä»¶ç”Ÿæ€é€‚åˆé«˜ååå¾®æœåŠ¡ä¸è¾¹ç¼˜ç½‘å…³åœºæ™¯ã€‚æœ¬ç« ç»™å‡ºä¸æœ¬ä»“ç¤ºä¾‹çš„äº’è¡¥ç”¨æ³•ï¼Œèšç„¦å·¥ç¨‹åŒ–ä¸å¯è§‚æµ‹æ€§ã€‚

## 3.2.1 å…³é”®ç‰¹æ€§

- é«˜æ€§èƒ½ async IOï¼Œè‰¯å¥½çš„è·¯ç”±ä¸æå–å™¨ï¼ˆextractorï¼‰ã€‚
- å¼ºç±»å‹è¯·æ±‚/å“åº”ä¸ä¸­é—´ä»¶ç”Ÿæ€ï¼ˆCORSã€é™æµã€å‹ç¼©ã€æ—¥å¿—ï¼‰ã€‚
- ä¸ `actix-web-opentelemetry`ã€`tracing` æ·±åº¦é›†æˆã€‚

## 3.2.2 æœ€å°å¯ç”¨ç¤ºä¾‹

```rust
use actix_web::{get, App, HttpServer, Responder};

#[get("/health")]
async fn health() -> impl Responder { "OK" }

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    HttpServer::new(|| App::new().service(health))
        .bind(("0.0.0.0", 8080))?
        .workers(num_cpus::get())
        .run()
        .await
}
```

## 3.2.3 ä¸­é—´ä»¶ä¸å¯è§‚æµ‹æ€§

- ä½¿ç”¨ `tracing-actix-web` ç»Ÿä¸€ç»“æ„åŒ–æ—¥å¿—ï¼›
- æŒ‡æ ‡ï¼šé€šè¿‡ Prometheus exporter æš´éœ² HTTP æŒ‡æ ‡ï¼›
- è¿½è¸ªï¼šW3C TraceContext/Jaeger äº’é€šï¼›
- å®‰å…¨ï¼šCORSã€é™æµä¸é€Ÿç‡é™åˆ¶ï¼Œç»“åˆç†”æ–­/é‡è¯•ç­–ç•¥åœ¨å®¢æˆ·ç«¯å®ç°ã€‚

## 3.2.4 ä¸ axum/tonic çš„ç»„åˆ

- ä»¥ Actix-Web ä½œä¸ºé«˜æ€§èƒ½è¾¹ç¼˜å…¥å£ï¼›
- å†…éƒ¨æœåŠ¡ä½¿ç”¨ axum/tonicï¼Œå€ŸåŠ©æœåŠ¡ç½‘æ ¼æˆ–ç½‘å…³è·¯ç”±è½¬å‘ï¼›
- å…¬å…±åº“å±‚æŠ½è±¡é¢†åŸŸæ¨¡å‹ä¸ç­–ç•¥ï¼Œå‡å°‘æ¡†æ¶è€¦åˆã€‚

## 3.2.5 é›¶æ‹·è´ä¸å¤§æ–‡ä»¶ä¼ è¾“

```rust
use actix_web::{HttpResponse, web};
use bytes::Bytes;

async fn stream_bytes() -> HttpResponse {
    let data = Bytes::from_static(b"hello world");
    HttpResponse::Ok()
        .append_header(("content-type", "application/octet-stream"))
        .body(data) // Bytes å®ç°é›¶æ‹·è´è·¯å¾„
}
```

- é™æ€æ–‡ä»¶/å¤§å¯¹è±¡ï¼šç»“åˆ `actix-files` ä¸ `sendfile`ï¼›å°½é‡ä½¿ç”¨ `Bytes` ç®¡é“ã€‚

## 3.2.6 ç½‘ç»œä¸çº¿ç¨‹æ± è°ƒä¼˜

```rust
#[actix_web::main]
async fn main() -> std::io::Result<()> {
    HttpServer::new(move || App::new())
        .backlog(2048)
        .workers(num_cpus::get())
        .max_connections(100_000)
        .client_request_timeout(std::time::Duration::from_secs(2))
        .client_disconnect_timeout(std::time::Duration::from_secs(1))
        .keep_alive(std::time::Duration::from_secs(60))
        .bind(("0.0.0.0", 8080))?
        .run()
        .await
}
```

- ç»“åˆç³»ç»Ÿå‚æ•°ï¼ˆ`somaxconn`ã€`rmem`/`wmem`ï¼‰ä¸å®¹å™¨ CPU äº²å’Œæ€§ã€‚

## 3.2.7 é™æµä¸èƒŒå‹

```rust
use actix_governor::{Governor, GovernorConfigBuilder};

let governor_conf = GovernorConfigBuilder::default()
    .per_millisecond(200)
    .burst_size(400)
    .finish().unwrap();

HttpServer::new(move || App::new().wrap(Governor::new(&governor_conf)))
    .bind(("0.0.0.0", 8080))?
    .run()
    .await?;
```

- ç»“åˆä¿¡å·é‡/é˜Ÿåˆ—ä¸Šé™ï¼Œæ‹’ç»ç­–ç•¥ä¼˜å…ˆè¿”å›å¿«å¤±è´¥ï¼Œä¿æŠ¤ä¸‹æ¸¸ã€‚

## 3.2.8 å¯è§‚æµ‹æ€§ï¼šTracing + OpenTelemetry

```rust
use actix_web::{middleware::Logger, App, HttpServer};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    tracing_subscriber::registry().with(tracing_subscriber::fmt::layer()).init();
    HttpServer::new(|| App::new().wrap(Logger::default()))
        .bind(("0.0.0.0", 8080))?
        .run()
        .await
}
```

- æ¥å…¥ `actix-web-opentelemetry` å¯¼å‡º traces/metrics/logsï¼Œä¸ 8.x ç« èŠ‚ç»Ÿä¸€ã€‚

## 3.2.9 ä¼˜é›…å…³é—­ä¸å¥åº·æ£€æŸ¥

```rust
use actix_web::{get, App, HttpServer, Responder};
use tokio::signal;

#[get("/health")] async fn health() -> impl Responder { "OK" }
#[get("/ready")] async fn ready() -> impl Responder { "READY" }

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    let srv = HttpServer::new(|| App::new().service(health).service(ready))
        .bind(("0.0.0.0", 8080))?
        .run();

    let handle = srv.handle();
    tokio::spawn(async move {
        signal::ctrl_c().await.ok();
        handle.stop(true).await; // ä¼˜é›…å…³é—­
    });

    srv.await
}
```

## 3.2.10 TLS/mTLSï¼ˆç‰‡æ®µï¼‰

```rust
use actix_web::{App, HttpServer};
use rustls::{Certificate, PrivateKey, ServerConfig};

fn tls_config(cert_pem: &str, key_pem: &str) -> ServerConfig { /* æ„é€  rustls é…ç½® */ }

HttpServer::new(|| App::new())
    .bind_rustls("0.0.0.0:8443", tls_config(CERT, KEY))?
    .run()
    .await?;
```

- åœ¨ Mesh åœºæ™¯å¤ç”¨ sidecar mTLSï¼Œåº”ç”¨å±‚é¿å…é‡å¤åŠ å¯†ã€‚

## 3.2.11 ä¸ 14.4 è“å›¾å¯¹é½

- è¾¹ç¼˜é«˜ååå…¥å£ï¼šé…åˆ NATS/Kafkaã€é›¶æ‹·è´ã€æ‰¹å¤„ç†ã€ç½‘ç»œè°ƒä¼˜ã€‚
- æŒ‡æ ‡ï¼šQPS/é”™è¯¯ç‡/å»¶è¿Ÿ P95/P99ï¼›å¼‚å¸¸è¿½è¸ªä¸æµé‡ç°åº¦è”åŠ¨ã€‚
