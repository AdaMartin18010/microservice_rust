# 3.2 Actix-Web 高性能框架

## 📋 目录

- [3.2 Actix-Web 高性能框架](#32-actix-web-高性能框架)
  - [📋 目录](#-目录)
  - [3.2.1 关键特性](#321-关键特性)
  - [3.2.2 最小可用示例](#322-最小可用示例)
  - [3.2.3 中间件与可观测性](#323-中间件与可观测性)
  - [3.2.4 与 axum/tonic 的组合](#324-与-axumtonic-的组合)
  - [3.2.5 零拷贝与大文件传输](#325-零拷贝与大文件传输)
  - [3.2.6 网络与线程池调优](#326-网络与线程池调优)
  - [3.2.7 限流与背压](#327-限流与背压)
  - [3.2.8 可观测性：Tracing + OpenTelemetry](#328-可观测性tracing--opentelemetry)
  - [3.2.9 优雅关闭与健康检查](#329-优雅关闭与健康检查)
  - [3.2.10 TLS/mTLS（片段）](#3210-tlsmtls片段)
  - [3.2.11 与 14.4 蓝图对齐](#3211-与-144-蓝图对齐)

Actix-Web 以极致性能与成熟中间件生态适合高吞吐微服务与边缘网关场景。本章给出与本仓示例的互补用法，聚焦工程化与可观测性。

## 3.2.1 关键特性

- 高性能 async IO，良好的路由与提取器（extractor）。
- 强类型请求/响应与中间件生态（CORS、限流、压缩、日志）。
- 与 `actix-web-opentelemetry`、`tracing` 深度集成。

## 3.2.2 最小可用示例

```rust
use actix_web::{get, App, HttpServer, Responder};

#[get("/health")]
async fn health() -> impl Responder { "OK" }

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    HttpServer::new(|| App::new().service(health))
        .bind(("0.0.0.0", 8080))?
        .workers(num_cpus::get())
        .run()
        .await
}
```

## 3.2.3 中间件与可观测性

- 使用 `tracing-actix-web` 统一结构化日志；
- 指标：通过 Prometheus exporter 暴露 HTTP 指标；
- 追踪：W3C TraceContext/Jaeger 互通；
- 安全：CORS、限流与速率限制，结合熔断/重试策略在客户端实现。

## 3.2.4 与 axum/tonic 的组合

- 以 Actix-Web 作为高性能边缘入口；
- 内部服务使用 axum/tonic，借助服务网格或网关路由转发；
- 公共库层抽象领域模型与策略，减少框架耦合。

## 3.2.5 零拷贝与大文件传输

```rust
use actix_web::{HttpResponse, web};
use bytes::Bytes;

async fn stream_bytes() -> HttpResponse {
    let data = Bytes::from_static(b"hello world");
    HttpResponse::Ok()
        .append_header(("content-type", "application/octet-stream"))
        .body(data) // Bytes 实现零拷贝路径
}
```

- 静态文件/大对象：结合 `actix-files` 与 `sendfile`；尽量使用 `Bytes` 管道。

## 3.2.6 网络与线程池调优

```rust
#[actix_web::main]
async fn main() -> std::io::Result<()> {
    HttpServer::new(move || App::new())
        .backlog(2048)
        .workers(num_cpus::get())
        .max_connections(100_000)
        .client_request_timeout(std::time::Duration::from_secs(2))
        .client_disconnect_timeout(std::time::Duration::from_secs(1))
        .keep_alive(std::time::Duration::from_secs(60))
        .bind(("0.0.0.0", 8080))?
        .run()
        .await
}
```

- 结合系统参数（`somaxconn`、`rmem`/`wmem`）与容器 CPU 亲和性。

## 3.2.7 限流与背压

```rust
use actix_governor::{Governor, GovernorConfigBuilder};

let governor_conf = GovernorConfigBuilder::default()
    .per_millisecond(200)
    .burst_size(400)
    .finish().unwrap();

HttpServer::new(move || App::new().wrap(Governor::new(&governor_conf)))
    .bind(("0.0.0.0", 8080))?
    .run()
    .await?;
```

- 结合信号量/队列上限，拒绝策略优先返回快失败，保护下游。

## 3.2.8 可观测性：Tracing + OpenTelemetry

```rust
use actix_web::{middleware::Logger, App, HttpServer};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    tracing_subscriber::registry().with(tracing_subscriber::fmt::layer()).init();
    HttpServer::new(|| App::new().wrap(Logger::default()))
        .bind(("0.0.0.0", 8080))?
        .run()
        .await
}
```

- 接入 `actix-web-opentelemetry` 导出 traces/metrics/logs，与 8.x 章节统一。

## 3.2.9 优雅关闭与健康检查

```rust
use actix_web::{get, App, HttpServer, Responder};
use tokio::signal;

#[get("/health")] async fn health() -> impl Responder { "OK" }
#[get("/ready")] async fn ready() -> impl Responder { "READY" }

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    let srv = HttpServer::new(|| App::new().service(health).service(ready))
        .bind(("0.0.0.0", 8080))?
        .run();

    let handle = srv.handle();
    tokio::spawn(async move {
        signal::ctrl_c().await.ok();
        handle.stop(true).await; // 优雅关闭
    });

    srv.await
}
```

## 3.2.10 TLS/mTLS（片段）

```rust
use actix_web::{App, HttpServer};
use rustls::{Certificate, PrivateKey, ServerConfig};

fn tls_config(cert_pem: &str, key_pem: &str) -> ServerConfig { /* 构造 rustls 配置 */ }

HttpServer::new(|| App::new())
    .bind_rustls("0.0.0.0:8443", tls_config(CERT, KEY))?
    .run()
    .await?;
```

- 在 Mesh 场景复用 sidecar mTLS，应用层避免重复加密。

## 3.2.11 与 14.4 蓝图对齐

- 边缘高吞吐入口：配合 NATS/Kafka、零拷贝、批处理、网络调优。
- 指标：QPS/错误率/延迟 P95/P99；异常追踪与流量灰度联动。
