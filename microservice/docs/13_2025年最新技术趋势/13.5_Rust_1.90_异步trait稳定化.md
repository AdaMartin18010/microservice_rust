# 13.5 Rust 1.90 å¼‚æ­¥traitç¨³å®šåŒ–

## ğŸ“‹ ç›®å½•

- [å¼‚æ­¥traitç¨³å®šåŒ–æ¦‚è¿°](#å¼‚æ­¥traitç¨³å®šåŒ–æ¦‚è¿°)
- [æ ¸å¿ƒè¯­è¨€ç‰¹æ€§](#æ ¸å¿ƒè¯­è¨€ç‰¹æ€§)
- [å¾®æœåŠ¡ä¸­çš„åº”ç”¨](#å¾®æœåŠ¡ä¸­çš„åº”ç”¨)
- [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
- [è¿ç§»æŒ‡å—](#è¿ç§»æŒ‡å—)
- [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
- [å®é™…æ¡ˆä¾‹](#å®é™…æ¡ˆä¾‹)

## å¼‚æ­¥traitç¨³å®šåŒ–æ¦‚è¿°

Rust 1.90ç‰ˆæœ¬æ­£å¼ç¨³å®šåŒ–äº†å¼‚æ­¥traitåŠŸèƒ½ï¼Œè¿™æ˜¯Rustå¼‚æ­¥ç¼–ç¨‹çš„ä¸€ä¸ªé‡è¦é‡Œç¨‹ç¢‘ã€‚
è¿™ä¸ªç‰¹æ€§å…è®¸åœ¨traitä¸­ç›´æ¥å®šä¹‰å¼‚æ­¥æ–¹æ³•ï¼Œæ— éœ€ä½¿ç”¨`async-trait`å®ï¼Œå¤§å¤§ç®€åŒ–äº†å¼‚æ­¥ä»£ç çš„ç¼–å†™å’Œç»´æŠ¤ã€‚

### ä¸»è¦ä¼˜åŠ¿

- **æ€§èƒ½æå‡**: æ¶ˆé™¤äº†`async-trait`å®çš„è¿è¡Œæ—¶å¼€é”€
- **ä»£ç ç®€åŒ–**: å‡å°‘äº†æ ·æ¿ä»£ç ï¼Œæé«˜å¼€å‘æ•ˆç‡
- **ç±»å‹å®‰å…¨**: æ›´å¥½çš„ç±»å‹æ¨æ–­å’Œé”™è¯¯æ£€æŸ¥
- **ç”Ÿæ€å…¼å®¹**: ä¸ç°æœ‰å¼‚æ­¥ç”Ÿæ€ç³»ç»Ÿæ— ç¼é›†æˆ

## æ ¸å¿ƒè¯­è¨€ç‰¹æ€§

### 1. åŸç”Ÿå¼‚æ­¥traitå®šä¹‰

```rust
// Rust 1.90 ä¹‹å‰ - éœ€è¦ä½¿ç”¨ async-trait å®
use async_trait::async_trait;

#[async_trait]
pub trait Service {
    async fn process(&self, request: Request) -> Result<Response, Error>;
    async fn health_check(&self) -> Result<HealthStatus, Error>;
}

// Rust 1.90 ä¹‹å - åŸç”Ÿæ”¯æŒ
pub trait Service {
    async fn process(&self, request: Request) -> Result<Response, Error>;
    async fn health_check(&self) -> Result<HealthStatus, Error>;
}
```

### 2. æ³›å‹å…³è”ç±»å‹(GAT)æ”¯æŒ

```rust
// ä½¿ç”¨GATå®šä¹‰å¤æ‚çš„å¼‚æ­¥è¿­ä»£å™¨
pub trait AsyncIterator {
    type Item<'a> where Self: 'a;
    type Future<'a>: Future<Output = Option<Self::Item<'a>>> where Self: 'a;
    
    fn next<'a>(&'a mut self) -> Self::Future<'a>;
}

// å®ç°å¼‚æ­¥è¿­ä»£å™¨
pub struct RequestStream {
    requests: VecDeque<Request>,
}

impl AsyncIterator for RequestStream {
    type Item<'a> = &'a Request;
    type Future<'a> = Pin<Box<dyn Future<Output = Option<&'a Request>> + 'a>>;
    
    fn next<'a>(&'a mut self) -> Self::Future<'a> {
        Box::pin(async move {
            self.requests.pop_front()
        })
    }
}
```

### 3. ç±»å‹åˆ«åå®ç°ç‰¹æ€§(TAIT)

```rust
// ä½¿ç”¨TAITç®€åŒ–å¤æ‚ç±»å‹å®šä¹‰
pub type ServiceResult<T> = impl Future<Output = Result<T, ServiceError>>;

pub fn create_service() -> ServiceResult<ServiceInfo> {
    async move {
        // å¼‚æ­¥æœåŠ¡åˆ›å»ºé€»è¾‘
        Ok(ServiceInfo::new())
    }
}
```

## å¾®æœåŠ¡ä¸­çš„åº”ç”¨

### 1. æœåŠ¡æ¥å£å®šä¹‰

```rust
use std::collections::HashMap;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceRequest {
    pub id: String,
    pub data: String,
    pub metadata: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceResponse {
    pub id: String,
    pub result: String,
    pub status: ResponseStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ResponseStatus {
    Success,
    Error(String),
    Timeout,
}

// ä½¿ç”¨åŸç”Ÿå¼‚æ­¥traitå®šä¹‰å¾®æœåŠ¡æ¥å£
pub trait MicroService {
    async fn handle_request(&self, request: ServiceRequest) -> Result<ServiceResponse, ServiceError>;
    async fn health_check(&self) -> Result<HealthStatus, ServiceError>;
    async fn get_metrics(&self) -> Result<ServiceMetrics, ServiceError>;
    async fn shutdown(&self) -> Result<(), ServiceError>;
}
```

### 2. æœåŠ¡å®ç°

```rust
use tokio::sync::RwLock;
use std::sync::Arc;

pub struct UserService {
    users: Arc<RwLock<HashMap<String, User>>>,
    metrics: Arc<RwLock<ServiceMetrics>>,
}

impl UserService {
    pub fn new() -> Self {
        Self {
            users: Arc::new(RwLock::new(HashMap::new())),
            metrics: Arc::new(RwLock::new(ServiceMetrics::new())),
        }
    }
}

impl MicroService for UserService {
    async fn handle_request(&self, request: ServiceRequest) -> Result<ServiceResponse, ServiceError> {
        let start_time = std::time::Instant::now();
        
        // å¤„ç†ç”¨æˆ·è¯·æ±‚
        let result = match request.data.as_str() {
            "get_user" => {
                let users = self.users.read().await;
                let user = users.get(&request.id);
                match user {
                    Some(user) => serde_json::to_string(user)?,
                    None => "User not found".to_string(),
                }
            }
            "create_user" => {
                let mut users = self.users.write().await;
                let user = User::new(&request.id);
                users.insert(request.id.clone(), user);
                "User created".to_string()
            }
            _ => return Err(ServiceError::InvalidRequest),
        };
        
        // æ›´æ–°æŒ‡æ ‡
        let processing_time = start_time.elapsed().as_millis() as u64;
        let mut metrics = self.metrics.write().await;
        metrics.increment_requests();
        metrics.update_processing_time(processing_time);
        
        Ok(ServiceResponse {
            id: request.id,
            result,
            status: ResponseStatus::Success,
        })
    }
    
    async fn health_check(&self) -> Result<HealthStatus, ServiceError> {
        Ok(HealthStatus {
            service: "user-service".to_string(),
            status: "healthy".to_string(),
            uptime: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)?
                .as_secs(),
        })
    }
    
    async fn get_metrics(&self) -> Result<ServiceMetrics, ServiceError> {
        let metrics = self.metrics.read().await;
        Ok(metrics.clone())
    }
    
    async fn shutdown(&self) -> Result<(), ServiceError> {
        tracing::info!("Shutting down user service");
        Ok(())
    }
}
```

### 3. æœåŠ¡æ³¨å†Œä¸å‘ç°

```rust
use std::sync::Arc;
use tokio::sync::RwLock;

pub struct ServiceRegistry {
    services: Arc<RwLock<HashMap<String, Arc<dyn MicroService + Send + Sync>>>>,
}

impl ServiceRegistry {
    pub fn new() -> Self {
        Self {
            services: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    pub async fn register_service(
        &self,
        name: String,
        service: Arc<dyn MicroService + Send + Sync>,
    ) -> Result<(), ServiceError> {
        let mut services = self.services.write().await;
        services.insert(name, service);
        Ok(())
    }
    
    pub async fn get_service(
        &self,
        name: &str,
    ) -> Option<Arc<dyn MicroService + Send + Sync>> {
        let services = self.services.read().await;
        services.get(name).cloned()
    }
    
    pub async fn list_services(&self) -> Vec<String> {
        let services = self.services.read().await;
        services.keys().cloned().collect()
    }
}
```

## æ€§èƒ½ä¼˜åŒ–

### 1. é›¶æˆæœ¬å¼‚æ­¥æŠ½è±¡

```rust
// Rust 1.90 çš„å¼‚æ­¥traitå®ç°é›¶æˆæœ¬æŠ½è±¡
pub trait HighPerformanceService {
    async fn process_batch(&self, requests: Vec<ServiceRequest>) -> Vec<ServiceResponse> {
        // å¹¶è¡Œå¤„ç†å¤šä¸ªè¯·æ±‚
        let futures: Vec<_> = requests
            .into_iter()
            .map(|req| self.process_single(req))
            .collect();
        
        futures::future::join_all(futures).await
    }
    
    async fn process_single(&self, request: ServiceRequest) -> ServiceResponse {
        // å•ä¸ªè¯·æ±‚å¤„ç†é€»è¾‘
        ServiceResponse {
            id: request.id,
            result: "processed".to_string(),
            status: ResponseStatus::Success,
        }
    }
}
```

### 2. å†…å­˜ä¼˜åŒ–

```rust
use std::pin::Pin;
use std::future::Future;

// ä½¿ç”¨Pinä¼˜åŒ–å†…å­˜å¸ƒå±€
pub struct OptimizedService {
    cache: Arc<RwLock<HashMap<String, CachedData>>>,
}

impl OptimizedService {
    // è¿”å›Pin<Box<dyn Future>>ä»¥ä¼˜åŒ–å†…å­˜åˆ†é…
    pub fn process_request<'a>(
        &'a self,
        request: ServiceRequest,
    ) -> Pin<Box<dyn Future<Output = Result<ServiceResponse, ServiceError>> + 'a>> {
        Box::pin(async move {
            // å¼‚æ­¥å¤„ç†é€»è¾‘
            let cached = self.cache.read().await;
            if let Some(data) = cached.get(&request.id) {
                return Ok(ServiceResponse {
                    id: request.id,
                    result: data.clone(),
                    status: ResponseStatus::Success,
                });
            }
            
            // å¤„ç†æ–°è¯·æ±‚
            let result = self.compute_result(&request).await?;
            
            // æ›´æ–°ç¼“å­˜
            {
                let mut cache = self.cache.write().await;
                cache.insert(request.id.clone(), result.clone());
            }
            
            Ok(ServiceResponse {
                id: request.id,
                result,
                status: ResponseStatus::Success,
            })
        })
    }
    
    async fn compute_result(&self, request: &ServiceRequest) -> Result<String, ServiceError> {
        // æ¨¡æ‹Ÿè®¡ç®—å¯†é›†å‹æ“ä½œ
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        Ok(format!("Result for {}", request.id))
    }
}
```

## è¿ç§»æŒ‡å—

### 1. ä»async-traitè¿ç§»

```rust
// è¿ç§»å‰ - ä½¿ç”¨ async-trait
use async_trait::async_trait;

#[async_trait]
pub trait OldService {
    async fn process(&self, data: String) -> Result<String, Error>;
}

// è¿ç§»å - ä½¿ç”¨åŸç”Ÿå¼‚æ­¥trait
pub trait NewService {
    async fn process(&self, data: String) -> Result<String, Error>;
}

// å®ç°è¿ç§»
pub struct MyService;

// æ—§çš„å®ç°æ–¹å¼
#[async_trait]
impl OldService for MyService {
    async fn process(&self, data: String) -> Result<String, Error> {
        Ok(format!("Processed: {}", data))
    }
}

// æ–°çš„å®ç°æ–¹å¼ - æ›´ç®€æ´
impl NewService for MyService {
    async fn process(&self, data: String) -> Result<String, Error> {
        Ok(format!("Processed: {}", data))
    }
}
```

### 2. ä¾èµ–æ›´æ–°

```toml
# Cargo.toml æ›´æ–°
[dependencies]
# ç§»é™¤ async-trait ä¾èµ–ï¼ˆå¦‚æœä¸å†éœ€è¦ï¼‰
# async-trait = "0.1"  # æ³¨é‡Šæ‰æˆ–åˆ é™¤

# ç¡®ä¿ä½¿ç”¨ Rust 1.90+
[package]
rust-version = "1.90"
```

### 3. ç±»å‹ç³»ç»Ÿæ›´æ–°

```rust
// æ›´æ–°å¤æ‚çš„å¼‚æ­¥ç±»å‹å®šä¹‰
use std::future::Future;
use std::pin::Pin;

// ä½¿ç”¨GATç®€åŒ–ç±»å‹å®šä¹‰
pub trait AsyncProcessor {
    type Output<'a>: Future<Output = Result<String, Error>> + 'a where Self: 'a;
    
    fn process<'a>(&'a self, input: &'a str) -> Self::Output<'a>;
}

pub struct TextProcessor;

impl AsyncProcessor for TextProcessor {
    type Output<'a> = Pin<Box<dyn Future<Output = Result<String, Error>> + 'a>>;
    
    fn process<'a>(&'a self, input: &'a str) -> Self::Output<'a> {
        Box::pin(async move {
            // å¼‚æ­¥å¤„ç†é€»è¾‘
            tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
            Ok(input.to_uppercase())
        })
    }
}
```

## æœ€ä½³å®è·µ

### 1. å¼‚æ­¥traitè®¾è®¡åŸåˆ™

```rust
// å¥½çš„è®¾è®¡ - ç®€æ´æ˜ç¡®çš„æ¥å£
pub trait DatabaseService {
    async fn get(&self, key: &str) -> Result<Option<String>, DatabaseError>;
    async fn set(&self, key: &str, value: &str) -> Result<(), DatabaseError>;
    async fn delete(&self, key: &str) -> Result<(), DatabaseError>;
}

// é¿å…çš„è®¾è®¡ - è¿‡äºå¤æ‚çš„æ¥å£
pub trait BadDatabaseService {
    async fn execute_query<T, F>(&self, query: &str, mapper: F) -> Result<Vec<T>, DatabaseError>
    where
        F: Fn(&str) -> Result<T, DatabaseError> + Send + Sync;
}
```

### 2. é”™è¯¯å¤„ç†

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ServiceError {
    #[error("Network error: {0}")]
    Network(#[from] reqwest::Error),
    
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),
    
    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),
    
    #[error("Invalid request: {message}")]
    InvalidRequest { message: String },
    
    #[error("Service unavailable")]
    ServiceUnavailable,
}

// åœ¨å¼‚æ­¥traitä¸­ä½¿ç”¨é”™è¯¯å¤„ç†
pub trait ResilientService {
    async fn process_with_retry(
        &self,
        request: ServiceRequest,
        max_retries: u32,
    ) -> Result<ServiceResponse, ServiceError> {
        let mut last_error = None;
        
        for attempt in 0..=max_retries {
            match self.process_single(&request).await {
                Ok(response) => return Ok(response),
                Err(e) => {
                    last_error = Some(e);
                    if attempt < max_retries {
                        let delay = std::time::Duration::from_millis(100 * (2_u64.pow(attempt)));
                        tokio::time::sleep(delay).await;
                    }
                }
            }
        }
        
        Err(last_error.unwrap_or(ServiceError::ServiceUnavailable))
    }
    
    async fn process_single(&self, request: &ServiceRequest) -> Result<ServiceResponse, ServiceError>;
}
```

### 3. ç”Ÿå‘½å‘¨æœŸç®¡ç†

```rust
use std::sync::Arc;
use tokio::sync::RwLock;

// ä½¿ç”¨Arcå’ŒRwLockç®¡ç†å…±äº«çŠ¶æ€
pub struct StatefulService {
    state: Arc<RwLock<ServiceState>>,
    config: Arc<ServiceConfig>,
}

#[derive(Clone)]
pub struct ServiceState {
    pub active_connections: u32,
    pub processed_requests: u64,
    pub last_health_check: std::time::SystemTime,
}

impl StatefulService {
    pub fn new(config: ServiceConfig) -> Self {
        Self {
            state: Arc::new(RwLock::new(ServiceState {
                active_connections: 0,
                processed_requests: 0,
                last_health_check: std::time::SystemTime::now(),
            })),
            config: Arc::new(config),
        }
    }
    
    pub async fn update_state<F>(&self, updater: F) -> Result<(), ServiceError>
    where
        F: FnOnce(&mut ServiceState) -> Result<(), ServiceError>,
    {
        let mut state = self.state.write().await;
        updater(&mut state)
    }
    
    pub async fn get_state(&self) -> ServiceState {
        let state = self.state.read().await;
        state.clone()
    }
}
```

## å®é™…æ¡ˆä¾‹

### 1. å®Œæ•´çš„å¾®æœåŠ¡å®ç°

```rust
use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::Json,
    routing::{get, post},
    Router,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::RwLock;

// ä½¿ç”¨Rust 1.90åŸç”Ÿå¼‚æ­¥trait
pub trait UserService {
    async fn get_user(&self, id: &str) -> Result<Option<User>, ServiceError>;
    async fn create_user(&self, user: CreateUserRequest) -> Result<User, ServiceError>;
    async fn update_user(&self, id: &str, user: UpdateUserRequest) -> Result<User, ServiceError>;
    async fn delete_user(&self, id: &str) -> Result<(), ServiceError>;
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    pub id: String,
    pub name: String,
    pub email: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CreateUserRequest {
    pub name: String,
    pub email: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateUserRequest {
    pub name: Option<String>,
    pub email: Option<String>,
}

pub struct InMemoryUserService {
    users: Arc<RwLock<std::collections::HashMap<String, User>>>,
}

impl InMemoryUserService {
    pub fn new() -> Self {
        Self {
            users: Arc::new(RwLock::new(std::collections::HashMap::new())),
        }
    }
}

impl UserService for InMemoryUserService {
    async fn get_user(&self, id: &str) -> Result<Option<User>, ServiceError> {
        let users = self.users.read().await;
        Ok(users.get(id).cloned())
    }
    
    async fn create_user(&self, request: CreateUserRequest) -> Result<User, ServiceError> {
        let id = uuid::Uuid::new_v4().to_string();
        let user = User {
            id: id.clone(),
            name: request.name,
            email: request.email,
            created_at: chrono::Utc::now(),
        };
        
        let mut users = self.users.write().await;
        users.insert(id, user.clone());
        Ok(user)
    }
    
    async fn update_user(&self, id: &str, request: UpdateUserRequest) -> Result<User, ServiceError> {
        let mut users = self.users.write().await;
        let user = users.get_mut(id)
            .ok_or_else(|| ServiceError::InvalidRequest { 
                message: "User not found".to_string() 
            })?;
        
        if let Some(name) = request.name {
            user.name = name;
        }
        if let Some(email) = request.email {
            user.email = email;
        }
        
        Ok(user.clone())
    }
    
    async fn delete_user(&self, id: &str) -> Result<(), ServiceError> {
        let mut users = self.users.write().await;
        users.remove(id)
            .ok_or_else(|| ServiceError::InvalidRequest { 
                message: "User not found".to_string() 
            })?;
        Ok(())
    }
}

// Axumè·¯ç”±å¤„ç†å™¨
pub async fn get_user_handler(
    Path(id): Path<String>,
    State(service): State<Arc<dyn UserService + Send + Sync>>,
) -> Result<Json<User>, (StatusCode, String)> {
    match service.get_user(&id).await {
        Ok(Some(user)) => Ok(Json(user)),
        Ok(None) => Err((StatusCode::NOT_FOUND, "User not found".to_string())),
        Err(e) => Err((StatusCode::INTERNAL_SERVER_ERROR, e.to_string())),
    }
}

pub async fn create_user_handler(
    State(service): State<Arc<dyn UserService + Send + Sync>>,
    Json(request): Json<CreateUserRequest>,
) -> Result<Json<User>, (StatusCode, String)> {
    match service.create_user(request).await {
        Ok(user) => Ok(Json(user)),
        Err(e) => Err((StatusCode::INTERNAL_SERVER_ERROR, e.to_string())),
    }
}

// åˆ›å»ºåº”ç”¨è·¯ç”±
pub fn create_app(service: Arc<dyn UserService + Send + Sync>) -> Router {
    Router::new()
        .route("/users/:id", get(get_user_handler))
        .route("/users", post(create_user_handler))
        .with_state(service)
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åˆå§‹åŒ–æœåŠ¡
    let user_service = Arc::new(InMemoryUserService::new());
    
    // åˆ›å»ºåº”ç”¨
    let app = create_app(user_service);
    
    // å¯åŠ¨æœåŠ¡å™¨
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await?;
    axum::serve(listener, app).await?;
    
    Ok(())
}
```

### 2. æœåŠ¡ç»„åˆä¸ä¾èµ–æ³¨å…¥

```rust
use std::sync::Arc;

// å®šä¹‰æœåŠ¡ä¾èµ–
pub trait DatabaseService {
    async fn save(&self, data: &str) -> Result<String, ServiceError>;
    async fn load(&self, id: &str) -> Result<Option<String>, ServiceError>;
}

pub trait CacheService {
    async fn get(&self, key: &str) -> Result<Option<String>, ServiceError>;
    async fn set(&self, key: &str, value: &str) -> Result<(), ServiceError>;
}

// ç»„åˆæœåŠ¡
pub struct CompositeService {
    database: Arc<dyn DatabaseService + Send + Sync>,
    cache: Arc<dyn CacheService + Send + Sync>,
}

impl CompositeService {
    pub fn new(
        database: Arc<dyn DatabaseService + Send + Sync>,
        cache: Arc<dyn CacheService + Send + Sync>,
    ) -> Self {
        Self { database, cache }
    }
}

impl UserService for CompositeService {
    async fn get_user(&self, id: &str) -> Result<Option<User>, ServiceError> {
        // å…ˆæ£€æŸ¥ç¼“å­˜
        if let Some(cached_data) = self.cache.get(id).await? {
            return Ok(serde_json::from_str(&cached_data)?);
        }
        
        // ä»æ•°æ®åº“åŠ è½½
        if let Some(data) = self.database.load(id).await? {
            let user: User = serde_json::from_str(&data)?;
            
            // æ›´æ–°ç¼“å­˜
            self.cache.set(id, &data).await?;
            
            return Ok(Some(user));
        }
        
        Ok(None)
    }
    
    async fn create_user(&self, request: CreateUserRequest) -> Result<User, ServiceError> {
        let user = User {
            id: uuid::Uuid::new_v4().to_string(),
            name: request.name,
            email: request.email,
            created_at: chrono::Utc::now(),
        };
        
        let data = serde_json::to_string(&user)?;
        self.database.save(&data).await?;
        self.cache.set(&user.id, &data).await?;
        
        Ok(user)
    }
    
    async fn update_user(&self, id: &str, request: UpdateUserRequest) -> Result<User, ServiceError> {
        // è·å–ç°æœ‰ç”¨æˆ·
        let mut user = self.get_user(id).await?
            .ok_or_else(|| ServiceError::InvalidRequest { 
                message: "User not found".to_string() 
            })?;
        
        // æ›´æ–°å­—æ®µ
        if let Some(name) = request.name {
            user.name = name;
        }
        if let Some(email) = request.email {
            user.email = email;
        }
        
        // ä¿å­˜æ›´æ–°
        let data = serde_json::to_string(&user)?;
        self.database.save(&data).await?;
        self.cache.set(id, &data).await?;
        
        Ok(user)
    }
    
    async fn delete_user(&self, id: &str) -> Result<(), ServiceError> {
        // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨
        if self.get_user(id).await?.is_none() {
            return Err(ServiceError::InvalidRequest { 
                message: "User not found".to_string() 
            });
        }
        
        // ä»ç¼“å­˜å’Œæ•°æ®åº“ä¸­åˆ é™¤
        self.cache.set(id, "").await?; // ç®€å•çš„åˆ é™¤æ ‡è®°
        // è¿™é‡Œåº”è¯¥è°ƒç”¨æ•°æ®åº“çš„åˆ é™¤æ–¹æ³•
        
        Ok(())
    }
}
```

## æ€»ç»“

Rust 1.90çš„å¼‚æ­¥traitç¨³å®šåŒ–ä¸ºå¾®æœåŠ¡å¼€å‘å¸¦æ¥äº†é‡å¤§æ”¹è¿›ï¼š

1. **æ€§èƒ½æå‡**: æ¶ˆé™¤äº†`async-trait`å®çš„è¿è¡Œæ—¶å¼€é”€
2. **ä»£ç ç®€åŒ–**: å‡å°‘äº†æ ·æ¿ä»£ç ï¼Œæé«˜äº†å¼€å‘æ•ˆç‡
3. **ç±»å‹å®‰å…¨**: æ›´å¥½çš„ç±»å‹æ¨æ–­å’Œé”™è¯¯æ£€æŸ¥
4. **ç”Ÿæ€å…¼å®¹**: ä¸ç°æœ‰å¼‚æ­¥ç”Ÿæ€ç³»ç»Ÿæ— ç¼é›†æˆ

é€šè¿‡åˆç†ä½¿ç”¨è¿™äº›æ–°ç‰¹æ€§ï¼Œå¯ä»¥æ„å»ºæ›´é«˜æ•ˆã€æ›´å®‰å…¨ã€æ›´æ˜“ç»´æŠ¤çš„å¾®æœåŠ¡ç³»ç»Ÿã€‚å»ºè®®åœ¨è¿ç§»è¿‡ç¨‹ä¸­ï¼š

- é€æ­¥æ›¿æ¢`async-trait`å®çš„ä½¿ç”¨
- åˆ©ç”¨GATç®€åŒ–å¤æ‚çš„å¼‚æ­¥ç±»å‹å®šä¹‰
- ä½¿ç”¨TAITæé«˜ä»£ç å¯è¯»æ€§
- éµå¾ªæœ€ä½³å®è·µç¡®ä¿ä»£ç è´¨é‡

è¿™äº›æ”¹è¿›ä½¿å¾—Ruståœ¨å¾®æœåŠ¡å¼€å‘é¢†åŸŸæ›´å…·ç«äº‰åŠ›ï¼Œä¸ºæ„å»ºé«˜æ€§èƒ½ã€å¯é çš„åˆ†å¸ƒå¼ç³»ç»Ÿæä¾›äº†å¼ºå¤§çš„å·¥å…·æ”¯æŒã€‚
