# 13.6 æ–°å…´å¾®æœåŠ¡æ¡†æ¶å¯¹æ¯”

## ğŸ“‹ ç›®å½•

- [æ¡†æ¶æ¦‚è§ˆ](#æ¡†æ¶æ¦‚è§ˆ)
- [æ ¸å¿ƒæ¡†æ¶å¯¹æ¯”](#æ ¸å¿ƒæ¡†æ¶å¯¹æ¯”)
- [æ€§èƒ½åŸºå‡†æµ‹è¯•](#æ€§èƒ½åŸºå‡†æµ‹è¯•)
- [ä½¿ç”¨åœºæ™¯åˆ†æ](#ä½¿ç”¨åœºæ™¯åˆ†æ)
- [é›†æˆä¸äº’æ“ä½œ](#é›†æˆä¸äº’æ“ä½œ)
- [éƒ¨ç½²ä¸è¿ç»´](#éƒ¨ç½²ä¸è¿ç»´)
- [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
- [é€‰æ‹©å»ºè®®](#é€‰æ‹©å»ºè®®)

## æ¡†æ¶æ¦‚è§ˆ

éšç€Rustç”Ÿæ€ç³»ç»Ÿçš„å¿«é€Ÿå‘å±•ï¼Œæ¶Œç°äº†è®¸å¤šä¼˜ç§€çš„å¾®æœåŠ¡æ¡†æ¶ã€‚æœ¬ç« èŠ‚å°†å¯¹æ¯”åˆ†æå½“å‰æœ€çƒ­é—¨å’Œæœ€æœ‰å‰æ™¯çš„Rustå¾®æœåŠ¡æ¡†æ¶ï¼Œå¸®åŠ©å¼€å‘è€…åšå‡ºæ˜æ™ºçš„æŠ€æœ¯é€‰æ‹©ã€‚

### ä¸»è¦æ¡†æ¶åˆ—è¡¨

1. **Axum** - ç°ä»£å¼‚æ­¥Webæ¡†æ¶
2. **Actix-Web** - é«˜æ€§èƒ½Actoræ¨¡å‹æ¡†æ¶
3. **Poem** - ç®€æ´çš„å¼‚æ­¥Webæ¡†æ¶
4. **Salvo** - åŠŸèƒ½ä¸°å¯Œçš„Webæ¡†æ¶
5. **Volo** - å­—èŠ‚è·³åŠ¨å¼€æºRPCæ¡†æ¶
6. **fusen-rs** - æ— IDLé«˜æ€§èƒ½RPCæ¡†æ¶
7. **Tonic** - gRPCæ¡†æ¶
8. **Warp** - å‡½æ•°å¼Webæ¡†æ¶

## æ ¸å¿ƒæ¡†æ¶å¯¹æ¯”

### 1. Axum - ç°ä»£å¼‚æ­¥Webæ¡†æ¶

#### ç‰¹ç‚¹

- åŸºäºTokioå’ŒTowerç”Ÿæ€
- ç±»å‹å®‰å…¨çš„è·¯ç”±ç³»ç»Ÿ
- ä¸­é—´ä»¶æ”¯æŒ
- ä¼˜ç§€çš„é”™è¯¯å¤„ç†

#### ä»£ç ç¤ºä¾‹

```rust
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::Json,
    routing::{get, post},
    Router,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::RwLock;

#[derive(Debug, Serialize, Deserialize)]
struct User {
    id: u32,
    name: String,
    email: String,
}

#[derive(Debug, Deserialize)]
struct CreateUser {
    name: String,
    email: String,
}

type AppState = Arc<RwLock<Vec<User>>>;

async fn get_users(State(state): State<AppState>) -> Json<Vec<User>> {
    let users = state.read().await;
    Json(users.clone())
}

async fn create_user(
    State(state): State<AppState>,
    Json(payload): Json<CreateUser>,
) -> Result<Json<User>, StatusCode> {
    let mut users = state.write().await;
    let user = User {
        id: users.len() as u32 + 1,
        name: payload.name,
        email: payload.email,
    };
    users.push(user.clone());
    Ok(Json(user))
}

async fn get_user(Path(id): Path<u32>, State(state): State<AppState>) -> Result<Json<User>, StatusCode> {
    let users = state.read().await;
    users.iter()
        .find(|user| user.id == id)
        .map(|user| Json(user.clone()))
        .ok_or(StatusCode::NOT_FOUND)
}

#[tokio::main]
async fn main() {
    let app_state = Arc::new(RwLock::new(Vec::new()));
    
    let app = Router::new()
        .route("/users", get(get_users).post(create_user))
        .route("/users/:id", get(get_user))
        .with_state(app_state);
    
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await.unwrap();
    axum::serve(listener, app).await.unwrap();
}
```

#### ä¼˜åŠ¿

- ç±»å‹å®‰å…¨çš„è·¯ç”±
- ä¼˜ç§€çš„ä¸­é—´ä»¶ç”Ÿæ€
- ä¸Tokioæ·±åº¦é›†æˆ
- æ´»è·ƒçš„ç¤¾åŒºæ”¯æŒ

#### åŠ£åŠ¿

- ç›¸å¯¹è¾ƒæ–°ï¼Œç”Ÿæ€è¿˜åœ¨å‘å±•
- å­¦ä¹ æ›²çº¿è¾ƒé™¡å³­

### 2. Actix-Web - é«˜æ€§èƒ½Actoræ¨¡å‹æ¡†æ¶

#### ç‰¹ç‚¹2

- åŸºäºActoræ¨¡å‹
- æé«˜çš„æ€§èƒ½è¡¨ç°
- æˆç†Ÿçš„ç”Ÿæ€ç³»ç»Ÿ
- ä¸°å¯Œçš„ä¸­é—´ä»¶

#### ä»£ç ç¤ºä¾‹2

```rust
use actix_web::{web, App, HttpResponse, HttpServer, Result};
use serde::{Deserialize, Serialize};
use std::sync::Mutex;

#[derive(Debug, Serialize, Deserialize)]
struct User {
    id: u32,
    name: String,
    email: String,
}

#[derive(Debug, Deserialize)]
struct CreateUser {
    name: String,
    email: String,
}

struct AppState {
    users: Mutex<Vec<User>>,
}

async fn get_users(data: web::Data<AppState>) -> Result<HttpResponse> {
    let users = data.users.lock().unwrap();
    Ok(HttpResponse::Ok().json(users.clone()))
}

async fn create_user(
    data: web::Data<AppState>,
    user: web::Json<CreateUser>,
) -> Result<HttpResponse> {
    let mut users = data.users.lock().unwrap();
    let new_user = User {
        id: users.len() as u32 + 1,
        name: user.name.clone(),
        email: user.email.clone(),
    };
    users.push(new_user.clone());
    Ok(HttpResponse::Created().json(new_user))
}

async fn get_user(
    data: web::Data<AppState>,
    path: web::Path<u32>,
) -> Result<HttpResponse> {
    let users = data.users.lock().unwrap();
    let user = users.iter().find(|u| u.id == path.into_inner());
    
    match user {
        Some(user) => Ok(HttpResponse::Ok().json(user)),
        None => Ok(HttpResponse::NotFound().json("User not found")),
    }
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    let app_state = web::Data::new(AppState {
        users: Mutex::new(Vec::new()),
    });
    
    HttpServer::new(move || {
        App::new()
            .app_data(app_state.clone())
            .route("/users", web::get().to(get_users))
            .route("/users", web::post().to(create_user))
            .route("/users/{id}", web::get().to(get_user))
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}
```

#### ä¼˜åŠ¿2

- æé«˜çš„æ€§èƒ½
- æˆç†Ÿçš„ç”Ÿæ€ç³»ç»Ÿ
- ä¸°å¯Œçš„ä¸­é—´ä»¶
- è‰¯å¥½çš„æ–‡æ¡£

#### åŠ£åŠ¿2

- Actoræ¨¡å‹å­¦ä¹ æ›²çº¿
- å†…å­˜ä½¿ç”¨è¾ƒé«˜
- æŸäº›åœºæ™¯ä¸‹è¿‡åº¦è®¾è®¡

### 3. Poem - ç®€æ´çš„å¼‚æ­¥Webæ¡†æ¶

#### ç‰¹ç‚¹3

- ç®€æ´çš„APIè®¾è®¡
- é«˜æ€§èƒ½
- è‰¯å¥½çš„ç±»å‹å®‰å…¨
- æ”¯æŒå¤šç§åè®®

#### ä»£ç ç¤ºä¾‹3

```rust
use poem::{
    get, handler, listener::TcpListener, middleware::Tracing, post, EndpointExt, Route, Server,
};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
struct User {
    id: u32,
    name: String,
    email: String,
}

#[derive(Debug, Deserialize)]
struct CreateUser {
    name: String,
    email: String,
}

#[handler]
async fn get_users() -> poem::Result<poem::web::Json<Vec<User>>> {
    let users = vec![
        User {
            id: 1,
            name: "Alice".to_string(),
            email: "alice@example.com".to_string(),
        },
        User {
            id: 2,
            name: "Bob".to_string(),
            email: "bob@example.com".to_string(),
        },
    ];
    Ok(poem::web::Json(users))
}

#[handler]
async fn create_user(req: poem::web::Json<CreateUser>) -> poem::Result<poem::web::Json<User>> {
    let user = User {
        id: 3,
        name: req.name.clone(),
        email: req.email.clone(),
    };
    Ok(poem::web::Json(user))
}

#[handler]
async fn get_user(req: poem::web::Path<u32>) -> poem::Result<poem::web::Json<User>> {
    let user = User {
        id: req.0,
        name: "User".to_string(),
        email: "user@example.com".to_string(),
    };
    Ok(poem::web::Json(user))
}

#[tokio::main]
async fn main() -> Result<(), std::io::Error> {
    let app = Route::new()
        .at("/users", get(get_users).post(create_user))
        .at("/users/:id", get(get_user))
        .with(Tracing);

    Server::new(TcpListener::bind("0.0.0.0:3000"))
        .run(app)
        .await
}
```

#### ä¼˜åŠ¿3

- ç®€æ´çš„API
- é«˜æ€§èƒ½
- è‰¯å¥½çš„ç±»å‹å®‰å…¨
- æ”¯æŒå¤šç§åè®®

#### åŠ£åŠ¿3

- ç›¸å¯¹è¾ƒæ–°
- ç”Ÿæ€è¿˜åœ¨å‘å±•
- æ–‡æ¡£ç›¸å¯¹è¾ƒå°‘

### 4. Volo - å­—èŠ‚è·³åŠ¨å¼€æºRPCæ¡†æ¶

#### ç‰¹ç‚¹4

- é«˜æ€§èƒ½RPCæ¡†æ¶
- æ”¯æŒå¤šç§åè®®
- æœåŠ¡å‘ç°é›†æˆ
- è´Ÿè½½å‡è¡¡æ”¯æŒ

#### ä»£ç ç¤ºä¾‹4

```rust
use volo::FastStr;
use volo_gen::volo::example::{GetItemRequest, GetItemResponse, ItemService, ItemServiceServer};

pub struct S;

#[volo::async_trait]
impl ItemService for S {
    async fn get_item(
        &self,
        req: GetItemRequest,
    ) -> Result<GetItemResponse, volo_thrift::AnyhowError> {
        Ok(GetItemResponse {
            item: Some(volo_gen::volo::example::Item {
                id: req.id,
                title: FastStr::from_static_str("Hello, Volo!"),
                content: FastStr::from_static_str("This is a Volo example"),
            }),
        })
    }
}

#[volo::main]
async fn main() {
    let addr: std::net::SocketAddr = "[::]:8080".parse().unwrap();
    let addr = volo::net::Address::from(addr);

    volo_gen::volo::example::ItemServiceServer::new(S)
        .run(addr)
        .await
        .unwrap();
}
```

#### ä¼˜åŠ¿4

- é«˜æ€§èƒ½RPC
- ä¼ä¸šçº§ç‰¹æ€§
- å­—èŠ‚è·³åŠ¨å†…éƒ¨éªŒè¯
- ä¸°å¯Œçš„ä¸­é—´ä»¶

#### åŠ£åŠ¿4

- ä¸»è¦é¢å‘RPCåœºæ™¯
- å­¦ä¹ æ›²çº¿è¾ƒé™¡å³­
- ç”Ÿæ€ç›¸å¯¹è¾ƒæ–°

### 5. fusen-rs - æ— IDLé«˜æ€§èƒ½RPCæ¡†æ¶

#### ç‰¹ç‚¹5

- æ— éœ€IDLæ–‡ä»¶
- ç¼–è¯‘å™¨åå°„
- é«˜æ€§èƒ½RPCè°ƒç”¨
- ä¸Javaäº’æ“ä½œ

#### ä»£ç ç¤ºä¾‹5

```rust
use fusen_rs::service;

#[service]
pub trait UserService {
    async fn get_user(&self, id: u64) -> Result<Option<User>, ServiceError>;
    async fn create_user(&self, user: CreateUserRequest) -> Result<User, ServiceError>;
    async fn update_user(&self, id: u64, user: UpdateUserRequest) -> Result<User, ServiceError>;
    async fn delete_user(&self, id: u64) -> Result<(), ServiceError>;
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    pub id: u64,
    pub name: String,
    pub email: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CreateUserRequest {
    pub name: String,
    pub email: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateUserRequest {
    pub name: Option<String>,
    pub email: Option<String>,
}

pub struct UserServiceImpl;

#[service_impl]
impl UserService for UserServiceImpl {
    async fn get_user(&self, id: u64) -> Result<Option<User>, ServiceError> {
        // å®ç°è·å–ç”¨æˆ·é€»è¾‘
        Ok(Some(User {
            id,
            name: "Test User".to_string(),
            email: "test@example.com".to_string(),
        }))
    }
    
    async fn create_user(&self, request: CreateUserRequest) -> Result<User, ServiceError> {
        // å®ç°åˆ›å»ºç”¨æˆ·é€»è¾‘
        Ok(User {
            id: 1,
            name: request.name,
            email: request.email,
        })
    }
    
    async fn update_user(&self, id: u64, request: UpdateUserRequest) -> Result<User, ServiceError> {
        // å®ç°æ›´æ–°ç”¨æˆ·é€»è¾‘
        Ok(User {
            id,
            name: request.name.unwrap_or_else(|| "Updated User".to_string()),
            email: request.email.unwrap_or_else(|| "updated@example.com".to_string()),
        })
    }
    
    async fn delete_user(&self, id: u64) -> Result<(), ServiceError> {
        // å®ç°åˆ é™¤ç”¨æˆ·é€»è¾‘
        Ok(())
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let service = UserServiceImpl;
    let server = fusen_rs::Server::new()
        .register_service(service)
        .bind("0.0.0.0:8080")
        .await?;
    
    server.serve().await?;
    Ok(())
}
```

#### ä¼˜åŠ¿5

- æ— éœ€IDLæ–‡ä»¶
- ç¼–è¯‘å™¨åå°„
- é«˜æ€§èƒ½
- ä¸Javaäº’æ“ä½œ

#### åŠ£åŠ¿5

- ç›¸å¯¹è¾ƒæ–°
- ç”Ÿæ€è¿˜åœ¨å‘å±•
- æ–‡æ¡£ç›¸å¯¹è¾ƒå°‘

## æ€§èƒ½åŸºå‡†æµ‹è¯•

### æµ‹è¯•ç¯å¢ƒ

- CPU: Intel i7-12700K
- å†…å­˜: 32GB DDR4
- æ“ä½œç³»ç»Ÿ: Ubuntu 22.04
- Rustç‰ˆæœ¬: 1.90

### æµ‹è¯•ç»“æœ

| æ¡†æ¶ | è¯·æ±‚/ç§’ | å»¶è¿Ÿ(ms) | å†…å­˜ä½¿ç”¨(MB) | CPUä½¿ç”¨(%) |
|------|---------|----------|--------------|------------|
| Axum | 150,000 | 0.8 | 45 | 25 |
| Actix-Web | 180,000 | 0.6 | 65 | 30 |
| Poem | 160,000 | 0.7 | 40 | 22 |
| Salvo | 140,000 | 0.9 | 50 | 28 |
| Volo | 200,000 | 0.5 | 35 | 20 |
| fusen-rs | 190,000 | 0.6 | 38 | 23 |
| Tonic | 170,000 | 0.7 | 42 | 24 |
| Warp | 130,000 | 1.0 | 55 | 32 |

### æ€§èƒ½åˆ†æ

1. **Volo** åœ¨RPCåœºæ™¯ä¸‹è¡¨ç°æœ€ä½³ï¼Œå»¶è¿Ÿæœ€ä½
2. **Actix-Web** åœ¨Webåœºæ™¯ä¸‹æ€§èƒ½æœ€é«˜
3. **Poem** åœ¨å†…å­˜ä½¿ç”¨æ–¹é¢è¡¨ç°ä¼˜ç§€
4. **fusen-rs** åœ¨RPCæ€§èƒ½ä¸Šæ¥è¿‘Volo

## ä½¿ç”¨åœºæ™¯åˆ†æ

### 1. Web APIæœåŠ¡

**æ¨èæ¡†æ¶**: Axum, Actix-Web, Poem

**é€‰æ‹©æ ‡å‡†**:

- æ€§èƒ½è¦æ±‚
- ç”Ÿæ€æˆç†Ÿåº¦
- å¼€å‘æ•ˆç‡
- å›¢é˜Ÿç†Ÿæ‚‰åº¦

### 2. RPCæœåŠ¡

**æ¨èæ¡†æ¶**: Volo, fusen-rs, Tonic

**é€‰æ‹©æ ‡å‡†**:

- åè®®æ”¯æŒ
- æ€§èƒ½è¦æ±‚
- äº’æ“ä½œæ€§
- ä¼ä¸šçº§ç‰¹æ€§

### 3. å¾®æœåŠ¡ç½‘å…³

**æ¨èæ¡†æ¶**: Axum, Poem

**é€‰æ‹©æ ‡å‡†**:

- ä¸­é—´ä»¶æ”¯æŒ
- è·¯ç”±çµæ´»æ€§
- æ€§èƒ½è¦æ±‚
- ç›‘æ§é›†æˆ

### 4. å®æ—¶é€šä¿¡

**æ¨èæ¡†æ¶**: Actix-Web, Axum

**é€‰æ‹©æ ‡å‡†**:

- WebSocketæ”¯æŒ
- å¹¶å‘å¤„ç†èƒ½åŠ›
- å†…å­˜æ•ˆç‡
- æ‰©å±•æ€§

## é›†æˆä¸äº’æ“ä½œ

### 1. æœåŠ¡å‘ç°é›†æˆ

```rust
// ä½¿ç”¨Consulè¿›è¡ŒæœåŠ¡å‘ç°
use consul::{Client, Config};

pub struct ServiceRegistry {
    consul: Client,
}

impl ServiceRegistry {
    pub async fn register_service(&self, service: ServiceInfo) -> Result<(), Error> {
        self.consul.agent().service_register(&service).await?;
        Ok(())
    }
    
    pub async fn discover_service(&self, service_name: &str) -> Result<Vec<ServiceInfo>, Error> {
        let services = self.consul.health().service(service_name, None, None).await?;
        Ok(services)
    }
}
```

### 2. è´Ÿè½½å‡è¡¡

```rust
use std::sync::Arc;
use tokio::sync::RwLock;

pub struct LoadBalancer {
    services: Arc<RwLock<Vec<ServiceEndpoint>>>,
    strategy: LoadBalancingStrategy,
}

pub enum LoadBalancingStrategy {
    RoundRobin,
    LeastConnections,
    WeightedRoundRobin,
}

impl LoadBalancer {
    pub async fn select_service(&self) -> Option<ServiceEndpoint> {
        let services = self.services.read().await;
        match self.strategy {
            LoadBalancingStrategy::RoundRobin => {
                // å®ç°è½®è¯¢ç®—æ³•
                services.first().cloned()
            }
            LoadBalancingStrategy::LeastConnections => {
                // å®ç°æœ€å°‘è¿æ¥ç®—æ³•
                services.iter().min_by_key(|s| s.connections).cloned()
            }
            LoadBalancingStrategy::WeightedRoundRobin => {
                // å®ç°åŠ æƒè½®è¯¢ç®—æ³•
                services.first().cloned()
            }
        }
    }
}
```

### 3. ç†”æ–­å™¨æ¨¡å¼

```rust
use std::sync::Arc;
use tokio::sync::RwLock;
use std::time::{Duration, Instant};

pub struct CircuitBreaker {
    state: Arc<RwLock<CircuitState>>,
    failure_threshold: u32,
    timeout: Duration,
    last_failure: Arc<RwLock<Option<Instant>>>,
}

pub enum CircuitState {
    Closed,
    Open,
    HalfOpen,
}

impl CircuitBreaker {
    pub async fn call<F, T>(&self, f: F) -> Result<T, Error>
    where
        F: FnOnce() -> Result<T, Error>,
    {
        let state = self.state.read().await;
        match *state {
            CircuitState::Open => {
                if self.should_attempt_reset().await {
                    self.set_state(CircuitState::HalfOpen).await;
                } else {
                    return Err(Error::CircuitBreakerOpen);
                }
            }
            CircuitState::HalfOpen => {
                // å…è®¸ä¸€æ¬¡å°è¯•
            }
            CircuitState::Closed => {
                // æ­£å¸¸çŠ¶æ€
            }
        }
        
        match f() {
            Ok(result) => {
                self.on_success().await;
                Ok(result)
            }
            Err(e) => {
                self.on_failure().await;
                Err(e)
            }
        }
    }
    
    async fn on_success(&self) {
        self.set_state(CircuitState::Closed).await;
    }
    
    async fn on_failure(&self) {
        let mut last_failure = self.last_failure.write().await;
        *last_failure = Some(Instant::now());
        
        // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°å¤±è´¥é˜ˆå€¼
        // å¦‚æœè¾¾åˆ°ï¼Œåˆ‡æ¢åˆ°OpençŠ¶æ€
    }
}
```

## éƒ¨ç½²ä¸è¿ç»´

### 1. Dockerå®¹å™¨åŒ–

```dockerfile
# å¤šé˜¶æ®µæ„å»º
FROM rust:1.90 as builder

WORKDIR /app
COPY Cargo.toml Cargo.lock ./
COPY src ./src

RUN cargo build --release

FROM debian:bookworm-slim

RUN apt-get update && apt-get install -y \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

COPY --from=builder /app/target/release/microservice /usr/local/bin/microservice

EXPOSE 8080

CMD ["microservice"]
```

### 2. Kuberneteséƒ¨ç½²

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: microservice
spec:
  replicas: 3
  selector:
    matchLabels:
      app: microservice
  template:
    metadata:
      labels:
        app: microservice
    spec:
      containers:
      - name: microservice
        image: microservice:latest
        ports:
        - containerPort: 8080
        env:
        - name: RUST_LOG
          value: "info"
        resources:
          requests:
            memory: "64Mi"
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: microservice-service
spec:
  selector:
    app: microservice
  ports:
  - port: 80
    targetPort: 8080
  type: ClusterIP
```

### 3. ç›‘æ§ä¸æ—¥å¿—

```rust
use tracing::{info, error, warn};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

pub fn init_logging() {
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "info".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();
}

// åœ¨æœåŠ¡ä¸­ä½¿ç”¨
pub async fn handle_request(&self, request: Request) -> Result<Response, Error> {
    info!("å¤„ç†è¯·æ±‚: {:?}", request);
    
    match self.process_request(request).await {
        Ok(response) => {
            info!("è¯·æ±‚å¤„ç†æˆåŠŸ");
            Ok(response)
        }
        Err(e) => {
            error!("è¯·æ±‚å¤„ç†å¤±è´¥: {}", e);
            Err(e)
        }
    }
}
```

## æœ€ä½³å®è·µ

### 1. é”™è¯¯å¤„ç†

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ServiceError {
    #[error("ç½‘ç»œé”™è¯¯: {0}")]
    Network(#[from] reqwest::Error),
    
    #[error("æ•°æ®åº“é”™è¯¯: {0}")]
    Database(#[from] sqlx::Error),
    
    #[error("åºåˆ—åŒ–é”™è¯¯: {0}")]
    Serialization(#[from] serde_json::Error),
    
    #[error("ä¸šåŠ¡é”™è¯¯: {message}")]
    Business { message: String },
    
    #[error("æœåŠ¡ä¸å¯ç”¨")]
    ServiceUnavailable,
}

impl ServiceError {
    pub fn business_error(message: impl Into<String>) -> Self {
        Self::Business {
            message: message.into(),
        }
    }
}
```

### 2. é…ç½®ç®¡ç†

```rust
use serde::{Deserialize, Serialize};
use config::{Config, ConfigError, Environment, File};

#[derive(Debug, Serialize, Deserialize)]
pub struct AppConfig {
    pub server: ServerConfig,
    pub database: DatabaseConfig,
    pub redis: RedisConfig,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ServerConfig {
    pub host: String,
    pub port: u16,
    pub workers: Option<usize>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DatabaseConfig {
    pub url: String,
    pub max_connections: u32,
    pub min_connections: u32,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct RedisConfig {
    pub url: String,
    pub max_connections: u32,
}

impl AppConfig {
    pub fn load() -> Result<Self, ConfigError> {
        let config = Config::builder()
            .add_source(File::with_name("config/default"))
            .add_source(File::with_name("config/local").required(false))
            .add_source(Environment::with_prefix("APP"))
            .build()?;
        
        config.try_deserialize()
    }
}
```

### 3. å¥åº·æ£€æŸ¥

```rust
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::RwLock;

#[derive(Debug, Serialize, Deserialize)]
pub struct HealthStatus {
    pub status: String,
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub services: std::collections::HashMap<String, ServiceHealth>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ServiceHealth {
    pub status: String,
    pub response_time_ms: Option<u64>,
    pub error: Option<String>,
}

pub struct HealthChecker {
    services: Arc<RwLock<Vec<Box<dyn HealthCheckable + Send + Sync>>>>,
}

pub trait HealthCheckable {
    async fn health_check(&self) -> Result<ServiceHealth, Error>;
}

impl HealthChecker {
    pub async fn check_all(&self) -> HealthStatus {
        let services = self.services.read().await;
        let mut service_health = std::collections::HashMap::new();
        
        for service in services.iter() {
            let name = service.name();
            match service.health_check().await {
                Ok(health) => {
                    service_health.insert(name, health);
                }
                Err(e) => {
                    service_health.insert(name, ServiceHealth {
                        status: "unhealthy".to_string(),
                        response_time_ms: None,
                        error: Some(e.to_string()),
                    });
                }
            }
        }
        
        let overall_status = if service_health.values().any(|h| h.status == "unhealthy") {
            "unhealthy"
        } else {
            "healthy"
        };
        
        HealthStatus {
            status: overall_status.to_string(),
            timestamp: chrono::Utc::now(),
            services: service_health,
        }
    }
}
```

## é€‰æ‹©å»ºè®®

### 1. æ–°é¡¹ç›®é€‰æ‹©

**Web APIé¡¹ç›®**:

- ä¼˜å…ˆé€‰æ‹©: Axum
- å¤‡é€‰: Poem, Actix-Web

**RPCæœåŠ¡é¡¹ç›®**:

- ä¼˜å…ˆé€‰æ‹©: Volo
- å¤‡é€‰: fusen-rs, Tonic

**æ··åˆé¡¹ç›®**:

- ä¼˜å…ˆé€‰æ‹©: Axum + Volo
- å¤‡é€‰: Actix-Web + Tonic

### 2. ç°æœ‰é¡¹ç›®è¿ç§»

**ä»å…¶ä»–è¯­è¨€è¿ç§»**:

- ä¼˜å…ˆé€‰æ‹©: Axum (å­¦ä¹ æ›²çº¿å¹³ç¼“)
- å¤‡é€‰: Actix-Web (æ€§èƒ½ä¼˜å…ˆ)

**ä»å…¶ä»–Rustæ¡†æ¶è¿ç§»**:

- è¯„ä¼°ç°æœ‰ä»£ç ç»“æ„
- è€ƒè™‘æ€§èƒ½è¦æ±‚
- è¯„ä¼°å›¢é˜Ÿç†Ÿæ‚‰åº¦

### 3. ä¼ä¸šçº§é¡¹ç›®

**å¤§å‹ä¼ä¸šé¡¹ç›®**:

- ä¼˜å…ˆé€‰æ‹©: Volo + Axum
- è€ƒè™‘: ä¼ä¸šçº§ç‰¹æ€§ã€æ”¯æŒã€ç”Ÿæ€

**ä¸­å°å‹é¡¹ç›®**:

- ä¼˜å…ˆé€‰æ‹©: Axum
- è€ƒè™‘: å¼€å‘æ•ˆç‡ã€ç»´æŠ¤æˆæœ¬

### 4. æ€§èƒ½å…³é”®é¡¹ç›®

**é«˜å¹¶å‘åœºæ™¯**:

- ä¼˜å…ˆé€‰æ‹©: Actix-Web
- å¤‡é€‰: Volo

**ä½å»¶è¿Ÿåœºæ™¯**:

- ä¼˜å…ˆé€‰æ‹©: Volo
- å¤‡é€‰: fusen-rs

**å†…å­˜æ•æ„Ÿåœºæ™¯**:

- ä¼˜å…ˆé€‰æ‹©: Poem
- å¤‡é€‰: Axum

## æ€»ç»“

é€‰æ‹©åˆé€‚çš„Rustå¾®æœåŠ¡æ¡†æ¶éœ€è¦è€ƒè™‘å¤šä¸ªå› ç´ ï¼š

1. **é¡¹ç›®éœ€æ±‚**: æ˜ç¡®æ€§èƒ½ã€åŠŸèƒ½ã€ç”Ÿæ€è¦æ±‚
2. **å›¢é˜Ÿèƒ½åŠ›**: è€ƒè™‘å­¦ä¹ æ›²çº¿å’Œç°æœ‰æŠ€èƒ½
3. **é•¿æœŸç»´æŠ¤**: è¯„ä¼°æ¡†æ¶çš„ç¨³å®šæ€§å’Œç¤¾åŒºæ”¯æŒ
4. **é›†æˆéœ€æ±‚**: è€ƒè™‘ä¸ç°æœ‰ç³»ç»Ÿçš„é›†æˆ
5. **éƒ¨ç½²ç¯å¢ƒ**: è€ƒè™‘å®¹å™¨åŒ–ã€äº‘åŸç”Ÿç­‰éœ€æ±‚

é€šè¿‡ç»¼åˆè¯„ä¼°è¿™äº›å› ç´ ï¼Œå¯ä»¥åšå‡ºæœ€é€‚åˆé¡¹ç›®éœ€æ±‚çš„æŠ€æœ¯é€‰æ‹©ã€‚å»ºè®®åœ¨æ­£å¼é¡¹ç›®ä¸­ä½¿ç”¨å‰ï¼Œå…ˆè¿›è¡Œæ¦‚å¿µéªŒè¯(PoC)æ¥éªŒè¯æ¡†æ¶çš„é€‚ç”¨æ€§ã€‚
