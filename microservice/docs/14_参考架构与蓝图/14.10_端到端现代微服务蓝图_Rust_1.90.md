# 14.10 端到端现代微服务蓝图（Rust 1.90）

> 结合 Rust 1.90（异步 trait/GAT/TAIT）、Axum/Tonic、Traefik、etcd/Consul、OpenTelemetry、SQLx/SeaORM、Redis、NATS/Kafka，形成可演进的端到端方案。

## 14.10.1 架构总览

- 入口：Traefik + mTLS + WAF + 路由；
- 网关内策略：见 5.4 自定义路由策略（sticky/灰度/标签）；
- 内部通信：Tonic gRPC（核心路径）+ Axum HTTP（开放 REST）；
- 服务发现：etcd/Consul；
- 数据：SQLx/SeaORM + Redis 二级缓存；
- 事件总线：NATS 控制面 + Kafka 业务主干（见 7.5）。

## 14.10.2 关键设计

- 能力边界：以 trait 定义、TAIT 隐藏复杂返回类型，模块间接口稳定；
- 弹性与容错：tower 限流/熔断/超时/重试；
- 配置热更：NATS KV/etcd 通知，服务端滚动更新；
- 可观测性：OTel 指标/日志/追踪三合一，统一 `x-request-id` 与 baggage。

## 14.10.3 服务模板（骨架）

```rust
// 省略 imports
pub type ServiceFuture = impl core::future::Future<Output = Result<Response, Error>> + Send;

#[tonic::async_trait]
pub trait UserService {
    async fn get(&self, id: UserId) -> Result<User, DomainError>;
}

pub async fn http_handler(req: Request) -> ServiceFuture {
    async move {
        // 路由决策、遥测、调用领域服务
        Ok(Response::new(/* body */))
    }
}
```

## 14.10.4 数据与缓存

- 读路径：LRU -> Redis -> DB，命中打点；
- 写路径：DB 落地 -> 失效/更新 Redis -> 事件发 Kafka；
- 幂等：业务键 + 版本；
- 观测：命中率/延迟/错误率/热点。

## 14.10.5 事件与流处理

- NATS 即时通知与控制开关；
- Kafka 事件作为事实来源，可回放；
- 流任务：批/流混合，背压与重试策略清晰。

## 14.10.6 安全与合规

- mTLS 与 SPIFFE；
- 主题级 ACL 与最小权限；
- PII 脱敏与审计日志。

## 14.10.7 部署与运行

- 容器化：多阶段构建 + distroless；
- 编排：Kubernetes + HPA；
- 可观测：OTel-Collector + Prometheus + Grafana；
- 配置：ConfigMap/Secret + 动态下发。

### 观测栈与网关（K8s 片段）

```yaml
    # OpenTelemetry Collector（简化）
    apiVersion: apps/v1
    kind: Deployment
    metadata: { name: otel-collector }
    spec:
    replicas: 1
    selector: { matchLabels: { app: otel-collector } }
    template:
        metadata: { labels: { app: otel-collector } }
        spec:
        containers:
        - name: otel-collector
            image: otel/opentelemetry-collector:0.99.0
            args: [ "--config=/etc/otel/config.yaml" ]
            volumeMounts: [ { name: cfg, mountPath: /etc/otel } ]
        volumes:
        - name: cfg
            configMap: { name: otel-collector-config }
    ---
    # Traefik Ingress（TLS 略）
    apiVersion: traefik.containo.us/v1alpha1
    kind: IngressRoute
    metadata: { name: gateway }
    spec:
    entryPoints: [ websecure ]
    routes:
        - match: Host(`api.example.com`)
        kind: Rule
        services: [ { name: user-service, port: 80 } ]
    ---
    # Envoy Gateway（示例：HTTPRoute + TLS 终止）
    apiVersion: gateway.networking.k8s.io/v1
    kind: Gateway
    metadata: { name: eg }
    spec:
    gatewayClassName: envoy-gateway-class
    listeners:
        - name: https
        port: 443
        protocol: HTTPS
        tls:
            mode: Terminate
            certificateRefs: [ { name: api-cert } ]
    ---
    apiVersion: gateway.networking.k8s.io/v1
    kind: HTTPRoute
    metadata: { name: user }
    spec:
    parentRefs: [ { name: eg } ]
    rules:
        - matches: [ { path: { type: PathPrefix, value: /user } } ]
        backendRefs: [ { name: user-service, port: 80 } ]
    ---

    ## Nacos（示例简化，生产建议 Helm 官方 Chart）
    apiVersion: apps/v1
    kind: Deployment
    metadata: { name: nacos }
    spec:
    replicas: 1
    selector: { matchLabels: { app: nacos } }
    template:
        metadata: { labels: { app: nacos } }
        spec:
        containers:
        - name: nacos
            image: nacos/nacos-server:v2.3.2
            env:
            - { name: MODE, value: standalone }
    ---

    ```rust
    // 客户端解析片段（伪代码）：直连与经网关解析到服务端点
    async fn resolve_endpoint(service: &str) -> anyhow::Result<Url> {
        if let Ok(url) = std::env::var("GATEWAY_BASE") {
            return Ok(Url::parse(&format!("{url}/{service}"))?);
        }
        // etcd/Consul/Nacos 查询（省略具体 SDK 细节）
        // 返回健康实例带权重的地址
        Ok(Url::parse("http://user-service.default.svc:8080")?)
    }
    ```

## Consul（示例简化）

```yaml
apiVersion: apps/v1
kind: Deployment
metadata: { name: consul }
spec:
  replicas: 1
  selector: { matchLabels: { app: consul } }
  template:
    metadata: { labels: { app: consul } }
    spec:
      containers:
      - name: consul
        image: hashicorp/consul:1.18
        args: ["agent","-dev","-client","0.0.0.0"]
---
apiVersion: v1
kind: Service
metadata: { name: consul }
spec:
  selector: { app: consul }
  ports:
    - name: http
      port: 8500
      targetPort: 8500
```

```rust
// 通过 Consul 查询带权重健康实例（伪代码）
#[derive(serde::Deserialize)]
struct ConsulService {
  ServiceAddress: String,
  ServicePort: u16,
  ServiceMeta: std::collections::HashMap<String, String>, // 可包含权重/版本/区域等
}

async fn pick_weighted_instance(service: &str) -> anyhow::Result<Url> {
  let url = format!("http://consul.default.svc:8500/v1/health/service/{service}?passing=true");
  let list: Vec<serde_json::Value> = reqwest::get(&url).await?.json().await?;
  let mut candidates: Vec<(u32, Url)> = Vec::new();
  for item in list {
    let svc: &serde_json::Value = &item["Service"];
    let addr = svc["Address"].as_str().unwrap_or("");
    let port = svc["Port"].as_u64().unwrap_or(0) as u16;
    let meta = &svc["Meta"];
    let weight = meta["weight"].as_str().unwrap_or("100").parse::<u32>().unwrap_or(100);
    if !addr.is_empty() && port > 0 {
      candidates.push((weight, Url::parse(&format!("http://{addr}:{port}"))?));
    }
  }
  // 简单按权重随机
  use rand::distributions::{Distribution, WeightedIndex};
  let weights: Vec<u32> = candidates.iter().map(|(w, _)| *w).collect();
  let dist = WeightedIndex::new(&weights)?;
  let mut rng = rand::thread_rng();
  let idx = dist.sample(&mut rng);
  Ok(candidates[idx].1.clone())
}
```

```yaml
# etcd （示例，生产需持久化与 TLS）
apiVersion: apps/v1
kind: StatefulSet
metadata: { name: etcd }
spec:
  selector: { matchLabels: { app: etcd } }
  serviceName: etcd
  replicas: 3
  template:
    metadata: { labels: { app: etcd } }
    spec:
      containers:
      - name: etcd
        image: quay.io/coreos/etcd:v3.5.13
        command: ["etcd"]
        args: ["--advertise-client-urls","http://$(HOSTNAME).etcd:2379","--listen-client-urls","http://0.0.0.0:2379"]
---
# Consul （示例，生产建议 Helm/HashiCorp 官方 Chart）
apiVersion: apps/v1
kind: Deployment
metadata: { name: consul }
spec:
  replicas: 1
  selector: { matchLabels: { app: consul } }
  template:
    metadata: { labels: { app: consul } }
    spec:
      containers:
      - name: consul
        image: hashicorp/consul:1.18
        args: ["agent","-dev","-client","0.0.0.0"]

```

### GitOps 流程（简述）

- 分支策略：`main` 受保护、`release/*`、`feat/*`；
- CI：构建/测试/安全扫描（SAST/依赖漏洞）/镜像签名（cosign）；
- CD：Argo CD/Flux 监听 `env/{prod,staging}` 清单库；
- 渐进式交付：金丝雀 + 自动回滚（指标阈值触发）。

## 14.10.8 演进路线

- 单体到微服务的绞杀者模式迁移；
- 引入 TAIT/GAT 优化中间件与流式接口；
- 引入 NATS/Kafka 双总线，逐步把控制面与数据面解耦。

## 14.10.9 SLO/SLA 参考基线（示例）

- 可用性：99.95%（月）
- 请求延迟：P50 20ms / P95 100ms / P99 300ms（内网 RPC）
- 错误率：< 0.1%
- 事件滞留：< 1 分钟（Kafka 主干）
- 观测覆盖：追踪采样率 ≥ 5%（高QPS服务动态采样）

### 关联阅读

- `14.12` 端到端生产基线·落地索引（参数模板与验收清单）
- `17.6` 编译器优化与代码生成（调优入口与构建加速）

---
该蓝图聚焦“可观测、可回放、可灰度、可回退”，在高可靠与高性能之间取得工程化平衡。
