# 14.7 Rust 1.90 现代化架构

## 概述

Rust 1.90 引入了多项重要特性，为构建现代化微服务架构提供了更强大的工具和更优雅的抽象。本章将深入探讨如何利用 Rust 1.90 的新特性来构建高性能、安全、可维护的微服务系统。

## Rust 1.90 核心特性

### 1. 原生异步 Trait

Rust 1.90 引入了原生异步 trait 支持，消除了对 `async-trait` 宏的依赖，提供了更简洁的异步编程体验。

#### 异步服务接口设计

```rust
// 使用原生异步 trait 定义服务接口
use std::future::Future;
use std::pin::Pin;

// 用户服务接口
pub trait UserService {
    async fn get_user(&self, id: u64) -> Result<User, ServiceError>;
    async fn create_user(&self, user: CreateUserRequest) -> Result<User, ServiceError>;
    async fn update_user(&self, id: u64, user: UpdateUserRequest) -> Result<User, ServiceError>;
    async fn delete_user(&self, id: u64) -> Result<(), ServiceError>;
    async fn list_users(&self, page: u32, size: u32) -> Result<Vec<User>, ServiceError>;
}

// 订单服务接口
pub trait OrderService {
    async fn create_order(&self, order: CreateOrderRequest) -> Result<Order, ServiceError>;
    async fn get_order(&self, id: u64) -> Result<Order, ServiceError>;
    async fn update_order_status(&self, id: u64, status: OrderStatus) -> Result<Order, ServiceError>;
    async fn get_user_orders(&self, user_id: u64) -> Result<Vec<Order>, ServiceError>;
}

// 支付服务接口
pub trait PaymentService {
    async fn process_payment(&self, payment: PaymentRequest) -> Result<PaymentResult, ServiceError>;
    async fn refund_payment(&self, payment_id: u64) -> Result<RefundResult, ServiceError>;
    async fn get_payment_status(&self, payment_id: u64) -> Result<PaymentStatus, ServiceError>;
}

// 服务组合器 - 使用原生异步 trait
pub struct CompositeService {
    user_service: Box<dyn UserService + Send + Sync>,
    order_service: Box<dyn OrderService + Send + Sync>,
    payment_service: Box<dyn PaymentService + Send + Sync>,
}

impl CompositeService {
    pub fn new(
        user_service: Box<dyn UserService + Send + Sync>,
        order_service: Box<dyn OrderService + Send + Sync>,
        payment_service: Box<dyn PaymentService + Send + Sync>,
    ) -> Self {
        Self {
            user_service,
            order_service,
            payment_service,
        }
    }

    // 复合操作 - 创建订单并处理支付
    pub async fn create_order_with_payment(
        &self,
        user_id: u64,
        order_request: CreateOrderRequest,
        payment_request: PaymentRequest,
    ) -> Result<(Order, PaymentResult), ServiceError> {
        // 验证用户存在
        let _user = self.user_service.get_user(user_id).await?;
        
        // 创建订单
        let order = self.order_service.create_order(order_request).await?;
        
        // 处理支付
        let payment_result = self.payment_service.process_payment(payment_request).await?;
        
        // 更新订单状态
        if payment_result.success {
            self.order_service.update_order_status(order.id, OrderStatus::Paid).await?;
        }
        
        Ok((order, payment_result))
    }
}
```

### 2. 泛型关联类型 (GAT)

GAT 允许在 trait 中定义泛型关联类型，为复杂的类型抽象提供了更强大的表达能力。

#### 数据库抽象层

```rust
use std::future::Future;
use std::pin::Pin;

// 数据库连接抽象
pub trait DatabaseConnection {
    type Transaction<'a>: DatabaseTransaction<'a> + Send + Sync
    where
        Self: 'a;
    
    async fn begin_transaction(&self) -> Result<Self::Transaction<'_>, DatabaseError>;
    async fn execute_query<T>(&self, query: &str, params: &[&dyn ToSql]) -> Result<Vec<T>, DatabaseError>;
}

// 数据库事务抽象
pub trait DatabaseTransaction<'a> {
    async fn commit(self) -> Result<(), DatabaseError>;
    async fn rollback(self) -> Result<(), DatabaseError>;
    async fn execute_query<T>(&self, query: &str, params: &[&dyn ToSql]) -> Result<Vec<T>, DatabaseError>;
}

// 仓储模式实现
pub trait Repository<T, ID> {
    type Connection: DatabaseConnection;
    
    async fn find_by_id(&self, conn: &Self::Connection, id: ID) -> Result<Option<T>, DatabaseError>;
    async fn find_all(&self, conn: &Self::Connection) -> Result<Vec<T>, DatabaseError>;
    async fn save(&self, conn: &Self::Connection, entity: &T) -> Result<T, DatabaseError>;
    async fn update(&self, conn: &Self::Connection, entity: &T) -> Result<T, DatabaseError>;
    async fn delete(&self, conn: &Self::Connection, id: ID) -> Result<(), DatabaseError>;
}

// 用户仓储实现
pub struct UserRepository<C: DatabaseConnection> {
    connection: C,
}

impl<C: DatabaseConnection> Repository<User, u64> for UserRepository<C> {
    type Connection = C;
    
    async fn find_by_id(&self, conn: &Self::Connection, id: u64) -> Result<Option<User>, DatabaseError> {
        let query = "SELECT id, name, email, created_at FROM users WHERE id = ?";
        let params = vec![&id as &dyn ToSql];
        let results: Vec<User> = conn.execute_query(query, &params).await?;
        Ok(results.into_iter().next())
    }
    
    async fn find_all(&self, conn: &Self::Connection) -> Result<Vec<User>, DatabaseError> {
        let query = "SELECT id, name, email, created_at FROM users";
        conn.execute_query(query, &[]).await
    }
    
    async fn save(&self, conn: &Self::Connection, user: &User) -> Result<User, DatabaseError> {
        let query = "INSERT INTO users (name, email) VALUES (?, ?)";
        let params = vec![&user.name as &dyn ToSql, &user.email as &dyn ToSql];
        conn.execute_query(query, &params).await?;
        Ok(user.clone())
    }
    
    async fn update(&self, conn: &Self::Connection, user: &User) -> Result<User, DatabaseError> {
        let query = "UPDATE users SET name = ?, email = ? WHERE id = ?";
        let params = vec![
            &user.name as &dyn ToSql,
            &user.email as &dyn ToSql,
            &user.id as &dyn ToSql,
        ];
        conn.execute_query(query, &params).await?;
        Ok(user.clone())
    }
    
    async fn delete(&self, conn: &Self::Connection, id: u64) -> Result<(), DatabaseError> {
        let query = "DELETE FROM users WHERE id = ?";
        let params = vec![&id as &dyn ToSql];
        conn.execute_query(query, &params).await?;
        Ok(())
    }
}
```

### 3. 类型别名 impl Trait (TAIT)

TAIT 允许在类型别名中使用 `impl Trait`，提供了更灵活的类型抽象。

#### 服务工厂模式

```rust
use std::future::Future;
use std::pin::Pin;

// 服务工厂类型别名
pub type ServiceFactory<T> = impl Fn() -> Pin<Box<dyn Future<Output = Result<T, ServiceError>> + Send>>;

// 配置加载器类型别名
pub type ConfigLoader<T> = impl Fn(&str) -> Pin<Box<dyn Future<Output = Result<T, ConfigError>> + Send>>;

// 中间件链类型别名
pub type MiddlewareChain = impl Fn(Request) -> Pin<Box<dyn Future<Output = Result<Response, ServiceError>> + Send>>;

// 服务注册表
pub struct ServiceRegistry {
    services: std::collections::HashMap<String, Box<dyn std::any::Any + Send + Sync>>,
}

impl ServiceRegistry {
    pub fn new() -> Self {
        Self {
            services: std::collections::HashMap::new(),
        }
    }
    
    pub fn register<T: 'static + Send + Sync>(&mut self, name: &str, service: T) {
        self.services.insert(name.to_string(), Box::new(service));
    }
    
    pub fn get<T: 'static>(&self, name: &str) -> Option<&T> {
        self.services.get(name)?.downcast_ref::<T>()
    }
}

// 服务构建器
pub struct ServiceBuilder {
    registry: ServiceRegistry,
    middleware: Vec<Box<dyn Middleware + Send + Sync>>,
}

impl ServiceBuilder {
    pub fn new() -> Self {
        Self {
            registry: ServiceRegistry::new(),
            middleware: Vec::new(),
        }
    }
    
    pub fn with_service<T: 'static + Send + Sync>(mut self, name: &str, service: T) -> Self {
        self.registry.register(name, service);
        self
    }
    
    pub fn with_middleware<M: Middleware + Send + Sync + 'static>(mut self, middleware: M) -> Self {
        self.middleware.push(Box::new(middleware));
        self
    }
    
    pub fn build(self) -> ServiceRegistry {
        self.registry
    }
}

// 中间件 trait
pub trait Middleware {
    async fn handle(&self, request: Request) -> Result<Response, ServiceError>;
}
```

## 现代化架构模式

### 1. 事件驱动架构

#### 事件总线实现

```rust
use std::sync::Arc;
use tokio::sync::{broadcast, RwLock};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DomainEvent {
    pub event_id: String,
    pub event_type: String,
    pub aggregate_id: String,
    pub aggregate_type: String,
    pub event_data: serde_json::Value,
    pub metadata: HashMap<String, String>,
    pub timestamp: u64,
    pub version: u32,
}

// 事件处理器 trait
pub trait EventHandler<T: Clone + Send + Sync + 'static> {
    async fn handle(&self, event: &DomainEvent) -> Result<(), EventError>;
}

// 事件总线
pub struct EventBus {
    channels: Arc<RwLock<HashMap<String, broadcast::Sender<DomainEvent>>>>,
    handlers: Arc<RwLock<HashMap<String, Vec<Box<dyn EventHandler<()> + Send + Sync>>>>>,
}

impl EventBus {
    pub fn new() -> Self {
        Self {
            channels: Arc::new(RwLock::new(HashMap::new())),
            handlers: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    pub async fn publish(&self, event: DomainEvent) -> Result<(), EventError> {
        let event_type = event.event_type.clone();
        let channels = self.channels.read().await;
        
        if let Some(sender) = channels.get(&event_type) {
            let _ = sender.send(event);
        }
        
        Ok(())
    }
    
    pub async fn subscribe<H: EventHandler<()> + Send + Sync + 'static>(
        &self,
        event_type: &str,
        handler: H,
    ) -> Result<(), EventError> {
        // 注册处理器
        let mut handlers = self.handlers.write().await;
        let event_handlers = handlers.entry(event_type.to_string()).or_insert_with(Vec::new);
        event_handlers.push(Box::new(handler));
        
        // 创建或获取广播通道
        let mut channels = self.channels.write().await;
        if !channels.contains_key(event_type) {
            let (tx, _) = broadcast::channel(1000);
            channels.insert(event_type.to_string(), tx);
        }
        
        Ok(())
    }
    
    pub async fn start_event_processing(&self) {
        let channels = self.channels.read().await;
        let handlers = self.handlers.read().await;
        
        for (event_type, sender) in channels.iter() {
            let mut receiver = sender.subscribe();
            let event_handlers = handlers.get(event_type).cloned().unwrap_or_default();
            
            tokio::spawn(async move {
                while let Ok(event) = receiver.recv().await {
                    for handler in &event_handlers {
                        if let Err(e) = handler.handle(&event).await {
                            eprintln!("Event handler error: {:?}", e);
                        }
                    }
                }
            });
        }
    }
}

// 用户事件处理器
pub struct UserEventHandler {
    user_repository: Arc<dyn UserRepository + Send + Sync>,
}

impl EventHandler<()> for UserEventHandler {
    async fn handle(&self, event: &DomainEvent) -> Result<(), EventError> {
        match event.event_type.as_str() {
            "UserCreated" => {
                // 处理用户创建事件
                println!("User created: {}", event.aggregate_id);
            }
            "UserUpdated" => {
                // 处理用户更新事件
                println!("User updated: {}", event.aggregate_id);
            }
            "UserDeleted" => {
                // 处理用户删除事件
                println!("User deleted: {}", event.aggregate_id);
            }
            _ => {}
        }
        Ok(())
    }
}
```

### 2. CQRS 模式实现

#### 命令和查询分离

```rust
use std::future::Future;
use std::pin::Pin;

// 命令 trait
pub trait Command {
    type Result;
}

// 查询 trait
pub trait Query {
    type Result;
}

// 命令处理器
pub trait CommandHandler<C: Command> {
    async fn handle(&self, command: C) -> Result<C::Result, CommandError>;
}

// 查询处理器
pub trait QueryHandler<Q: Query> {
    async fn handle(&self, query: Q) -> Result<Q::Result, QueryError>;
}

// 命令总线
pub struct CommandBus {
    handlers: std::collections::HashMap<std::any::TypeId, Box<dyn std::any::Any + Send + Sync>>,
}

impl CommandBus {
    pub fn new() -> Self {
        Self {
            handlers: std::collections::HashMap::new(),
        }
    }
    
    pub fn register_handler<C: Command, H: CommandHandler<C> + Send + Sync + 'static>(
        &mut self,
        handler: H,
    ) {
        self.handlers.insert(
            std::any::TypeId::of::<C>(),
            Box::new(handler),
        );
    }
    
    pub async fn execute<C: Command>(&self, command: C) -> Result<C::Result, CommandError> {
        let handler = self.handlers
            .get(&std::any::TypeId::of::<C>())
            .ok_or(CommandError::HandlerNotFound)?
            .downcast_ref::<Box<dyn CommandHandler<C> + Send + Sync>>()
            .ok_or(CommandError::HandlerNotFound)?;
        
        handler.handle(command).await
    }
}

// 查询总线
pub struct QueryBus {
    handlers: std::collections::HashMap<std::any::TypeId, Box<dyn std::any::Any + Send + Sync>>,
}

impl QueryBus {
    pub fn new() -> Self {
        Self {
            handlers: std::collections::HashMap::new(),
        }
    }
    
    pub fn register_handler<Q: Query, H: QueryHandler<Q> + Send + Sync + 'static>(
        &mut self,
        handler: H,
    ) {
        self.handlers.insert(
            std::any::TypeId::of::<Q>(),
            Box::new(handler),
        );
    }
    
    pub async fn execute<Q: Query>(&self, query: Q) -> Result<Q::Result, QueryError> {
        let handler = self.handlers
            .get(&std::any::TypeId::of::<Q>())
            .ok_or(QueryError::HandlerNotFound)?
            .downcast_ref::<Box<dyn QueryHandler<Q> + Send + Sync>>()
            .ok_or(QueryError::HandlerNotFound)?;
        
        handler.handle(query).await
    }
}

// 具体命令实现
#[derive(Debug, Clone)]
pub struct CreateUserCommand {
    pub name: String,
    pub email: String,
}

impl Command for CreateUserCommand {
    type Result = User;
}

#[derive(Debug, Clone)]
pub struct UpdateUserCommand {
    pub id: u64,
    pub name: Option<String>,
    pub email: Option<String>,
}

impl Command for UpdateUserCommand {
    type Result = User;
}

// 具体查询实现
#[derive(Debug, Clone)]
pub struct GetUserQuery {
    pub id: u64,
}

impl Query for GetUserQuery {
    type Result = Option<User>;
}

#[derive(Debug, Clone)]
pub struct ListUsersQuery {
    pub page: u32,
    pub size: u32,
}

impl Query for ListUsersQuery {
    type Result = Vec<User>;
}

// 命令处理器实现
pub struct CreateUserCommandHandler {
    user_repository: Arc<dyn UserRepository + Send + Sync>,
    event_bus: Arc<EventBus>,
}

impl CommandHandler<CreateUserCommand> for CreateUserCommandHandler {
    async fn handle(&self, command: CreateUserCommand) -> Result<User, CommandError> {
        // 创建用户
        let user = User {
            id: 0, // 将由数据库生成
            name: command.name,
            email: command.email,
            created_at: chrono::Utc::now(),
        };
        
        let saved_user = self.user_repository.save(&user).await?;
        
        // 发布事件
        let event = DomainEvent {
            event_id: uuid::Uuid::new_v4().to_string(),
            event_type: "UserCreated".to_string(),
            aggregate_id: saved_user.id.to_string(),
            aggregate_type: "User".to_string(),
            event_data: serde_json::to_value(&saved_user)?,
            metadata: std::collections::HashMap::new(),
            timestamp: chrono::Utc::now().timestamp() as u64,
            version: 1,
        };
        
        self.event_bus.publish(event).await?;
        
        Ok(saved_user)
    }
}

// 查询处理器实现
pub struct GetUserQueryHandler {
    user_repository: Arc<dyn UserRepository + Send + Sync>,
}

impl QueryHandler<GetUserQuery> for GetUserQueryHandler {
    async fn handle(&self, query: GetUserQuery) -> Result<Option<User>, QueryError> {
        self.user_repository.find_by_id(query.id).await
            .map_err(|e| QueryError::RepositoryError(e.to_string()))
    }
}
```

### 3. 领域驱动设计 (DDD)

#### 聚合根实现

```rust
use std::collections::VecDeque;

// 领域事件 trait
pub trait DomainEvent {
    fn event_type(&self) -> &str;
    fn aggregate_id(&self) -> &str;
    fn version(&self) -> u32;
}

// 聚合根 trait
pub trait AggregateRoot {
    type Event: DomainEvent + Clone;
    
    fn id(&self) -> &str;
    fn version(&self) -> u32;
    fn uncommitted_events(&self) -> &VecDeque<Self::Event>;
    fn mark_events_as_committed(&mut self);
}

// 用户聚合根
#[derive(Debug, Clone)]
pub struct User {
    id: String,
    name: String,
    email: String,
    status: UserStatus,
    version: u32,
    uncommitted_events: VecDeque<UserEvent>,
}

#[derive(Debug, Clone)]
pub enum UserStatus {
    Active,
    Inactive,
    Suspended,
}

#[derive(Debug, Clone)]
pub enum UserEvent {
    UserCreated {
        id: String,
        name: String,
        email: String,
        version: u32,
    },
    UserUpdated {
        id: String,
        name: String,
        email: String,
        version: u32,
    },
    UserStatusChanged {
        id: String,
        old_status: UserStatus,
        new_status: UserStatus,
        version: u32,
    },
    UserDeleted {
        id: String,
        version: u32,
    },
}

impl DomainEvent for UserEvent {
    fn event_type(&self) -> &str {
        match self {
            UserEvent::UserCreated { .. } => "UserCreated",
            UserEvent::UserUpdated { .. } => "UserUpdated",
            UserEvent::UserStatusChanged { .. } => "UserStatusChanged",
            UserEvent::UserDeleted { .. } => "UserDeleted",
        }
    }
    
    fn aggregate_id(&self) -> &str {
        match self {
            UserEvent::UserCreated { id, .. } => id,
            UserEvent::UserUpdated { id, .. } => id,
            UserEvent::UserStatusChanged { id, .. } => id,
            UserEvent::UserDeleted { id, .. } => id,
        }
    }
    
    fn version(&self) -> u32 {
        match self {
            UserEvent::UserCreated { version, .. } => *version,
            UserEvent::UserUpdated { version, .. } => *version,
            UserEvent::UserStatusChanged { version, .. } => *version,
            UserEvent::UserDeleted { version, .. } => *version,
        }
    }
}

impl AggregateRoot for User {
    type Event = UserEvent;
    
    fn id(&self) -> &str {
        &self.id
    }
    
    fn version(&self) -> u32 {
        self.version
    }
    
    fn uncommitted_events(&self) -> &VecDeque<Self::Event> {
        &self.uncommitted_events
    }
    
    fn mark_events_as_committed(&mut self) {
        self.uncommitted_events.clear();
    }
}

impl User {
    pub fn new(id: String, name: String, email: String) -> Self {
        let mut user = Self {
            id,
            name,
            email,
            status: UserStatus::Active,
            version: 1,
            uncommitted_events: VecDeque::new(),
        };
        
        user.add_event(UserEvent::UserCreated {
            id: user.id.clone(),
            name: user.name.clone(),
            email: user.email.clone(),
            version: user.version,
        });
        
        user
    }
    
    pub fn update(&mut self, name: String, email: String) -> Result<(), DomainError> {
        if self.status != UserStatus::Active {
            return Err(DomainError::UserNotActive);
        }
        
        self.name = name.clone();
        self.email = email.clone();
        self.version += 1;
        
        self.add_event(UserEvent::UserUpdated {
            id: self.id.clone(),
            name,
            email,
            version: self.version,
        });
        
        Ok(())
    }
    
    pub fn change_status(&mut self, new_status: UserStatus) -> Result<(), DomainError> {
        if self.status == new_status {
            return Ok(());
        }
        
        let old_status = std::mem::replace(&mut self.status, new_status);
        self.version += 1;
        
        self.add_event(UserEvent::UserStatusChanged {
            id: self.id.clone(),
            old_status,
            new_status: self.status.clone(),
            version: self.version,
        });
        
        Ok(())
    }
    
    pub fn delete(&mut self) -> Result<(), DomainError> {
        if self.status == UserStatus::Inactive {
            return Err(DomainError::UserAlreadyDeleted);
        }
        
        self.status = UserStatus::Inactive;
        self.version += 1;
        
        self.add_event(UserEvent::UserDeleted {
            id: self.id.clone(),
            version: self.version,
        });
        
        Ok(())
    }
    
    fn add_event(&mut self, event: UserEvent) {
        self.uncommitted_events.push_back(event);
    }
}

// 领域错误
#[derive(Debug, thiserror::Error)]
pub enum DomainError {
    #[error("User is not active")]
    UserNotActive,
    #[error("User is already deleted")]
    UserAlreadyDeleted,
    #[error("Invalid email format")]
    InvalidEmail,
    #[error("Invalid name")]
    InvalidName,
}
```

## 性能优化策略

### 1. 零成本抽象

```rust
// 使用 const 泛型实现零成本抽象
pub struct FixedSizeBuffer<const N: usize> {
    data: [u8; N],
    len: usize,
}

impl<const N: usize> FixedSizeBuffer<N> {
    pub fn new() -> Self {
        Self {
            data: [0; N],
            len: 0,
        }
    }
    
    pub fn push(&mut self, byte: u8) -> Result<(), BufferError> {
        if self.len >= N {
            return Err(BufferError::BufferFull);
        }
        
        self.data[self.len] = byte;
        self.len += 1;
        Ok(())
    }
    
    pub fn as_slice(&self) -> &[u8] {
        &self.data[..self.len]
    }
}

// 使用 const 泛型实现类型安全的配置
pub struct ServiceConfig<const MAX_CONNECTIONS: usize, const TIMEOUT_MS: u64> {
    pub max_connections: usize,
    pub timeout_ms: u64,
}

impl<const MAX_CONNECTIONS: usize, const TIMEOUT_MS: u64> ServiceConfig<MAX_CONNECTIONS, TIMEOUT_MS> {
    pub fn new() -> Self {
        Self {
            max_connections: MAX_CONNECTIONS,
            timeout_ms: TIMEOUT_MS,
        }
    }
}

// 编译时验证
type HighPerformanceConfig = ServiceConfig<1000, 100>;
type StandardConfig = ServiceConfig<100, 1000>;
```

### 2. 内存安全与并发优化

```rust
use std::sync::Arc;
use tokio::sync::{RwLock, Semaphore};
use std::collections::HashMap;

// 无锁数据结构
pub struct LockFreeCache<K, V> 
where
    K: Clone + std::hash::Hash + Eq + Send + Sync,
    V: Clone + Send + Sync,
{
    data: Arc<RwLock<HashMap<K, V>>>,
    semaphore: Arc<Semaphore>,
}

impl<K, V> LockFreeCache<K, V>
where
    K: Clone + std::hash::Hash + Eq + Send + Sync,
    V: Clone + Send + Sync,
{
    pub fn new(max_size: usize) -> Self {
        Self {
            data: Arc::new(RwLock::new(HashMap::new())),
            semaphore: Arc::new(Semaphore::new(max_size)),
        }
    }
    
    pub async fn get(&self, key: &K) -> Option<V> {
        let data = self.data.read().await;
        data.get(key).cloned()
    }
    
    pub async fn insert(&self, key: K, value: V) -> Result<(), CacheError> {
        let _permit = self.semaphore.acquire().await.map_err(|_| CacheError::SemaphoreError)?;
        
        let mut data = self.data.write().await;
        data.insert(key, value);
        
        Ok(())
    }
    
    pub async fn remove(&self, key: &K) -> Option<V> {
        let mut data = self.data.write().await;
        data.remove(key)
    }
}

// 内存池实现
pub struct MemoryPool<T> {
    pool: Arc<RwLock<Vec<Box<T>>>>,
    factory: Arc<dyn Fn() -> T + Send + Sync>,
}

impl<T> MemoryPool<T> {
    pub fn new<F>(factory: F, initial_size: usize) -> Self
    where
        F: Fn() -> T + Send + Sync + 'static,
    {
        let factory = Arc::new(factory);
        let mut pool = Vec::with_capacity(initial_size);
        
        for _ in 0..initial_size {
            pool.push(Box::new(factory()));
        }
        
        Self {
            pool: Arc::new(RwLock::new(pool)),
            factory,
        }
    }
    
    pub async fn acquire(&self) -> PooledObject<T> {
        let mut pool = self.pool.write().await;
        
        if let Some(obj) = pool.pop() {
            PooledObject::new(obj, self.pool.clone())
        } else {
            // 池为空时创建新对象
            let obj = Box::new((self.factory)());
            PooledObject::new(obj, self.pool.clone())
        }
    }
}

pub struct PooledObject<T> {
    obj: Option<Box<T>>,
    pool: Arc<RwLock<Vec<Box<T>>>>,
}

impl<T> PooledObject<T> {
    fn new(obj: Box<T>, pool: Arc<RwLock<Vec<Box<T>>>>) -> Self {
        Self {
            obj: Some(obj),
            pool,
        }
    }
    
    pub fn get(&self) -> &T {
        self.obj.as_ref().unwrap()
    }
    
    pub fn get_mut(&mut self) -> &mut T {
        self.obj.as_mut().unwrap()
    }
}

impl<T> Drop for PooledObject<T> {
    fn drop(&mut self) {
        if let Some(obj) = self.obj.take() {
            let pool = self.pool.clone();
            tokio::spawn(async move {
                let mut pool = pool.write().await;
                pool.push(obj);
            });
        }
    }
}
```

## 部署与运维

### 1. 容器化配置

```dockerfile
# 多阶段构建 Dockerfile
FROM rust:1.90-slim as builder

WORKDIR /app
COPY Cargo.toml Cargo.lock ./
COPY src ./src

# 构建优化
RUN cargo build --release --target x86_64-unknown-linux-musl

FROM scratch
COPY --from=builder /app/target/x86_64-unknown-linux-musl/release/microservice /app/microservice
EXPOSE 8080
CMD ["/app/microservice"]
```

### 2. Kubernetes 部署

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rust-microservice
  labels:
    app: rust-microservice
spec:
  replicas: 3
  selector:
    matchLabels:
      app: rust-microservice
  template:
    metadata:
      labels:
        app: rust-microservice
    spec:
      containers:
      - name: microservice
        image: rust-microservice:latest
        ports:
        - containerPort: 8080
        env:
        - name: RUST_LOG
          value: "info"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: database-secret
              key: url
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
```

## 总结

Rust 1.90 的现代化特性为构建高性能微服务架构提供了强大的工具：

1. **原生异步 Trait**: 简化异步编程，提高代码可读性
2. **泛型关联类型**: 提供更灵活的类型抽象能力
3. **类型别名 impl Trait**: 增强类型系统的表达能力
4. **零成本抽象**: 在编译时优化性能
5. **内存安全**: 提供并发安全的数据结构

通过合理运用这些特性，可以构建出既安全又高性能的现代化微服务系统，满足企业级应用的需求。
