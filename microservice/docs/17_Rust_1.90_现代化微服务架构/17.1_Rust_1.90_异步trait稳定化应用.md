# Rust 1.90 å¼‚æ­¥traitç¨³å®šåŒ–åº”ç”¨

> åŸºäºRust 1.90ç‰ˆæœ¬çš„å¼‚æ­¥traitç¨³å®šåŒ–ç‰¹æ€§ï¼Œæ„å»ºç°ä»£åŒ–å¾®æœåŠ¡æ¶æ„

## ğŸ“‹ ç›®å½•

- [æ¦‚è¿°](#æ¦‚è¿°)
- [Rust 1.90 å¼‚æ­¥traitæ–°ç‰¹æ€§](#rust-190-å¼‚æ­¥traitæ–°ç‰¹æ€§)
- [å¾®æœåŠ¡ä¸­çš„å¼‚æ­¥traitåº”ç”¨](#å¾®æœåŠ¡ä¸­çš„å¼‚æ­¥traitåº”ç”¨)
- [å®é™…ä»£ç ç¤ºä¾‹](#å®é™…ä»£ç ç¤ºä¾‹)
- [æ€§èƒ½ä¼˜åŒ–ä¸æœ€ä½³å®è·µ](#æ€§èƒ½ä¼˜åŒ–ä¸æœ€ä½³å®è·µ)
- [è¿ç§»æŒ‡å—](#è¿ç§»æŒ‡å—)
- [æ€»ç»“](#æ€»ç»“)

## æ¦‚è¿°

Rust 1.90ç‰ˆæœ¬æ­£å¼ç¨³å®šåŒ–äº†å¼‚æ­¥traitåŠŸèƒ½ï¼Œè¿™æ˜¯Rustå¼‚æ­¥ç¼–ç¨‹çš„ä¸€ä¸ªé‡è¦é‡Œç¨‹ç¢‘ã€‚
åœ¨å¾®æœåŠ¡æ¶æ„ä¸­ï¼Œå¼‚æ­¥traitçš„ç¨³å®šåŒ–å¸¦æ¥äº†ä»¥ä¸‹ä¼˜åŠ¿ï¼š

- **ç±»å‹å®‰å…¨**: ç¼–è¯‘æ—¶ä¿è¯å¼‚æ­¥ä»£ç çš„ç±»å‹å®‰å…¨
- **æ€§èƒ½æå‡**: é›¶æˆæœ¬æŠ½è±¡ï¼Œè¿è¡Œæ—¶æ€§èƒ½ä¸æ‰‹å†™å¼‚æ­¥ä»£ç ç›¸å½“
- **ä»£ç ç®€åŒ–**: å‡å°‘æ ·æ¿ä»£ç ï¼Œæé«˜å¼€å‘æ•ˆç‡
- **ç”Ÿæ€å…¼å®¹**: ä¸ç°æœ‰å¼‚æ­¥ç”Ÿæ€å®Œç¾å…¼å®¹

## Rust 1.90 å¼‚æ­¥traitæ–°ç‰¹æ€§

### 1. ç¨³å®šçš„async fn in trait

```rust
// Rust 1.90ä¹‹å‰éœ€è¦ä½¿ç”¨async-traitå®
#[async_trait]
trait AsyncService {
    async fn process(&self, data: Vec<u8>) -> Result<String, Error>;
}

// Rust 1.90å¯ä»¥ç›´æ¥ä½¿ç”¨
trait AsyncService {
    async fn process(&self, data: Vec<u8>) -> Result<String, Error>;
}
```

### 2. æ³›å‹å…³è”ç±»å‹(GAT)æ”¯æŒ

```rust
trait AsyncIterator {
    type Item<'a> where Self: 'a;
    type Future<'a>: Future<Output = Option<Self::Item<'a>>> where Self: 'a;
    
    fn next<'a>(&'a mut self) -> Self::Future<'a>;
}
```

### 3. ç±»å‹åˆ«åimpl Trait(TAIT)

```rust
type ServiceResult<T> = impl Future<Output = Result<T, ServiceError>>;

trait MicroService {
    fn handle_request(&self, req: Request) -> ServiceResult<Response>;
}
```

## å¾®æœåŠ¡ä¸­çš„å¼‚æ­¥traitåº”ç”¨

### 1. æœåŠ¡æ¥å£å®šä¹‰

```rust
use std::future::Future;
use std::pin::Pin;
use anyhow::Result;

/// å¾®æœåŠ¡åŸºç¡€trait
pub trait MicroService {
    type Config;
    type Error;
    
    /// åˆå§‹åŒ–æœåŠ¡
    async fn initialize(&mut self, config: Self::Config) -> Result<(), Self::Error>;
    
    /// å¯åŠ¨æœåŠ¡
    async fn start(&self) -> Result<(), Self::Error>;
    
    /// åœæ­¢æœåŠ¡
    async fn stop(&self) -> Result<(), Self::Error>;
    
    /// å¥åº·æ£€æŸ¥
    async fn health_check(&self) -> Result<HealthStatus, Self::Error>;
    
    /// å¤„ç†è¯·æ±‚
    async fn handle_request(&self, request: Request) -> Result<Response, Self::Error>;
}

/// æ•°æ®æœåŠ¡trait
pub trait DataService: MicroService {
    /// å¼‚æ­¥æ•°æ®æŸ¥è¯¢
    async fn query<T>(&self, query: Query) -> Result<Vec<T>, Self::Error>
    where
        T: serde::de::DeserializeOwned;
    
    /// å¼‚æ­¥æ•°æ®æ’å…¥
    async fn insert<T>(&self, data: T) -> Result<String, Self::Error>
    where
        T: serde::Serialize;
    
    /// å¼‚æ­¥æ•°æ®æ›´æ–°
    async fn update<T>(&self, id: &str, data: T) -> Result<(), Self::Error>
    where
        T: serde::Serialize;
    
    /// å¼‚æ­¥æ•°æ®åˆ é™¤
    async fn delete(&self, id: &str) -> Result<(), Self::Error>;
}

/// æ¶ˆæ¯æœåŠ¡trait
pub trait MessageService: MicroService {
    /// å¼‚æ­¥å‘é€æ¶ˆæ¯
    async fn send_message(&self, topic: &str, message: Message) -> Result<(), Self::Error>;
    
    /// å¼‚æ­¥è®¢é˜…æ¶ˆæ¯
    async fn subscribe<F>(&self, topic: &str, handler: F) -> Result<(), Self::Error>
    where
        F: Fn(Message) -> Pin<Box<dyn Future<Output = Result<(), Self::Error>> + Send + '_>> + Send + Sync;
    
    /// å¼‚æ­¥æ‰¹é‡å‘é€
    async fn send_batch(&self, messages: Vec<(String, Message)>) -> Result<(), Self::Error>;
}
```

### 2. æœåŠ¡å®ç°

```rust
use tokio::sync::RwLock;
use std::collections::HashMap;
use std::sync::Arc;

/// ç”¨æˆ·æœåŠ¡å®ç°
pub struct UserService {
    users: Arc<RwLock<HashMap<String, User>>>,
    config: UserServiceConfig,
}

#[derive(Debug, Clone)]
pub struct User {
    pub id: String,
    pub name: String,
    pub email: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone)]
pub struct UserServiceConfig {
    pub max_users: usize,
    pub cache_ttl: std::time::Duration,
}

#[derive(Debug, thiserror::Error)]
pub enum UserServiceError {
    #[error("ç”¨æˆ·ä¸å­˜åœ¨: {0}")]
    UserNotFound(String),
    #[error("ç”¨æˆ·å·²å­˜åœ¨: {0}")]
    UserExists(String),
    #[error("é…ç½®é”™è¯¯: {0}")]
    ConfigError(String),
    #[error("æ•°æ®åº“é”™è¯¯: {0}")]
    DatabaseError(String),
}

impl MicroService for UserService {
    type Config = UserServiceConfig;
    type Error = UserServiceError;
    
    async fn initialize(&mut self, config: Self::Config) -> Result<(), Self::Error> {
        self.config = config;
        tracing::info!("ç”¨æˆ·æœåŠ¡åˆå§‹åŒ–å®Œæˆ");
        Ok(())
    }
    
    async fn start(&self) -> Result<(), Self::Error> {
        tracing::info!("ç”¨æˆ·æœåŠ¡å¯åŠ¨");
        Ok(())
    }
    
    async fn stop(&self) -> Result<(), Self::Error> {
        tracing::info!("ç”¨æˆ·æœåŠ¡åœæ­¢");
        Ok(())
    }
    
    async fn health_check(&self) -> Result<HealthStatus, Self::Error> {
        let user_count = self.users.read().await.len();
        Ok(HealthStatus {
            service: "user-service".to_string(),
            status: if user_count < self.config.max_users {
                "healthy".to_string()
            } else {
                "degraded".to_string()
            },
            timestamp: chrono::Utc::now(),
            metrics: HashMap::from([
                ("user_count".to_string(), user_count.to_string()),
                ("max_users".to_string(), self.config.max_users.to_string()),
            ]),
        })
    }
    
    async fn handle_request(&self, request: Request) -> Result<Response, Self::Error> {
        match request.method.as_str() {
            "GET" => self.get_user(&request.path).await,
            "POST" => self.create_user(request.body).await,
            "PUT" => self.update_user(&request.path, request.body).await,
            "DELETE" => self.delete_user(&request.path).await,
            _ => Err(UserServiceError::ConfigError("ä¸æ”¯æŒçš„HTTPæ–¹æ³•".to_string())),
        }
    }
}

impl DataService for UserService {
    async fn query<T>(&self, query: Query) -> Result<Vec<T>, Self::Error>
    where
        T: serde::de::DeserializeOwned,
    {
        // å®ç°å¼‚æ­¥æŸ¥è¯¢é€»è¾‘
        let users = self.users.read().await;
        let results: Vec<T> = users
            .values()
            .filter(|user| {
                // æ ¹æ®æŸ¥è¯¢æ¡ä»¶è¿‡æ»¤
                query.filters.iter().all(|filter| {
                    match filter.field.as_str() {
                        "name" => user.name.contains(&filter.value),
                        "email" => user.email.contains(&filter.value),
                        _ => true,
                    }
                })
            })
            .map(|user| serde_json::from_value(serde_json::to_value(user).unwrap()).unwrap())
            .collect();
        
        Ok(results)
    }
    
    async fn insert<T>(&self, data: T) -> Result<String, Self::Error>
    where
        T: serde::Serialize,
    {
        let user: User = serde_json::from_value(serde_json::to_value(data)?)
            .map_err(|e| UserServiceError::ConfigError(e.to_string()))?;
        
        let mut users = self.users.write().await;
        if users.contains_key(&user.id) {
            return Err(UserServiceError::UserExists(user.id));
        }
        
        users.insert(user.id.clone(), user);
        Ok("ç”¨æˆ·åˆ›å»ºæˆåŠŸ".to_string())
    }
    
    async fn update<T>(&self, id: &str, data: T) -> Result<(), Self::Error>
    where
        T: serde::Serialize,
    {
        let updated_user: User = serde_json::from_value(serde_json::to_value(data)?)
            .map_err(|e| UserServiceError::ConfigError(e.to_string()))?;
        
        let mut users = self.users.write().await;
        if !users.contains_key(id) {
            return Err(UserServiceError::UserNotFound(id.to_string()));
        }
        
        users.insert(id.to_string(), updated_user);
        Ok(())
    }
    
    async fn delete(&self, id: &str) -> Result<(), Self::Error> {
        let mut users = self.users.write().await;
        if users.remove(id).is_none() {
            return Err(UserServiceError::UserNotFound(id.to_string()));
        }
        Ok(())
    }
}

impl UserService {
    pub fn new() -> Self {
        Self {
            users: Arc::new(RwLock::new(HashMap::new())),
            config: UserServiceConfig {
                max_users: 1000,
                cache_ttl: std::time::Duration::from_secs(300),
            },
        }
    }
    
    async fn get_user(&self, path: &str) -> Result<Response, UserServiceError> {
        let user_id = path.trim_start_matches("/users/");
        let users = self.users.read().await;
        
        match users.get(user_id) {
            Some(user) => Ok(Response {
                status: 200,
                body: serde_json::to_string(user).unwrap(),
                headers: HashMap::from([("Content-Type".to_string(), "application/json".to_string())]),
            }),
            None => Err(UserServiceError::UserNotFound(user_id.to_string())),
        }
    }
    
    async fn create_user(&self, body: String) -> Result<Response, UserServiceError> {
        let user: User = serde_json::from_str(&body)
            .map_err(|e| UserServiceError::ConfigError(e.to_string()))?;
        
        let mut users = self.users.write().await;
        if users.contains_key(&user.id) {
            return Err(UserServiceError::UserExists(user.id));
        }
        
        users.insert(user.id.clone(), user.clone());
        Ok(Response {
            status: 201,
            body: serde_json::to_string(&user).unwrap(),
            headers: HashMap::from([("Content-Type".to_string(), "application/json".to_string())]),
        })
    }
    
    async fn update_user(&self, path: &str, body: String) -> Result<Response, UserServiceError> {
        let user_id = path.trim_start_matches("/users/");
        let updated_user: User = serde_json::from_str(&body)
            .map_err(|e| UserServiceError::ConfigError(e.to_string()))?;
        
        let mut users = self.users.write().await;
        if !users.contains_key(user_id) {
            return Err(UserServiceError::UserNotFound(user_id.to_string()));
        }
        
        users.insert(user_id.to_string(), updated_user.clone());
        Ok(Response {
            status: 200,
            body: serde_json::to_string(&updated_user).unwrap(),
            headers: HashMap::from([("Content-Type".to_string(), "application/json".to_string())]),
        })
    }
    
    async fn delete_user(&self, path: &str) -> Result<Response, UserServiceError> {
        let user_id = path.trim_start_matches("/users/");
        let mut users = self.users.write().await;
        
        if users.remove(user_id).is_none() {
            return Err(UserServiceError::UserNotFound(user_id.to_string()));
        }
        
        Ok(Response {
            status: 204,
            body: String::new(),
            headers: HashMap::new(),
        })
    }
}
```

### 3. æœåŠ¡ç»„åˆä¸ç¼–æ’

```rust
/// æœåŠ¡ç¼–æ’å™¨
pub struct ServiceOrchestrator {
    services: Arc<RwLock<HashMap<String, Box<dyn MicroService<Error = Box<dyn std::error::Error + Send + Sync>> + Send + Sync>>>>,
}

impl ServiceOrchestrator {
    pub fn new() -> Self {
        Self {
            services: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    /// æ³¨å†ŒæœåŠ¡
    pub async fn register_service<S>(&self, name: String, service: S) -> Result<(), Box<dyn std::error::Error + Send + Sync>>
    where
        S: MicroService + Send + Sync + 'static,
        S::Error: std::error::Error + Send + Sync + 'static,
    {
        let mut services = self.services.write().await;
        services.insert(name, Box::new(service));
        Ok(())
    }
    
    /// å¯åŠ¨æ‰€æœ‰æœåŠ¡
    pub async fn start_all(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let services = self.services.read().await;
        for (name, service) in services.iter() {
            tracing::info!("å¯åŠ¨æœåŠ¡: {}", name);
            service.start().await?;
        }
        Ok(())
    }
    
    /// åœæ­¢æ‰€æœ‰æœåŠ¡
    pub async fn stop_all(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let services = self.services.read().await;
        for (name, service) in services.iter() {
            tracing::info!("åœæ­¢æœåŠ¡: {}", name);
            service.stop().await?;
        }
        Ok(())
    }
    
    /// å¥åº·æ£€æŸ¥æ‰€æœ‰æœåŠ¡
    pub async fn health_check_all(&self) -> HashMap<String, HealthStatus> {
        let services = self.services.read().await;
        let mut health_status = HashMap::new();
        
        for (name, service) in services.iter() {
            match service.health_check().await {
                Ok(status) => {
                    health_status.insert(name.clone(), status);
                }
                Err(e) => {
                    tracing::error!("æœåŠ¡ {} å¥åº·æ£€æŸ¥å¤±è´¥: {}", name, e);
                    health_status.insert(name.clone(), HealthStatus {
                        service: name.clone(),
                        status: "unhealthy".to_string(),
                        timestamp: chrono::Utc::now(),
                        metrics: HashMap::from([("error".to_string(), e.to_string())]),
                    });
                }
            }
        }
        
        health_status
    }
}
```

## å®é™…ä»£ç ç¤ºä¾‹

### 1. å®Œæ•´çš„å¾®æœåŠ¡åº”ç”¨

```rust
use tokio::net::TcpListener;
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    // åˆå§‹åŒ–æ—¥å¿—
    tracing_subscriber::fmt::init();
    
    // åˆ›å»ºæœåŠ¡ç¼–æ’å™¨
    let orchestrator = Arc::new(ServiceOrchestrator::new());
    
    // åˆ›å»ºå¹¶æ³¨å†Œç”¨æˆ·æœåŠ¡
    let user_service = UserService::new();
    orchestrator.register_service("user-service".to_string(), user_service).await?;
    
    // å¯åŠ¨æ‰€æœ‰æœåŠ¡
    orchestrator.start_all().await?;
    
    // å¯åŠ¨HTTPæœåŠ¡å™¨
    let listener = TcpListener::bind("127.0.0.1:8080").await?;
    tracing::info!("æœåŠ¡å™¨å¯åŠ¨åœ¨ http://127.0.0.1:8080");
    
    loop {
        let (stream, _) = listener.accept().await?;
        let orchestrator = orchestrator.clone();
        
        tokio::spawn(async move {
            if let Err(e) = handle_connection(stream, orchestrator).await {
                tracing::error!("å¤„ç†è¿æ¥æ—¶å‡ºé”™: {}", e);
            }
        });
    }
}

async fn handle_connection(
    stream: tokio::net::TcpStream,
    orchestrator: Arc<ServiceOrchestrator>,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    // ç®€åŒ–çš„HTTPå¤„ç†é€»è¾‘
    // å®é™…åº”ç”¨ä¸­åº”è¯¥ä½¿ç”¨å®Œæ•´çš„HTTPæ¡†æ¶å¦‚Axumæˆ–Actix-web
    
    // è§£æHTTPè¯·æ±‚
    let request = parse_http_request(stream).await?;
    
    // è·¯ç”±åˆ°ç›¸åº”çš„æœåŠ¡
    match request.path.as_str() {
        path if path.starts_with("/users") => {
            // è·å–ç”¨æˆ·æœåŠ¡å¹¶å¤„ç†è¯·æ±‚
            let services = orchestrator.services.read().await;
            if let Some(service) = services.get("user-service") {
                let response = service.handle_request(request).await?;
                // å‘é€å“åº”
                send_http_response(response).await?;
            }
        }
        "/health" => {
            // å¥åº·æ£€æŸ¥
            let health_status = orchestrator.health_check_all().await;
            let response = Response {
                status: 200,
                body: serde_json::to_string(&health_status)?,
                headers: HashMap::from([("Content-Type".to_string(), "application/json".to_string())]),
            };
            send_http_response(response).await?;
        }
        _ => {
            // 404 Not Found
            let response = Response {
                status: 404,
                body: "Not Found".to_string(),
                headers: HashMap::new(),
            };
            send_http_response(response).await?;
        }
    }
    
    Ok(())
}
```

### 2. å¼‚æ­¥ä¸­é—´ä»¶ç³»ç»Ÿ

```rust
/// å¼‚æ­¥ä¸­é—´ä»¶trait
pub trait AsyncMiddleware {
    async fn process(&self, request: &mut Request, next: Next) -> Result<Response, Box<dyn std::error::Error + Send + Sync>>;
}

/// ä¸­é—´ä»¶é“¾
pub struct MiddlewareChain {
    middlewares: Vec<Box<dyn AsyncMiddleware + Send + Sync>>,
}

impl MiddlewareChain {
    pub fn new() -> Self {
        Self {
            middlewares: Vec::new(),
        }
    }
    
    pub fn add_middleware<M>(&mut self, middleware: M)
    where
        M: AsyncMiddleware + Send + Sync + 'static,
    {
        self.middlewares.push(Box::new(middleware));
    }
    
    pub async fn execute(&self, mut request: Request) -> Result<Response, Box<dyn std::error::Error + Send + Sync>> {
        let mut index = 0;
        self.execute_next(&mut request, &mut index).await
    }
    
    async fn execute_next(&self, request: &mut Request, index: &mut usize) -> Result<Response, Box<dyn std::error::Error + Send + Sync>> {
        if *index >= self.middlewares.len() {
            // æ‰€æœ‰ä¸­é—´ä»¶å¤„ç†å®Œæ¯•ï¼Œè¿”å›é»˜è®¤å“åº”
            return Ok(Response {
                status: 404,
                body: "Not Found".to_string(),
                headers: HashMap::new(),
            });
        }
        
        let middleware = &self.middlewares[*index];
        *index += 1;
        
        let next = Next {
            chain: self,
            index: *index,
        };
        
        middleware.process(request, next).await
    }
}

pub struct Next<'a> {
    chain: &'a MiddlewareChain,
    index: usize,
}

impl<'a> Next<'a> {
    pub async fn call(mut self, request: &mut Request) -> Result<Response, Box<dyn std::error::Error + Send + Sync>> {
        if self.index >= self.chain.middlewares.len() {
            return Ok(Response {
                status: 404,
                body: "Not Found".to_string(),
                headers: HashMap::new(),
            });
        }
        
        let middleware = &self.chain.middlewares[self.index];
        self.index += 1;
        
        let next = Next {
            chain: self.chain,
            index: self.index,
        };
        
        middleware.process(request, next).await
    }
}

/// æ—¥å¿—ä¸­é—´ä»¶
pub struct LoggingMiddleware;

impl AsyncMiddleware for LoggingMiddleware {
    async fn process(&self, request: &mut Request, next: Next) -> Result<Response, Box<dyn std::error::Error + Send + Sync>> {
        let start_time = std::time::Instant::now();
        tracing::info!("è¯·æ±‚å¼€å§‹: {} {}", request.method, request.path);
        
        let response = next.call(request).await?;
        
        let duration = start_time.elapsed();
        tracing::info!("è¯·æ±‚å®Œæˆ: {} {} - {}ms", request.method, request.path, duration.as_millis());
        
        Ok(response)
    }
}

/// è®¤è¯ä¸­é—´ä»¶
pub struct AuthMiddleware {
    jwt_secret: String,
}

impl AuthMiddleware {
    pub fn new(jwt_secret: String) -> Self {
        Self { jwt_secret }
    }
}

impl AsyncMiddleware for AuthMiddleware {
    async fn process(&self, request: &mut Request, next: Next) -> Result<Response, Box<dyn std::error::Error + Send + Sync>> {
        // æ£€æŸ¥è®¤è¯å¤´
        if let Some(auth_header) = request.headers.get("Authorization") {
            if let Ok(token) = verify_jwt_token(auth_header, &self.jwt_secret).await {
                request.metadata.insert("user_id".to_string(), token.sub);
                return next.call(request).await;
            }
        }
        
        // æœªè®¤è¯ï¼Œè¿”å›401
        Ok(Response {
            status: 401,
            body: "Unauthorized".to_string(),
            headers: HashMap::from([("WWW-Authenticate".to_string(), "Bearer".to_string())]),
        })
    }
}
```

## æ€§èƒ½ä¼˜åŒ–ä¸æœ€ä½³å®è·µ

### 1. å¼‚æ­¥traitæ€§èƒ½ä¼˜åŒ–

```rust
/// é«˜æ€§èƒ½å¼‚æ­¥æœåŠ¡å®ç°
pub struct HighPerformanceService {
    // ä½¿ç”¨æ— é”æ•°æ®ç»“æ„
    cache: Arc<dashmap::DashMap<String, String>>,
    // ä½¿ç”¨å¯¹è±¡æ± å‡å°‘åˆ†é…
    request_pool: Arc<tokio::sync::Semaphore>,
    // ä½¿ç”¨æ‰¹é‡å¤„ç†
    batch_processor: Arc<tokio::sync::Mutex<Vec<Request>>>,
}

impl HighPerformanceService {
    pub fn new(max_concurrent: usize) -> Self {
        Self {
            cache: Arc::new(dashmap::DashMap::new()),
            request_pool: Arc::new(tokio::sync::Semaphore::new(max_concurrent)),
            batch_processor: Arc::new(tokio::sync::Mutex::new(Vec::new())),
        }
    }
    
    /// æ‰¹é‡å¤„ç†è¯·æ±‚ä»¥æé«˜ååé‡
    pub async fn process_batch(&self, requests: Vec<Request>) -> Result<Vec<Response>, ServiceError> {
        let mut responses = Vec::with_capacity(requests.len());
        
        // å¹¶è¡Œå¤„ç†è¯·æ±‚
        let futures: Vec<_> = requests
            .into_iter()
            .map(|request| self.process_single(request))
            .collect();
        
        let results = futures::future::join_all(futures).await;
        
        for result in results {
            match result {
                Ok(response) => responses.push(response),
                Err(e) => {
                    tracing::error!("å¤„ç†è¯·æ±‚å¤±è´¥: {}", e);
                    responses.push(Response {
                        status: 500,
                        body: "Internal Server Error".to_string(),
                        headers: HashMap::new(),
                    });
                }
            }
        }
        
        Ok(responses)
    }
    
    async fn process_single(&self, request: Request) -> Result<Response, ServiceError> {
        // è·å–ä¿¡å·é‡è®¸å¯
        let _permit = self.request_pool.acquire().await
            .map_err(|_| ServiceError::ResourceExhausted)?;
        
        // æ£€æŸ¥ç¼“å­˜
        if let Some(cached) = self.cache.get(&request.path) {
            return Ok(Response {
                status: 200,
                body: cached.clone(),
                headers: HashMap::from([("X-Cache".to_string(), "HIT".to_string())]),
            });
        }
        
        // å¤„ç†è¯·æ±‚
        let response = self.handle_request_internal(request).await?;
        
        // ç¼“å­˜å“åº”
        if response.status == 200 {
            self.cache.insert(response.body.clone(), response.body.clone());
        }
        
        Ok(response)
    }
}
```

### 2. å†…å­˜ä¼˜åŒ–ç­–ç•¥

```rust
/// é›¶æ‹·è´æ•°æ®å¤„ç†
pub struct ZeroCopyProcessor {
    buffer_pool: Arc<tokio::sync::Mutex<Vec<Vec<u8>>>>,
    max_buffer_size: usize,
}

impl ZeroCopyProcessor {
    pub fn new(max_buffers: usize) -> Self {
        Self {
            buffer_pool: Arc::new(tokio::sync::Mutex::new(Vec::with_capacity(max_buffers))),
            max_buffer_size: 8192,
        }
    }
    
    /// è·å–ç¼“å†²åŒº
    pub async fn get_buffer(&self) -> Vec<u8> {
        let mut pool = self.buffer_pool.lock().await;
        pool.pop().unwrap_or_else(|| Vec::with_capacity(self.max_buffer_size))
    }
    
    /// å½’è¿˜ç¼“å†²åŒº
    pub async fn return_buffer(&self, mut buffer: Vec<u8>) {
        buffer.clear();
        if buffer.capacity() <= self.max_buffer_size {
            let mut pool = self.buffer_pool.lock().await;
            if pool.len() < pool.capacity() {
                pool.push(buffer);
            }
        }
    }
    
    /// é›¶æ‹·è´æ•°æ®å¤„ç†
    pub async fn process_data(&self, data: &[u8]) -> Result<Vec<u8>, ProcessingError> {
        let mut buffer = self.get_buffer().await;
        
        // ä½¿ç”¨ç¼“å†²åŒºå¤„ç†æ•°æ®ï¼Œé¿å…ä¸å¿…è¦çš„å†…å­˜åˆ†é…
        buffer.extend_from_slice(data);
        
        // å¤„ç†æ•°æ®...
        let result = self.transform_data(&buffer).await?;
        
        // å½’è¿˜ç¼“å†²åŒº
        self.return_buffer(buffer).await;
        
        Ok(result)
    }
}
```

## è¿ç§»æŒ‡å—

### ä»async-traitå®è¿ç§»

```rust
// è¿ç§»å‰ (ä½¿ç”¨async-traitå®)
#[async_trait]
trait OldAsyncService {
    async fn process(&self, data: Vec<u8>) -> Result<String, Error>;
}

// è¿ç§»å (ä½¿ç”¨Rust 1.90åŸç”Ÿæ”¯æŒ)
trait NewAsyncService {
    async fn process(&self, data: Vec<u8>) -> Result<String, Error>;
}
```

### å¤„ç†ç”Ÿå‘½å‘¨æœŸé—®é¢˜

```rust
// ä½¿ç”¨GATå¤„ç†å¤æ‚çš„ç”Ÿå‘½å‘¨æœŸ
trait AsyncDataProcessor {
    type Item<'a> where Self: 'a;
    type Future<'a>: Future<Output = Result<Self::Item<'a>, Error>> where Self: 'a;
    
    fn process<'a>(&'a self, data: &'a [u8]) -> Self::Future<'a>;
}

impl AsyncDataProcessor for MyProcessor {
    type Item<'a> = &'a str;
    type Future<'a> = Pin<Box<dyn Future<Output = Result<&'a str, Error>> + 'a>>;
    
    fn process<'a>(&'a self, data: &'a [u8]) -> Self::Future<'a> {
        Box::pin(async move {
            // å¤„ç†æ•°æ®ï¼Œè¿”å›å¼•ç”¨
            std::str::from_utf8(data).map_err(|_| Error::InvalidUtf8)
        })
    }
}
```

## æ€»ç»“

Rust 1.90çš„å¼‚æ­¥traitç¨³å®šåŒ–ä¸ºå¾®æœåŠ¡å¼€å‘å¸¦æ¥äº†é‡å¤§æ”¹è¿›ï¼š

1. **å¼€å‘ä½“éªŒæå‡**: å‡å°‘äº†æ ·æ¿ä»£ç ï¼Œæé«˜äº†å¼€å‘æ•ˆç‡
2. **æ€§èƒ½ä¼˜åŒ–**: é›¶æˆæœ¬æŠ½è±¡ï¼Œè¿è¡Œæ—¶æ€§èƒ½ä¼˜å¼‚
3. **ç±»å‹å®‰å…¨**: ç¼–è¯‘æ—¶ä¿è¯å¼‚æ­¥ä»£ç çš„æ­£ç¡®æ€§
4. **ç”Ÿæ€å…¼å®¹**: ä¸ç°æœ‰å¼‚æ­¥ç”Ÿæ€å®Œç¾é›†æˆ

é€šè¿‡åˆç†ä½¿ç”¨å¼‚æ­¥traitã€GATå’ŒTAITç­‰æ–°ç‰¹æ€§ï¼Œå¯ä»¥æ„å»ºé«˜æ€§èƒ½ã€ç±»å‹å®‰å…¨çš„ç°ä»£åŒ–å¾®æœåŠ¡æ¶æ„ã€‚åœ¨å®é™…åº”ç”¨ä¸­ï¼Œå»ºè®®ï¼š

- ä¼˜å…ˆä½¿ç”¨åŸç”Ÿå¼‚æ­¥traitæ›¿ä»£async-traitå®
- åˆ©ç”¨GATå¤„ç†å¤æ‚çš„ç”Ÿå‘½å‘¨æœŸé—®é¢˜
- ä½¿ç”¨TAITç®€åŒ–å¤æ‚çš„è¿”å›ç±»å‹
- ç»“åˆæ€§èƒ½ä¼˜åŒ–ç­–ç•¥æå‡æ•´ä½“æ€§èƒ½

è¿™äº›ç‰¹æ€§ä½¿å¾—Ruståœ¨å¾®æœåŠ¡é¢†åŸŸæ›´å…·ç«äº‰åŠ›ï¼Œä¸ºæ„å»ºç°ä»£åŒ–ã€é«˜æ€§èƒ½çš„å¾®æœåŠ¡ç³»ç»Ÿæä¾›äº†å¼ºå¤§çš„è¯­è¨€æ”¯æŒã€‚
